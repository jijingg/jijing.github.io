{"pages":[{"title":"索引置顶","text":"Lambda演算python实现 2019-04-19: lambda演算python实现.(二)之数字和运算 2019-04-19: lambda演算python实现.(三)之Bool值和逻辑运算 Scala 笔记 2019-03-08: SCALA 程序初探.一(main函数) 2019-03-08: SCALA 程序初探.二(package组织方式) 2019-03-08: SCALA 程序初探.三(sbt组织scala代码1) 2019-03-08: SCALA 程序初探.四(sbt组织scala代码2) RISCV 开发调试 2018-11-28: IDEA scala chisel环境配置 2018-11-28: Makefile使用笔记 2018-11-27: RISC-V 编译链接脚本 2018-11-20: RISC-V C代码编译调试笔记 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-15: RISCV-Vector介绍 Chisel 笔记 2018-12-05: Chisel 示例问题汇总 2019-03-21: chisel 组合逻辑，时序逻辑写法 2019-04-01: chisel Keep变量名 2019-04-11: chisel 版本问题 2019-03-20: Chisel-Verilog 查找表优先级问题讨论 EDA工具 如何从shell中传递变量给verilog文件 EDA仿真环境Makefile配置(vcs,verdi) 时序分析回顾 Moudle名冲突解决办法 仿真不打拍 收藏 Python lambda Y组合子(Y算子)实现 通信 AGC调整 其他 Terminal Shell 常见配置问题 RISCV ISA todo list Markdown 使用手册 晶振,PLL,VCO初识 计算机大小端详解 进程通信，消息队列","link":"/top-index.html"},{"title":"","text":"","link":"/about/index.html"},{"title":"","text":"RISCV SCALA Chisel EDA","link":"/topic/index.html"},{"title":"","text":"Lambda演算python实现 2019-04-19: lambda演算python实现.(二)之数字和运算 2019-04-19: lambda演算python实现.(三)之Bool值和逻辑运算 Scala 笔记 2019-03-08: SCALA 程序初探.一(main函数) 2019-03-08: SCALA 程序初探.二(package组织方式) 2019-03-08: SCALA 程序初探.三(sbt组织scala代码1) 2019-03-08: SCALA 程序初探.四(sbt组织scala代码2) RISCV 开发调试 2018-11-28: IDEA scala chisel环境配置 2018-11-28: Makefile使用笔记 2018-11-27: RISC-V 编译链接脚本 2018-11-20: RISC-V C代码编译调试笔记 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-15: RISCV-Vector介绍 Chisel 笔记 2018-12-05: Chisel 示例问题汇总 2019-03-21: chisel 组合逻辑，时序逻辑写法 2019-04-01: chisel Keep变量名 2019-04-11: chisel 版本问题 2019-03-20: Chisel-Verilog 查找表优先级问题讨论 EDA工具 如何从shell中传递变量给verilog文件 EDA仿真环境Makefile配置(vcs,verdi) 时序分析回顾 Moudle名冲突解决办法 仿真不打拍 收藏 Python lambda Y组合子(Y算子)实现 通信 AGC调整 其他 Terminal Shell 常见配置问题 RISCV ISA todo list Markdown 使用手册 晶振,PLL,VCO初识 计算机大小端详解 进程通信，消息队列","link":"/main/index.html"}],"posts":[{"title":"索引置顶","text":"Lambda演算python实现 2019-04-19: lambda演算python实现.[二]之数字和运算 2019-04-19: lambda演算python实现.[三]之Bool值和逻辑运算 Scala 笔记 2019-03-08: SCALA 程序初探.一(main函数) 2019-03-08: SCALA 程序初探.二(package组织方式) 2019-03-08: SCALA 程序初探.三(sbt组织scala代码1) 2019-03-08: SCALA 程序初探.四(sbt组织scala代码2) RISCV 开发调试 2018-11-28: IDEA scala chisel环境配置 2018-11-28: Makefile使用笔记 2018-11-27: RISC-V 编译链接脚本 2018-11-20: RISC-V C代码编译调试笔记 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-15: RISCV-Vector介绍 Chisel 笔记 2018-12-05: Chisel 示例问题汇总 2019-03-21: chisel 组合逻辑，时序逻辑写法 2019-04-01: chisel Keep变量名 2019-04-11: chisel 版本问题 2019-03-20: Chisel-Verilog 查找表优先级问题讨论 EDA工具 如何从shell中传递变量给verilog文件 EDA仿真环境Makefile配置(vcs,verdi) 时序分析回顾 Moudle名冲突解决办法 仿真不打拍 收藏 Python lambda Y组合子(Y算子)实现 通信 AGC调整 其他 Terminal Shell 常见配置问题 RISCV ISA todo list Markdown 使用手册 晶振,PLL,VCO初识 计算机大小端详解 进程通信，消息队列","link":"/top-index.html"},{"title":"C语言指针注解","text":"C语言指针实例指针的类型可以是int，double，float，struct …. 决定指针内部存放的数据大小，如果定义的是一个数组，类型可以让编译器 在p++是跳多少个大小的地址12345678910111213#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; void main(){ double array[5] = {1,2,3,4,5} ; int i ; // double *p = &amp;array[0] ;//跟下面等价 double *p = array ; //表示一个double的指针, 初始化指向array的首地址 for (i=0;i&lt;5;i++){ printf(\"@%p array[%d]=%f,%p\\n\",&amp;array[i],i,*p,p) ; //取值 *p p++; //p++ 会按照double 8个字节来增加，编译器会帮你自动搞定 }} 结构体指针12345678910111213141516171819202122struct Books { //总共占256个字节，16进制就是0x100个字节 char title[50]; char author[50]; char subject[152]; int book_id;};void main(){ struct Books booklist[5] ; int i ; struct Books *p = booklist ; //表示一个占Books struct的指针 for (i=0;i&lt;5;i++){ printf(&quot;@%p booklist[%d] @%p\\n&quot;,&amp;booklist[i],i,p) ; // p++; //p++ 会按照0x100(256字节)来增加 }} 执行`gcc main.c; ./a.exe`：@0x28c768 booklist[0] @0x28c768@0x28c868 booklist[1] @0x28c868@0x28c968 booklist[2] @0x28c968@0x28ca68 booklist[3] @0x28ca68@0x28cb68 booklist[4] @0x28cb68 结构体指针元素访问可以用结构体来定义指针类型 123456789101112131415161718192021222324252627282930313233#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;struct Books { //总共占256个字节，16进制就是0x100个字节 char title[50]; char author[50]; char subject[152]; int book_id;};void main(){ struct Books booklist[5] ; int i ; struct Books *p = booklist ; //表示一个占Books struct的指针 for (i=0;i&lt;5;i++){ //对于结构体指针，访问元素时用 p-&gt;title 访问 ，一般结构体直接用book.title 访问 strcpy( p-&gt;title, \"C Programming\"); strcpy( p-&gt;author, \"Nuha Ali\"); strcpy( p-&gt;subject, \"C Programming Tutorial\"); p-&gt;book_id = 100+i; printf(\"@%p booklist[%d] @%p\\n\",&amp;booklist[i],i,p) ; // p++; //p++ 会按照0x100(256字节)来增加 } p = booklist ; for (i=0;i&lt;5;i++){ printf(\"BookID:%d\\nTitle:%s\\nAuthor:%s\\nSubject:%s\\n\",\\ booklist[i].book_id,booklist[i].title,booklist[i].author,booklist[i].subject); // printf(\"BookID:%d\\nTitle:%s\\nAuthor:%s\\nSubject:%s\\n\",p-&gt;book_id,p-&gt;title,p-&gt;author,p-&gt;subject);//也是可以的 printf(\"--------------------------------------------\\n\"); p++; }} 结构体指针访问元素用 ‘-&gt;’ ,即 ‘p-&gt;tilte’一般结构体访问元素就用‘.’ ,即 ‘book.title’ union 共用体union共用体可以方便复用资源，有点像高级程序里面的泛型 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data{ int i; float f; char str[20];}; int main(){ union Data data; union Data *p; p = &amp;data ; printf( \"Memory size occupied by data : %d\\n\", sizeof(data)); data.i = 32 ; printf( \"data.i : %d\\n\", data.i); data.f = 32.12 ; printf( \"data.f : %f\\n\", data.i); strcpy(data.str,\"hello world\") ; printf( \"data.str : %s\\n\", data.str); printf( \"data.str : %s\\n\", p-&gt;i); printf( \"data.str : %s\\n\", p-&gt;f); printf( \"data.str : %s\\n\", p-&gt;str); return 0;}","link":"/riscv/20190418_c_point.html"},{"title":"","text":"函数式程序设计为什么至关重要Why Functional Programming Matters函数式程序设计为什么至关重要 作者： John Hughes翻译： CloudiDust ［http://blog.csdn.net/ddwn/］［在网上也可以找到其他同学的翻译哦，我翻译完了才看到的，呵呵。］ 原文地址：http://www.md.chalmers.se/~rjmh/Papers/whyfp.html －－－－－－－－－－－－－－－－－－－－ Why Functional Programming MattersJohn Hughes,Institutionen för Datavetenskap,Chalmers Tekniska Högskola,41296 G&amp;oumlteborg, SWEDEN.rjmh@cs.chalmers.se －－－－－－－－－－－－－－－－－－－－ 此 论文作于1984年，作为查麦兹大学的备忘录流传了多年，经过小幅度修订的版本出现于1989年与1990年，即［Hug89］与［Hug90］。此版本 基于原查麦兹大学备忘录的nroff源码，为LaTeX做了改动,使其更接近于印刷版本并纠正了少许错误。请原谅这多少有那么一点点过时的排版吧，文中的 例子也不是Haskell的！ ［me: 照理这段原文和内容没多大关系，不过实在手痒啊…… :)］ －－－－－－－－－－－－－－－－－－－－ 摘要 软 件正在变得越来越复杂，因此良好的软件构架也越来越重要。结构良好的软件易于编写，易于除错，同时提供可复用组件库以降低未来开发的成本。传统型语言在程 序模块化方面具有理念上的局限性，而函数式语言超越了局限。在本文中我们指出，函数式语言的两大特性，高阶函数与惰性求值，能够极大地促进模块化。作为例 证，我们处理了列表和树，编写了一些数值算法，并实现了alpha-beta启发式搜索（一个人工智能算法，用于游戏系统中）。既然模块化是程序设计成功 的关键，那么函数式语言对现实世界而言便极其重要了。 －－－－－－－－－－－－－－－－－－－－ 1 引言 本论文试图证明，对“现实世界”而言，函数式程序设计是极其重要的。同时，本文也试图明确指出函数式语言的长处，以帮助使用函数式语言的程序员们将这些长处发挥到极致。 函 数式语言之所以被如此称呼，是因为程序完全是由函数组成的。主程序本身也是一个函数，以程序的输入为参数，并返回其输出。典型地，主函数通过其他函数定 义，而这些函数又同样以更多的其他函数来定义，直到最低层的语言原生函数为止。这些函数与数学中的函数很相像，因此在本文中将以普通等式来定义它们。本文 使用了Turner的程序语言Miranda中的表示方法，但对于之前没有函数式语言相关知识的读者，本文仍然是可读的。（Miranda是 Research Software Ltd.的商标。） 函数式程序设计的特性与优点通常总结为类似这样：函数式程序不包含任何赋值语 句，因此变量一旦被赋予一个值，就不再改变。更一般地说，函数式程序不包含任何副作用：一个函数除了计算它本身的值以外，不产生任何作用。这一特性消灭了 “Bug”的一个主要来源，同时也使执行顺序不再重要——没有副作用能够改变一个表达式的值，故它可以在任何时刻被求值。这一特性将程序员从决定控制流的 重担之下拯救出来。由于表达式可以在任何时刻被求值，程序员便可以随心所欲地使用变量的值来代替变量，反之亦然——也就是说，程序是“引用透明”的。这一 自由使得函数式程序与它们传统的对应物相比，更容易数学化地控制。 这样的“优点”列表很不错，但如果说外行人不把它当回事，这也并不会令 人惊讶。它列出了很多内容关于函数式程序设计“没有”什么（它没有赋值，没有副作用，没有控制流）但却没多说它“有”什么。函数式程序员听起来很像是中世 纪的僧侣似的，他们禁绝了尘世中的种种乐趣并且期望这能使自己变得高洁。对于那些更关心物质利益的人而言，这些“优点”并没有多大的说服力。 函 数式程序员们争辩说，函数式程序设计确实有巨大的物质利益——一个函数式程序员拥有比他传统型的同行高得多的生产力，因为函数式程序短得多。但这有什么道 理吗？在这些“优点”的基础之上，唯一的很靠不住的借口就是，传统的程序中有90％是赋值语句，而在函数式程序中这些全都可以省略！这真是太荒唐了，如果 省略赋值语句可以带来如此巨大的好处，那么FORTRAN程序员们早该这样干了二十年了。［me：貌似是说FORTRAN的赋值多得一塌糊涂……］通过省 略特性来使语言更加强大在逻辑上是不可能的，不论这种特性是多么糟糕。 甚至函数式程序员都应该对这些所谓的“优点”表示不满意，因为它们 对于发掘函数式语言的威力毫无帮助。不可能写出一个特别地（particularly）缺少了赋值语句或者特别地引用透明的程序。这些不是什么衡量程序质 量的尺度，因此盯紧了它们（以此证明函数式语言的强大）也不理想。 ［me：关于那两个particularly的翻译，还是抓不准……］ 很明显，对函数式程序设计的特性的描述是不完备的。我们必须找出一些东西来填补——它们不但要解释函数式程序设计的威力，更要给函数式程序员们一个明确的追求目标。 －－－－－－－－－－－－－－－－－－－－ 2 与结构化程序设计的相似性 指 出函数式与结构化程序设计之间的相似性是很有帮助的。过去，结构化程序设计的特性与优点被总结为类似这样：结构化程序不包含goto语句；结构化程序中的 语句块没有多入口与多出口；结构化程序与它们传统的对应物相比，更容易数学化地控制。这些结构化程序设计的“优点”与我们之前所谈到的函数式程序设计的 “优点”在本质上很相似。这些叙述本质上都是否定式的，从而导致了诸如“不可或缺的goto”之类一大堆徒劳的争论。 事后诸葛亮式地说， 很明显地，结构化程序设计的这些特性，尽管很有用，但没有触及问题的核心。结构化程序与非结构化程序之间最重要的区别就是，结构化程序是用模块化的方法设 计的。模块化设计带来了生产力的巨大提升：首先，小模块可以很快很容易地编写；其次，通用模块可以被重用，使以后的程序可以更快地开发；再次，程序的模块 可以被独立测试，减少了除错的时间。 “不使用goto”等等这一类特性，对于这一提升没什么作用。这些特性促进了“程序设计的小改良”，然而模块化设计却促进了“程序设计的大进化”。因此，程序员在FORTRAN或汇编语言中都可以享受结构化程序设计带来的好处，哪怕那需要一点额外的工作。 模 块化设计是成功的程序设计的关键，这一观点现在已经被普遍地接受了，而诸如Modula-II[Wir82]，Ada[oD80]以及Standard ML[MTH90]之类的程序语言都内置了语言特性以促进模块化。然而，有一点非常重要，却常常被忽略。当编写一个模块化程序以解决问题的时候，程序员首 先把这个问题分解为子问题，而后解决这些子问题并把解决方案合并。程序员能够以什么方式分解问题，直接取决于他能以什么方式把解决方案粘起来。因此，为了 能在观念上提升程序员将问题模块化的能力，必须在程序语言提供中提供各种新的黏合剂。复杂的作用域规则与对分块编译的支持只对文本层面的细节有帮助，它们 没有提供能表达新观念的工具以分解问题。 通过与木匠行业的类比可以认识到黏合剂的重要性。先制作椅子的各部分——坐垫，椅子腿，靠背，等 等——而后用正确的方法钉起来，那么制作一把椅子是很容易的。但这取决于将木板与插接口结合起来的能力。如果缺乏这种能力，那么制作椅子的唯一方式，就是 将它从一大块木头里整个地切割出来，这是一项艰巨得多的任务。这个例子同时表明了模块化的非凡威力与拥有合适的黏合剂的重要性。 现在让我 们回到函数式程序设计上来。在这篇论文余下的部分里，我们将指出，函数式语言提供了两种新的、非常重要的黏合剂。我们将给出许多可以使用新方法模块化的示 例程序，它们因此变得很简洁。这就是函数式程序设计威力的关键——它允许了大幅改进的模块化设计。这也正是函数式程序员必须追求的目标——更小、更简洁、 更通用的模块，用我们将要描述的新黏合剂黏合起来。 －－－－－－－－－－－－－－－－－－－－ 3 把函数粘起来 两种黏合剂中的第一种，使简单的函数可以聚合起来形成复杂的函数。以一个简单的处理问题来说明：将列表中的元素累加起来。我们用下面的语句定义列表： listof X :: = nil | cons X (listof X) 这 说明，一个元素类型为X的列表（不论X是什么），或是nil，代表一个没有元素的空列表，或是一个X与另一个X的列表的cons。cons代表一个列表， 其首元素为X，而第二个以及后续元素即是另一个X的列表的元素。此处的X可以代表任何类型——例如，如果X是一个“Integer”（整数类型），那么这 个定义就是说，一个整数列表，或者是空的，或者是一个整数与另一个整数列表的cons。依照通常的实践，我们写列表时，只是简单地将其元素包含在方括号 里，而不是将cons和nil显式地写出来。方便起见，这是一个简单的速记法。例如： [] 表示 nil[1] 表示 cons 1 nil[1 2 3] 表示 cons 1 ( cons 2 ( cons 3 nil )) 列表中的元素可以通过一个递归函数sum进行累加。sum必须为两类参数进行定义：一个空列表（nil），以及一个cons。由于没有数字存在时，累加结果是0，因此我们定义： sum nil = 0 又因为cons的累加和可以通过将列表的第一个元素加到其余元素的累加和上的方式进行计算，所以可以定义： sum (cons num list) = num + sum list 检查定义可以发现，计算sum时，只有下面用*标出的部分是特化的：［me：原文用的是方框，在这里小偷一下懒…… :)］ sum nil = 0 sum (cons num list) = num + sum list 这说明sum的计算可以通过一个通用的递归模式和特化的部分来模块化。这个递归模式习惯上被称为“递减”（reduce），因此sum可以表达为： sum = reduce add 0 方便起见，reduce传递了一个二元函数add而不是一个运算符。add是这样定义的： add x y = x + y 只要将sum的定义参数化，我们便可以得到reduce的定义，即： (reduce f x) nil = x(reduce f x)(cons a l) = f a ((reduce f x) l) ［me：注意到了吗？这就是Haskell中的foldr啊……］ 这 里我们写出了(reduce f x)两边的括号以强调它代替了sum。习惯上括号是省略的，因此 ((reduce f x) l)写作(reduce f x l)。一个三元函数如reduce，当只提供两个参数时，将成为关于那个余下参数的一元函数。一般地，对一个n元函数，提供了m(&lt; n)个参数后，该函数便成为了关于余下的n-m个参数的函数。我们在下文中将遵守这一约定。 用这种方式将sum模块化之后，我们就可以通过对这部分的重用来收获福利了。最有趣的部分就是，reduce可以（直接）用于编写一个函数来计算列表中元素的累乘积，而不需要更多的编程步骤： product = reduce multiply 1 它也可以用来测试一个布尔值的列表中是否至少有一个元素为真： anytrue = reduce or false 或者它们是否都为真： alltrue = reduce and true 理解(reduce f a)的一种方式是，将其看作一个将列表中的所有cons替换为f，将所有nil替换为a的函数。以列表[1,2,3]为例，既然它表示： cons 1 (cons 2 (cons 3 nil)) 那么(reduce add 0)将其转换为： add 1 (add 2 (add 3 0)) = 6 而(reduce multiply 1)将其转换为： multiply 1 (mulitiply 2 (mulitiply 3 1)) = 6 于是，很明显地，(reduce cons nil)将复制列表本身。既然将一个列表追加到另一个列表上的方式是将前一个列表的元素cons到后一个列表前部，我们便得到： append a b = reduce cons b a 例如： append [1,2] [3,4] = reduce cons [3,4] [1,2] = (reduce cons [3,4]) (cons 1 ( cons 2 nil )) = cons 1 ( cons 2 [3,4])) （将cons替换为cons，将nil替换为[3,4]） ＝ [1,2,3,4] 一个用于将列表中全部元素翻倍的函数可以写作： doubleall = reduce doubleandcons nil其中 doubleandcons num list = cons ( 2*num ) list doubleandcons可以进一步模块化，首先分解为： doubleandcons = fandcons double其中 double n = 2*n fandcons f el list = cons (f el) list 继续分解： fandcons f = cons . f 其中“.”（函数复合，一个标准运算符）定义为： (f . g) h = f(g h) ［me：注意这是函数的左复合，可能与你在离散数学课上学到的“右复合”相反。］ 为证明fandcons的定义是正确的，我们代入一些参数： fandcons f el = (cons . f) el = cons (f el)因此 fandcons f el list = cons (f el) list 最终得到的版本是： doubleall = reduce (cons . double) nil 继续模块化，我们得到： doubleall = map doublemap f = reduce (cons . f) nil 其中map使任意的函数作用于列表的全部元素之上。map是另一个很通用的函数。 我们甚至可以写出一个函数累加矩阵中的所有元素，该矩阵用列表的列表表示。这个函数是： summatrix = sum . map sum map sum使用函数sum分别计算所有行的元素之和，而后最左边的sum将每一行的元素之和累加起来，从而得到整个矩阵的累加和。 这 些例子应该已经足以使读者确信，一点模块化的努力可以产生很大的效果。通过将一个简单的函数（sum）模块化为一个“高阶函数”与一些简单参数的聚合，我 们得到了一个部件（reduce），它可以用于编写与列表有关的许多函数，而又不再需要（更多的）编程努力。不止是对有关列表的函数可以这么干，举另外一 个例子，考虑数据类型“有序标记树”，其定义是： treeof X ::= node X (listof (treeof X)) 这个定义表明，一棵X的树，由一个标记类型为X的结点（node），以及一个子树列表组成，而这些子树也是X的树。例如，树： 1 o /\\ / \\ / \\ 2 o o 3 | | | o 4 可以被表示成： node 1 (cons (node 2 nil) (cons (node 3 (cons (node 4 nil) nil)) nil)) 我 们不再给出一个函数例子并将它抽象为高阶函数，取而代之的是，直接给出一个类似于reduce的函数redtree。回忆一下，reduce有两个参数， 一个用于取代cons，另一个用于取代nil。既然树由node，cons和nil组成，那么redtree必须有三个参数——用于分别取代上述三者。由 于树和列表不是同一种类型，我们得定义两个函数分别处理它们。因此我们定义： redtree f g a (node label subtrees) = f label (redtree’ f g a subtrees )redtree’ f g a (cons subtree rest) = g (redtree f g a subtree) (redtree’ f g a rest)redtree’ f g a nil = a ［me：这相当于f取代node，g取代cons，a取代nil。:)］ 很多有趣的函数都可以通过把redtree和其他函数粘起来的方法来定义。例如，要把一棵数字树上的所有标记累加起来，可以使用： sumtree = redtree add add 0 以我们刚才表述的那棵树为例，sumtree展开成： add 1 (add (add 2 0) (add (add 3 (add (add 4 0) 0)) 0))= 10 要生成一个包含树中全部标记的列表，可以用： labels = redtree cons append nil 仍然是那个例子，得到： cons 1 (append (cons 2 nil) (append (cons 3 (append (cons 4 nil) nil)) nil))= [1,2,3,4] 最后，可以定义一个类似于map的函数，此函数使函数f作用于树中的全部标记上： maptree f = redtree (node . f) cons nil 以 上这些操作之所以可行，是因为函数式语言允许将传统型语言中不可分解的函数表达为一些部件的聚合——也就是一个泛化的高阶函数与一些特化函数的聚合。这样 的高阶函数一旦定义，便使得很多操作都可以很容易地编写出来。不论何时，只要一个新的数据类型被定义，就应当同时定义用于处理这种数据的高阶函数。这样就 简化了对数据类型的处理，同时也将与它的表示细节相关的知识局部化了。［me：个人感觉这相当于OO里的封装。］与（函数式语言）最相像的传统程序语言是 可扩展语言——只要有需求，这种程序语言就好像随时都可以扩展出新的控制结构一样。［me：原文是The best analogy with conventional programming is with extensible languages - it is as though the programming language can be extended with new control structures whenever desired.不太有把握……］ －－－－－－－－－－－－－－－－－－－－ 4 把程序粘起来 函数式语言提供的另一种黏合剂使得所有程序都可以粘在一起。回忆一下，一个完整的函数式程序只不过是一个从输入映射到输出的函数。如果f和g是这样的程序，那么对程序(g.f)当提供了输入参数input之后，得到： g (f input) 程 序f计算自身的输出，此输出被用作程序g的输入。传统上，这是通过将f的输出储存在临时文件中实现的。这种方法的毛病是，临时文件可能会占用太大的空间， 以至于将程序黏合起来变得很不现实。［me：但也不要忘了神奇的Unix管道……也许管道就是下面说的这种方法的另一个实现？:)］函数式语言提供了一种 解决方案。程序f和g严格地同步运行，只有当g试图读取输入时，f才启动，并且只运行足够的时间，恰好可以提供g需要读取的输出数据。而后f将被挂起，g 将继续执行，直到它试图读取另一个输入。一个额外的好处是，如果g没有读取完f的全部输出就终止了，那么f也将被终止。f甚至可以是一个不会（自行）终止 的程序，它可以产生无穷多的输出（而不会出现问题），因为当g运行结束时，f也将被强行终止。这就使得终止条件可以与循环体分离——一种强大的模块化形式。 这 种求值方式使得f尽可能地少运行，因此被称为“惰性求值”。它使得将程序模块化为一个产生大量可能解的生成器与一个选取恰当解的选择器的方案变得可行。有 些其他的系统也允许程序以这种方式运行，［me：看来就是说的管道啦！］但只有函数式语言对每一个函数调用都一律使用惰性求值，使得程序的每个部分都可以 用这种方式模块化。惰性求值也许是函数式程序员的拿手利器中威力最大的模块化工具。 4.1 牛顿－拉夫森求根法 我们将编写一些数值算法以展现惰性求值的威力。首先，考虑用于求解平方根的牛顿－拉夫森算法。该算法从一个初始的近似值a0开始计算数N的平方根，为了求得更好的解，它使用下述规则： a(n+1) = (a(n) + N/a(n)) / 2 如果近似值序列趋近于某一个极限a，那么 a = (a + N/a) / 2 故 2a = a + N/a a = N/a a*a = N a = squareroot(N) 事实上，这个近似值序列确实迅速地趋近于一个极限。平方根算法取一个允许误差（eps）为参数，当两个相邻的近似值之差（的绝对值）小于eps时，算法便终止了。 这个算法通常被编写为类似下面这样： C N IS CALLED ZN HERE SO THAT IT HAS THE RIGHT TYPE X = A0 Y = A0 + 2.*EPSC THE VALUE OF Y DOES NOT MATTER SO LONG AS ABS(X-Y).GT.EPS100 IF (ABS(X-Y).LE.EPS) GOTO 200 Y = X X = (X + ZN/X) / 2200 CONTINUEC THE SQUARE ROOT OF ZN IS NOW IN X ［me：这是一段FORTRAN的程序，C代表注释行，保留不翻译。.LE.是“Less than or Equal to”（小于或等于）的缩写，同理.GT.是“大于”的意思。] 在传统型语言中，这个程序是不可分解的。我们将利用惰性求值将其化为更加模块化的形式，而后演示所生成部件的一些其他用途。 由于牛顿－拉夫森算法计算的是一个近似值的序列，故将它写作一个使用近似值列表的程序就再自然不过了。每个近似值都可以通过下面的函数从前一个值计算得到： next N x = (x + N/x) / 2 因此(next N)是从一个近似值映射到下一个值的函数。调用函数f，得到近似值序列： [a0, f a0, f(f a0), f(f(f a0)), …] 我们可以定义一个函数来计算：［me：这是通用的迭代计算。］ repeat f a = cons a (repeat f (f a)) 因此 近似值序列可以这样计算： repeat (next N) a0 repeat是一个具有“无穷”输出的函数的例子——但这没关系，因为超出程序其余部分需求的近似值并不会被计算。无穷性只是潜在的：它只说明，只要有需求，就可以计算出任意数量的近似值，repeat本身不会强加任何限制。 求根函数的剩余部分是函数within，它取一个允许误差与一个近似值列表作为参数，并在列表中查找差值不超过允许误差的一对相邻的近似值。这个函数可以定义为： within eps (cons a (cons b rest)) = = b, if abs(a-b) &lt;= eps = within eps (cons b rest), otherwise 将这两个部件结合起来， sqrt a0 eps N = within eps (repeat (next N) a0) 现 在我们得到了求根函数的两大部件，便可以尝试用不同的方式组合它们。将要进行的修改之一，是将判断条件改为“相邻近似值的比趋近1”而不是“差趋近0”。 这对于非常小的数字而言更加合适（当初始的相邻近似值之间的差值很小时），对非常大的数字也是如此（当舍尾产生的误差比允许误差大很多时）。我们只需要定 义一个函数来替换within： relative eps (cons a (cons b rest)) = = b, if abs(a-b) &lt;= eps*abs b = relative eps (cons b rest), otherwise ［me：注意：relative里的eps与within里的eps定义是不同的！前者是绝对误差后者是相对误差！］ 而并不需要改写生成近似值的部件。 4.2 数值微分 我们已经重用了平方根近似值序列，当然，对函数within和relative的重用也是可能的，它们能够与任何一个生成近似值序列的数值算法配合。我们将这样来编写数值微分算法。 函数在某一点的微分，便是其图象在该点的斜率。通过分别计算函数在该点与一个临近点处的取值，而后计算两点连线斜率的方法，可以很容易地估计出微分的值。这基于一个假定：如果这两点靠得足够近，那么函数图象在两点之间不会弯曲得很厉害。于是有下述定义： easydiff f x h = (f(x+h)-f x) / h 为 了得到良好的近似值，h应该很小。不幸的是，如果h太小，那么f(x+h)与f(x)会相当接近，因此在相减过程中产生的舍尾误差可能会掩盖了计算结果。 如何为h选取恰当的值呢？解决这个矛盾一种方案是从一个合理的较大取值开始，不断减小h的值，并求出一个（微分的）近似值序列。这个序列将趋近于该点的导 数，但最终会由于舍尾误差的存在而不可救药地变得不精确。如果我们用(within eps)来选取第一个足够精确的近似值，那么舍尾误差影响结果的风险将会大大降低。我们需要一个函数来计算这个序列： differentiate h0 f x = map (easydiff f x) (repeat halve h0)halve x = x/2 此处h0是h的初值，而后继取值是通过不断减半得到的。通过这个函数，任意点处的导数可以这样计算： within eps (differentiate h0 f x) 但是，甚至这个方案也不是那么令人满意的，因为近似值序列收敛得相当慢。解决这个问题需要一点数学知识，序列中的元素可以记为： （微分的）精确值 ＋ 一个关于h的误差项 理论表明，该误差项与h的某一次幂大致成正比，因此当h减小时，误差也会减小。设精确值为A，而误差项为B*hn [me：是求幂运算符］。由于计算每个近似值时所用的h取值是下一个的两倍，故任意两个连续的近似值可以表示成： a(i) = A + B(2**n)(hn)a(i+1) = A + B*(hn) 现在就可以消去误差项了，我们得到： a(i+1)*(2n) - a(i)A=———————- 2n - 1 当然，误差项只不过“大致”与h的某一次幂（成正比），因此这个结论也是近似的。但这是一个好得多的近似。这一改进可以通过下述函数作用于所有相邻的近似值对之上： elimerror n (cons a (cons b rest)) = = cons ((b*(2n)-a)/(2n-1)) (elimerror n (cons b rest)) 从一个近似值序列中消除误差项的操作产生了另一个收敛速度快得多的序列。 使用elimerror之前还有一个问题需要解决——我们必须知道n的正确值。通常这个值很难预测，但却很容易衡量。不难验证，下述函数能够正确地消除误差项，但在此我们并不给出证明。 order (cons a (cons b (cons c rest))) = = round(log2( (a-c)/(b-c) - 1 ))round x = 最接近x的整数log2 x = x以2为底的对数 现在，一个通用的近似值序列优化函数可以定义为： improve s = elimerror (order s) s 使用improve能够更加高效地计算函数f的导数，如下： within eps (improve (differentiate h0 f x)) improve只对利用一个不断减半的参数h计算得到的近似值序列适用。但是，如果improve作用于这样的序列，那么其结果也是一个这样的序列！这意味着一个近似值序列可以优化不止一次。每一次优化的过程中，都有一个不同的误差项被消除，因此优化产生的序列收敛得越来越快。因此，可以非常高效地计算导数： within eps (improve (improve (improve (differentiate h0 f x)) 从数值分析的角度讲，这似乎是一个“第四阶方法”［me：fourth order method，我还没有学数值分析，不会翻译……］，可以迅速地给出准确的结果。甚至可以定义： super s = map second (repeat improve s)second (cons a (cons b rest)) = b super 函数使用repeat improve来生成一个不断被优化的近似值的序列的序列。［me：就是说，生成一个序列，其中每一个元素是一个近似值序列，而这个元素是用前一个元素优 化得到的。］同时，super提取出每个近似值序列中的第二个元素，构造出一个新的序列（已经确认，第二元素是最佳选择——它比首元更精确，而且不需要额 外的计算）。这个算法的确非常复杂——更多的近似值被计算的同时，它使用了不断优化的数值方法。可以用下面的程序非常非常高效地计算导数： within eps (super (differentiate h0 f x)) 这个案例可能就像是用大锤敲碎坚果一样（大材小用），但关键是，甚至一个像super一样复杂的函数，当被惰性求值的方法模块化时，也会变得很容易表达。 4.3 数值积分 在 这一部分我们将讨论的最后一个例子是数值积分。问题的描述很简单：给出一个返回实数，并有一元实数参数的函数，以及两个端点a和b，估算两点之间曲线f下 方的面积。［me：感觉不够准确……可能我对under和area的理解错了？］估算面积的最简单方法是假定f趋近于直线，此时面积就是： easyintegrate f a b = (f a + f b)*(b-a)/2 不 幸的是，除非a与b足够接近，否则这个估算似乎非常不精确。更好的估算方法是，将a与b之间的区间分为两段，分别估算子区间上的面积，再将结果加起来。我 们可以定义一个不断趋近于准确值的积分近似值序列，首先使用上述方程进行第一次近似，而后将分别趋近于两个子区间上的子积分准确值的（两个）近似值累加起 来以得到新的（积分总体的）近似值。［me：翻译有点乱，简单说，二分法。］计算这个序列可以使用函数： intergrate f a b = cons (easyintergrate f a b) (map addpair (zip (intergrate f a mid) (intergrate f mid b))) 式中 mid = (a+b)/2 zip是另一个标准的表处理函数。它读取两个列表，并返回一个有序对的列表，每个有序对由两个输入列表中对应的元素组成。从而第一对由列表一和列表二的首元组成，第二对由列表一和列表二的第二个元素组成，以此类推。zip可以定义为： zip (cons a s) (cons b t) = cons (pair a b) (zip s t) 在函数intergrate中，zip用于生成由两个子区间上相对应的积分近似值对组成的列表，而map addpair用于将有序对中的元素相加，从而生成一个原积分的近似值列表。 实 际上，这个版本的intergrate函数相当低效，因为它持续不断地重复计算f的值。就像所写的一样，easyintergrate计算了f在a和b两 处的值，而对intergrate的递归调用将重复计算它们。同样的，(f mid)也在递归调用中重复计算了。因此，更可取的是下述从不重复计算f的版本： intergrate f a b = interg f a b (f a) (f b)integ f a b fa fb = cons ((fa+fb)*(b-a)/2) (map addpair (zip (interg f a m fa fm) (interg f m b fm fb))) 式中 m = (a+b)/2 fm = f m integrate给出了一个不断趋近准确值的积分近似值列表，正如differentiate在上一小节中所做的一样。因此可以写出计算式以求出所需任意精度的积分值，如下： within eps (intergrate f a b)relative eps (integrate f a b) 这 个积分算法与上一小节中的第一个微分算法有着同样的缺点——它收敛得相当慢。序列中的第一个近似值仅仅用了两个相距(a-b)的点来计算（通过 easyintergrate）。第二个近似值也（除了a、b之外）用到了中点，因此相邻两点之间的间距仅为(b-a)/2。第三个近似值在两个子区间上 作同样的处理，因此间距仅为(b-a)/4。很清楚，每个近似值对应的相邻两点之间的间距在计算下一个值时被减半了。将这一间距看作“h”，那么这个序列 就可以成为上一小节中定义的“improve”函数的优化对象了。因此我们可以写出（函数来计算）快速收敛的积分近似值序列，例如： super (intergrate sin 0 4) improve (intergrate f 0 1)式中 f x = 1/(1+x*x) （后一个序列是用于计算pi/4的“第八阶方法”［me：……］。其中的第二个近似值只需要计算5次f的取值，但却具有5位准确数字。） 在 本节中我们选取了一些数值算法并将它们函数化地编写出来，把惰性求值当做了黏合部件的黏合剂。由于惰性求值的存在，使得我们可以用很多新的方式来模块化这 些算法，从而产生用途广泛的函数，例如within，relative和improve。通过这些部件的不同组合，我们简单而明了地编写出了一些相当不错 的数值算法。 －－－－－－－－－－－－－－－－－－－－ 5 人工智能中的例子 我们已经指出，函数式语言威力强大主要是因为它们提供了两种新的黏合剂：高阶函数和惰性求值。在本节中，我们将讨论人工智能中一个大一点的实例，并演示如何使用这两种黏合剂来十分简单地编写它。 我们选取的实例是alpha-beta“启发式搜索”，一个用于估计游戏者所处形势好坏的算法。该算法预测游戏局势的可能发展，但会避免对无意义局势的进一步探究。 令游戏局势使用“position”类型的对象来表示。这个类型依据游戏的不同而不同，我们不对此作任何假定。必然有一种方法可以知晓对某一个局势能够采取的行动：假定有一个函数： moves: position -&gt; listof position 该函数以一个游戏局势为参数，并返回一个可以由自变量出发，通过一步行动而形成的position的列表。以noughts and crosses游戏（tic-tac-toe）为例： | | x| | |x| | | -+-+- -+-+- -+-+- -+-+- moves | | = [ | | , | | , |x| ] -+-+- -+-+- -+-+- -+-+- | | | | | | | | | | o| | |o| -+-+- -+-+- -+-+- moves |x| = [ |x| , |x| ] -+-+- -+-+- -+-+- | | | | | | 这个函数假定通过当前局势总是可以判定现在是哪位游戏者的回合。在noughts and crosses中，可以通过数出“0”与“X”的数目来做到这一点。在类似于象棋的游戏中，可能必须在“position”类型中显式包含这一信息。 利 用函数moves，第一步是构造一棵博弈树。这棵树的结点都用局势来标记，而一个结点的子结点用从该结点一步便可到达的局势标记。也就是说，如果一个结点 标记为局势p，那么它的子结点将使用(moves p)中的局势来标记。一棵博弈树完全有可能是无穷的，如果这个游戏可以在双方都不胜的情形下永远进行下去的话。博弈树与第2节中讨论的树完全类似——每个 结点都有一个标记（它所代表的局势）与一个子结点列表。因此我们可以使用相同的数据类型来表示它们。 博弈树是通过反复运用moves而构造出来的。构造从根局势开始，moves用于生成根结点处子树的标记，而后moves被用于生成子树的子树，依此类推。这一递归模式可以用一个高阶函数表示： reptree f a = node a (map (reptree f) (f a)) 使用这个函数可以定义另一个函数，该函数从一个特定的局势开始生成博弈树： gametree p = reptree moves p 例如图1所示。此处使用的高阶函数(reptree）与上一节中用于构造无穷列表的函数repeat是类似的。 | | -+-+- gametree | | -+-+- | | | | -+-+-= | | -+-+- | | / | \\ / | \\ / | \\ / | \\ / | \\ / | \\ X| | |X| | | -+-+- -+-+- -+-+- | | | | |X| -+-+- -+-+- -+-+- | | | | | | /|\\ /|\\ /\\ … … / \\ / \\ / \\ O| | |O| -+-+- -+-+- |X| |X| -+-+- -+-+- | | | | /|\\ /|\\ … … 图1： 一棵博弈树的实例 alpha- beta算法从一个给定的局势出发，就游戏的发展将会是有利还是不利作出判断。然而，要做到这一点，它必须能够在不考虑下一步的情况下粗略地估计某一个局 势的“价值”。在后继局势不可预测时必须使用这一函数，它也可以用来对算法进行先期引导。静态估价的结果是从计算机的角度考虑的，是对该局势的前途的度量 （假设在游戏中计算机与人对抗）。结果越大，局势对计算机而言越好。结果越小，局势越糟。最简单的此类函数将会，比如说，对计算机确定胜利的局势返 回+1，对计算机确定失败的局势返回-1，而对其它的局势返回0。在现实中，静态估价函数会衡量各种使局势“看上去不错”的因素。例如，具体的好处，以及 象棋中对中心的控制。假定有这样一个函数： static: position -&gt; number 既然一棵博弈树是一个(treeof position)，那么它就可以被函数(maptree static)转换为一个(treeof number)，该函数对树中所有的（也许是无穷多个）局势进行静态估价。此处使用了第2节中定义的函数maptree。 给 出一棵静态估价树之后，其中各个局势的真值究竟是多大？特别地，对根局势应该赋予什么值？不是它的静态值，因为那只是一个粗略的猜测。一个结点被赋予的 值，必须由其子结点的真值决定。这一过程的完成，基于每个游戏者都会选择对自己最有利的行动的假定。回忆一下，高值意味着计算机的有利形势。很明显，当计 算机从任意的局势开始下一步行动时，它将选择通往真值最高的子结点的行动。类似地，对手将会选择通往真值最低的子结点的行动。假定计算机与其对手轮流行 动，那么当轮到计算机行动时，节点的真值用函数maximise计算，反之用minimise计算。 ［me：所谓“真值”（true value），可能是我翻译得不好，此处理解为类似“真正的价值”的意思吧，是一个量度，不是逻辑学里的0和1哦。］ maximise (node n sub) = max (map minimise sub)minimise (node n sub) = min (map maximise sub) 此 处max和min是关于列表的函数，分别返回列表中元素的最大值与最小值。上述定义是不完整的，因为它们将永远递归下去——没有给出边界情形。我们必须定 义没有后继的结点的值（其标记）。因此静态估价用于任一游戏者胜利或者后继局势不可预测的情况下。maximise与minimise的完整定义是： maximise (node n nil) = nmaximise (node n sub) = max (map minimise sub)maximise (node n nil) = nmaximise (node n sub) = min (map minimise sub) 在这个阶段，几乎已经可以写出一个取一个局势作为参数并返回其真值的函数了。可能是： evaluate = maximise . maptree static . gametree 这 个定义有两个问题。首先，它不适用于无穷树。maximise不断地递归直到找到一个没有子树的结点——树的端点。［me：还是叫叶结点习惯啊……］如果 没有端点那么maximise就不会返回结果。第二个问题与第一个有关——甚至有穷的博弈树（如noughts and crosses里的那棵）事实上也可能相当大。估价整棵博弈树是不现实的——搜索必须被限定在接下去的几步之内。为此可以将树剪至一个固定的深度： prune 0 (node a x) = node a nilprune n (node a x) = node a (map (prune (n-1)) x) (prune n)取一棵树作为参数并“剪去”与根结点的距离超过n的所有结点。如果一棵博弈树被剪枝，那么将强制maximise对深度为n的结点执行静态估价而不是进一步递归。因此evaluate可以被定义为： evaluate = maximise . maptree static . prune 5 . gametree 这将考虑其后（比如说）5步的形势。 在 此开发过程中我们已经使用了高阶函数与惰性求值。高阶函数reptree和maptree使得我们能够很容易地构造与处理博弈树。更重要的是，惰性求值确 保了我们可以使用这种方式模块化evaluate。由于博弈树具有潜在的无穷结果，在没有惰性求值的情况下，程序将永远不会终止。我们将不能写： prune 5 . gametree 而不得不将这两个函数整合成一个只构造树的前五层的函数。更糟糕的是，甚至那前五层都可能已经太大以至于无法在同一时间内存储于内存中。而在我们所写的程序中，函数 maptree static . prune 5 . gametree 只 是构造出了树中maximise所需的部分。由于每一部分都可以在被maximise处理完之后丢弃（被垃圾收集器回收），故完整的树从来没有存储于内存 中。只有树的一小部分在某一段时间内被储存着。因此这个惰性程序很有效率。这一效率取决于maximise（组合链上的最后一个函数）与 gametree（第一个函数）的相互作用，因此在没有惰性求值的情况下，要完成任务，只能将组合链上的所有函数整合成一个大函数。这是对模块化的强烈破 坏，但也是通常的做法。通过单独修补每个部件，我们就可以优化估价算法——这相对简单。而一个传统型程序员必须把整个程序作为一个单元来修改，这就困难多 了。 到目前为止，我们只是描述了简单的对最大最小值的处理（minimaxing）。但alpha-beta算法的核心是“计算maximise与minimise的值时常常不需要考虑整棵树”这一观察结果。考虑树： max / \\ / \\ / \\ / \\ min min / \\ / \\ / \\ / \\ 1 2 0 ? 相当奇怪地，为了估价这棵树，并不需要知道问号处的值。左子树的最小值是1，但右子树的最小值显然是一个小于或等于0的值。因此这两个最小值的最大值必然是1。这一观察结果可以被泛化并内建到maximise和minimise之中。 第一步是将maximise拆分成max对一个数字列表的作用。也就是，将maximise分解为： maximise = max . maximise’ （minimise 可以用类似的方法分解。由于maximise和minimise是完全对称的，故我们将只讨论maximise，而假定minimise也照此处理。）一 旦这样分解之后，maximise可以使用minimise’来发现minimise将对哪些数字求最小值，并且不再使用minimise本身。而后便可 以在不查看某些数字的情况下便将它们丢弃。由于惰性求值的存在，如果maxmise并不会查看所有的数字列表，那么一部分列表将不会被计算，这是对计算机 时间的潜在节约。 将max从maximise中“约分出来”是很简单的，得到： maximise’ (node n nil) = cons n nilmaximise’ (node n l) = map minimise l = map (min . minimise’) l = map min (map minimise’ l) = mapmin (map minimise’ l)式中 mapmin = map min 由 于minimise’ 返回一个数字列表，而这个列表的最小值是minimise的结果，故(map minimise’ l)返回一个数字列表的列表。Maximise’应该返回这些列表中每个列表的最小值组成的列表，但只有其中［Maximise的返回值中］的最大值才有 用。我们应该定义一个mapmin的新版本以忽略那些最小值不重要的列表［在(map minimise’ l)的返回值中］的最小值。 mapmin (cons nums rest) = = cons (min nums) (omit (min nums) rest) 函数omit传递一个“潜在的最大值”——当前所发现的最小值中最大的一个——并忽略任何比该值小的最小值。 omit pot nil = nilomit pot (cons nums rest) = = omit pot rest, if minleq nums pot = cons (min nums) (omit (min nums) rest), otherwise minleq 以一个数字列表和一个潜在最大值为参数，如果列表的最小值小于或等于潜在最大值就返回真。要完成这一工作，它并不需要扫描整个列表！如果列表中有任意一个 元素小于或等于潜在最大值，那么列表的最小值肯定也是如此。该特别元素之后的所有元素都是无关紧要的——它们就像是上面例子中的问号一样。因此 minleq可以被定义为： minleq nil pot = falseminleq (cons num rest) port = true, if num&lt;=pot = minleq rest pot, otherwise 如是定义了maximise’和minimise’之后，要写出一个新的估价函数就很简单了： evaluate = max . maximise’ . maptree static . prune 8 . gametree 由于惰性求值的存在，使得maximise’只查看树的更小部分，这意味着整个程序会更加高效，正如prune只查看无穷树的一部分使得程序可以终止一样。对maxmise’的优化，尽管相当简单，却能对运算的速度产生戏剧性的效果。因此也使得估价函数可以看得更远。 ［me： 刚看完的时候想，maximise’干嘛还要返回一个包含了那个最大值的列表呢，这既然很显然会是一个升序表，那么只要保留pot遍历完了直接当最大值返 回不就结了……然后发现那样的话在返回值上和maximise就一样了啊……而且参数也一样，那不就是maximise了嘛……那我们还在这里搞什么 呢？:)］ 对估价函数还可以进行其它优化。例如，alpha-beta算法在最佳行动被最先考虑时，能够将工作描述得（进行得？）最好， 因为如果有一方发现了一着妙棋，那就没必要再考虑较差的行动了，除非他证明对手至少能有一种很好的回应方式。因此可能会希望对每一个结点的子树进行排序， 当计算机行动时将最高值放在第一，而人行动时则相反。这可以使用函数： highfirst (node n sub) = node n (sort higher (map lowfirst sub))lowfirst (node n sub) = node n (sort (not.higher) (map highfirst sub))higher (node n1 sub1)(node n2 sub2) = n1&gt;n2 此处sort是多用途排序函数。现在估价函数定义为： evaluate = max . maximise’ . highfirst . maptree static . prune 8 . gametree ［me：我一开始没想明白为什么highfirst是对静态估价产生的树排序，而不是根据真值树排序呢？后来才想起来根本就不存在返回真值树的函数啊……:)］ 也可能认为，为了限制搜索，只要考虑计算机或者对手的前三个最佳行动也已经足够了。要编写这样的程序，只需要把highfirst换成(taketree 3 . highfirst)，其中： taketree n = redtree (nodett n) cons nilnodett n label sub = node label (take n sub) taketree 将树上所有的结点替换为最多有n个子结点的结点，它使用了函数(take n)，而该函数返回列表的前n个元素（如果列表比n短，那么返回的元素就少一些）。 另 一种优化是对剪枝的改良。上述程序甚至在局势非常dynamic［me：晕……“动态”？实在不知道怎么翻译了……难道是“明朗”？］的情形下也会向前搜 索固定的深度——（但是，）例如在国际象棋中，一旦皇后被威胁，也许就可以决定不再搜索了。通常可以定义某些“dynamic”的形势，并在遇到这样的结 点之一时，不再继续搜索而停止。假定有函数“dyramic”用以确定这样的形势，那么只需要为prune追加一个定义等式： prune 0 (node pos sub) = node pos (map (prune 0) sub), if dynamic pos [me：原文如此，但大伙儿不觉得那开头的prune 0应该是prune n吗？］ 在 像这个程序一样模块化的程序里，作出这样的改动是很简单的。如前所述，这个程序的效率，关键是由链中的最后一个函数maximise与第一个函数 gametree的相互作用决定的，因此若没有惰性求值，就只能写成一个单一的程序。这样的程序难于编写，难于修改，而且，非常难于理解。 －－－－－－－－－－－－－－－－－－－－ 6 结论 在 本论文中，我们指出，模块化是成功的程序设计的关键。以提高生产力为目标的程序语言，必须良好地支持模块化程序设计。但是，新的作用域规则和分块编译的技 巧是不够的——“模块化”不仅仅意味着“模块”。我们分解程序的能力直接取决于将解决方案粘在一起的能力。为了协助模块化程序设计，程序语言必须提供优良 的黏合剂。函数式程序语言提供了两种新的黏合剂——高阶函数与惰性求值。利用这些黏合剂可以将程序用新的、令人激动的方式模块化，对此我们举出了很多实 例。越小、越通用的模块越可能被广泛地重用，使后续的程序设计工作变得简单。这解释了为什么函数式程序与传统型程序比较，要小得多，也容易编写得多。它也 为函数式程序员提供了一个追求目标。如果程序的任何部分是杂乱或者复杂的，那么程序员就应当尝试将其模块化并泛化其部件。他应当期望把高阶函数和惰性求值 用作他做此事的工具。 当然，我们并不是指出高阶函数与惰性求值的力与美的第一人。例如，Turner展示了这两者如何在一个生成化学结构 的程序里大显身手［Tur81］。Abelson和Sussman强调“流”（惰性列表）是构架程序的强大工具［AS86］。Henderson使用了流 来构架函数式操作系统［P.H82］。本论文的主要贡献是，断言了模块化自身，便是函数式语言强大威力的关键。 这与当前有关惰性求值的论 战也有关联。有些人认为函数式语言应当是惰性的，而其他人认为不是这样。有些人走折衷路线，只提供惰性列表以及用于构造它们的特殊语法（例如，在 SCHEME中［AS86］）。本论文提供了更进一步的证据，证明惰性求值非常重要以至于不能被降为二等公民。这也许是函数式程序员所拥有的最强大的黏合 剂。人们不应当阻碍对这样一个极为重要的工具的使用。 －－－－－－－－－－－－－－－－－－－－ 致谢 在 牛津程序设计研究组与Phil Wadler和Richard Bird的多次交谈对本论文的写作帮助甚大。约特堡查麦兹大学的Magnus Bondesson指出了一个数值算法的早期版本中的严重错误，同时也协助了很多其他算法的开发。本论文在英国科学与工程研究评议会提供的研究基金赞助下 发表。 －－－－－－－－－－－－－－－－－－－－ 参考文献 [AS86] H.Abelson,G.J.Sussman. 计算机程序的构造与解释. 麻省理工学院出版社,波士顿,1986 [Hug89] J.Hughes. 函数式程序设计为什么至关重要. 计算机月刊,32(2),1989 [Hug90] John Hughes. 函数式程序设计为什么至关重要. D.Turner主编,函数式编程的研究主题. Addison Wesley,1990 [MTH90] R.Milner,M.Tofte,R.Harper. Standard ML的定义. 麻省理工学院出版社,1990 [oD80] 美利坚合众国国防部. 程序语言Ada参考手册. Springer-Verlag,1980 [P.H82] P.Henderson. 纯函数式操作系统. 1982 [Tur81] D.A.Turner. 应用语言在语义上的优雅性. 1981年度函数式语言与计算机架构会议会报,海边温特渥,普茨茅斯,新汉普夏郡,1981 [Tur85] D.A.Turner. Miranda: 拥有多态类型的非严格语言. 1985年度函数式语言与计算机架构会议会报,1-16页,南锡,法国,1985 [Wir82] N.Wirth. Modula-II程序设计. Springer-Verlag,1982","link":"/sicp/20190421_whyfp.html"},{"title":"为什么函数式编程至关重要","text":"函数式程序的特点 函数式编程不包含任何赋值语句（也就是没有变量），所有的值从一开始就确定了 函数式编程不包含副作用，除了计数它本身的值以外不产生任何副作用，这一特性消灭了bug的一个主要来源 函数式编程值是一定的，那么执行顺序就不在重要，所以它可以在任何时候被执行，这一过程将程序员从控制流中解放 由于在任意时候求值，程序员可以随性所欲的用变量值来代替变量表达式，反之也可以用变量表达式代替变量的值。程序是引用透明，可以更容易的数学化控制 函数是一等公民，函数式编程中努力用函数来表达所有的概念，完成所有的操作 变量的不变性，赋值操作低人一等。简单将在scala函数是编程中只用val，不用var 函数式编程比传统编程代码更简洁，很大程度上是由于传统是编程90%的事情都是在干赋值的事，函数式编程这些都可以忽略。这仅仅是它的一个好处，不是说它就是函数式编程语言强大的原因 假如有两个函数g,f, 对于输入参数x假设是一个很长的序列, 要计算 g(f(x))传统的解决方法是先计算f(x)储存到临时文件中，这种方法临时文件可能占用很大的空间。函数式语言的解决方案是，程序g,f严格同步执行，只有当g需要数的时候它才会触发f，f从x取一个数计算返回给g，直到g试图获取下一个值。f的启动和终止取决于g，f甚至不会自行终止程序，因为当g运行结束时，f也会强制终止，这是的终止条件和循环体分离。这种求值方式按需求值，无需不求值 ，尽可能的减少运行，因此被称之为惰性求值。它使得将程序模块化为一个能产生大量可能解的生成器以及一个恰当的选择器变的可行。 惰性求值是程序员那首利器中威力最大的模块化工具 函数式语言威力强大主要是因为它们提供了两种新的黏合剂：高阶函数和惰性求值 循环迭代是在描述我们该如何地去解决问题。 递归是在描述这个问题的定义。 模块化是成功的程序设计的关键。以提高生产力为目标的程序语言，必须良好地支持模块化程序设计","link":"/sicp/whyfp.html"},{"title":"博文收藏","text":"博客收藏 道可叨http://zhuoqiang.me/ 函数式编程什么是函数式编程函数式代码是对“映射的描述”，输入x和输出y的映射关系 y=f(x)函数式编程在 描述是什么命令式编程在 应该怎样做 理解函数式编程 为什么我们需要（or不需要）科里化 什么是函数式编程思维？ / 知乎 Monad 最简介绍 符号: 抽象、语义(函数式表达最清晰的解释) 其他 程序如何定位自己","link":"/others/favo_blog.html"},{"title":"lambda演算python实现[三]之Bool值和分支","text":"原文出处：Lambda演算中的布尔值和选择 python实现用python定义Bool值和bool运算如下 123456789101112131415161718192021222324#用函数的方式定义Bool值TRUE#TRUE = lambda x,y:xdef TRUE(x,y): return x#用函数的方式定义Bool值FALSE#FALSE = lambda x,y:ydef FALSE(x,y): return y#用函数的方式定义Bool与#And = lambda x,y:x(y,FALSE)def And(x,y): return x(y,FALSE)#用函数的方式定义Bool或#Or = lambda x,y:x(TRUE,y)def Or(x,y): return x(TRUE,y)#用函数的方式定义Bool取反#Not = lambda x:x(FALSE,TRUE)def Not(x): return x(FALSE,TRUE) 验证一下，将Bool值带入一下运算1234567print(TRUE)print(\"and(True ,False):\",And(TRUE,FALSE))print(\"and(False,True ):\",And(FALSE,TRUE))print(\" or(True ,False):\", Or(TRUE,FALSE))print(\" or(False,True ):\", Or(FALSE,TRUE))print(\"not False :\",Not(FALSE))print(\"not True :\",Not(TRUE)) 得到1234567&lt;function TRUE at 0x00A88FA8&gt;and(True ,False): &lt;function FALSE at 0x00406810&gt;and(False,True ): &lt;function FALSE at 0x00406810&gt; or(True ,False): &lt;function TRUE at 0x00A88FA8&gt; or(False,True ): &lt;function TRUE at 0x00A88FA8&gt;not False : &lt;function TRUE at 0x00A88FA8&gt;not True : &lt;function FALSE at 0x00406810&gt; 看结果确实能够正确布尔计算。注：如果要用C语言实现，参数x,y的类型定义成指针类型即可。","link":"/sicp/lambda_03_bool_branch.html"},{"title":"lambda演算python实现[二]之数字","text":"原文出处：lambda演算中的数字 python实现数字和加法的函数表示 数字的定义123456789101112131415161718192021222324def _0(s,z): return zdef _1(s,z): return s(z)def _2(s,z): return s(s(z))def _3(s,z): return s(s(s(z)))_4 = lambda s,z:s(s(s(s(z))))_5 = lambda s,z:s(s(s(s(s(z)))))_6 = lambda s,z:s(s(s(s(s(s(z))))))_7 = lambda s,z:s(s(s(s(s(s(s(z)))))))_8 = lambda s,z:s(s(s(s(s(s(s(s(z))))))))_9 = lambda s,z:s(s(s(s(s(s(s(s(s(z)))))))))#add = lambda x,y:lambda s,z:x(s,y(s,z))def add(x,y): def curry0(s,z): return x(s,y(s,z)) return curry0 检验运行以下函数1234print(_2)print(_2)print(_3)print(add(_1, _2)) 得到：1234&lt;function _2 at 0x00611660&gt;&lt;function _3 at 0x006113D8&gt;&lt;function _5 at 0x006115D0&gt;&lt;function add.&lt;locals&gt;.curry0 at 0x006114F8&gt; 你会发现add加法，根本看不出任何信息 ,为什么呢？原因是我们定义的这些值和add操作都是函数，没有赋值推导就不会发生作用 为了让函数确实能发生变化，我们就要依赖于python的编译器，只要给这些表示数字的函数赋值，编译器就工作了，递归也就发生了为了能够清晰示意，我们把z 赋值成0，s也有意义的实现为一个递增函数。实际上这里的z,s的实现不一定是0和inc递增函数，只是这么实现是为了方便示意 让递归发生123456z = 0s = lambda x:x+1print(\"_2 :\",_2(s,z))print(\"_3 :\",_3(s,z))print(\"_5 :\",_5(s,z))print(\"add(_2,_3):\",add(_2, _3)(s,z)) 得到：1234_2 : 2_3 : 3_5 : 5 add(_2,_3): 5 #瞧！发生作用了，add(_2,_3) 和_5的值一样 数字赋予新的意义我们也可以用字符”+”的个数来代替我们定义的数字的意义123456z=\"\" s= lambda x:x+\".\"print(\"_2 :\",_2(s,z))print(\"_3 :\",_3(s,z))print(\"_5 :\",_5(s,z))print(\"add(_2,_3):\",add(_2, _3)(s,z)) 得到：1234_2 : ++ #表示2个“+”号 _3 : +++ #表示3个“+”号 _5 : +++++ #表示5个“+”号add(_2,_3): +++++ #得到5个“+”号，加法操作确实发生了作用 所以z,s只要定义的有意义，我们可以做更多的事情","link":"/sicp/lambda_02_number.html"},{"title":"Scala 避坑大法","text":"单引号双引号是有区别的 单引号表示：char字符 双引号表示：string字符 scala 为什么不建议用return return是命令时语句，Scala鼓励函数式编程，函数式在描述关系，而不是高速计算机怎么做 return会破坏Scala的类型推断，加上return 你得显式的声明返回类型 return在有些情况下使返回含义模糊 scala实际上并没有真正意义上的return语句，而是又抛出异常的语法糖包裹实现的","link":"/scala/scala_FAQ.html"},{"title":"Chisel 常见问题","text":"Q1: Q1:","link":"/chisel/chisel_QA.html"},{"title":"函数是编程的闭包和迭代器理解","text":"什么是闭包？闭包是一类特殊的函数。如果一个函数定义在另一个函数的作用域中，并且函数中引用了外部函数的局部变量，那么这个函数就是一个闭包。123456789101112def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum$ lazy_sum(1,2,3,4,5)&lt;function sum at 0x10452f668&gt;$ lazy_sum(1,2,3,4,5)()15 在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，称为闭包 需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了 f() 才执行。我们来看一个例子 1234567891011121314def count(): fs = [] for i in range(1,4): def f(): return i * 4 fs.append(f) return fs $ f1, f2, f3 = count()$ f1()9$ f2()9$ f3()9 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为她封装的是这个变量，最后求值的时候才会去取这个变量，上面i最后的值是3.所以三个函数得到的都是9如果非要在引用变量，可以这么做123456789def count(): fs = [] for i in range(1,4): def wrap(i): #i参数传递进去是确定的值 def f(): return i * 4 return f fs.append(wrap(i)) #已将i作为固定值传递进去 return fs 闭包有什么用处？本质上，闭包是将函数内部和函数外部连接起来的桥梁。1234567891011121314151617&gt;&gt;&gt; def ExFunc(n): sum=n def InsFunc(): return sum+1 return InsFunc&gt;&gt;&gt; myFunc=ExFunc(10)&gt;&gt;&gt; myFunc()11&gt;&gt;&gt; myAnotherFunc=ExFunc(20)&gt;&gt;&gt; myAnotherFunc()21&gt;&gt;&gt; myFunc()11&gt;&gt;&gt; myAnotherFunc()21&gt;&gt;&gt; 由于闭包把函数和运行时的引用环境打包成为一个新的整体，所以就解决了函数编程中的嵌套所引发的问题。如上述代码段中，当每次调用ExFunc函数时都将返回一个新的闭包实例，这些实例之间是隔离的，分别包含调用时不同的引用环境现场。不同于函数，闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例 他最根本的用途是提供了更深的代码复用 怎么理解函数是一等公民？变量是一等公民，变量怎么用，函数就能怎么用变量出现的地方，函数都可以出现 怎么理解函数式编程的惰性求值？函数式编程的主题之一是关注分离(separation of concerns)。希望将计算的描述与实际运行分离一般而言，惰性化对一个表达式分离了它的描述和求值。 12345678910scala&gt; def maybeTwice(b: Boolean, i: =&gt; int) = if(b) i+i else 0scala&gt; val x = maybeTwice(true, { println(&quot;hi&quot;); 42}) #{,x}的传参方法可以用于debughihix: Int = 84scala&gt; val x = maybeTwice(false, { println(&quot;hi&quot;); 42}) x: Int = 0 # 可以表达式{println(&quot;hi&quot;),2} 根本就没有被执行，它也不需要被执行，# 但是如果是传值调用，那么b不管真否，表达式都必须求值# 所以只有当用到时才求值，用不到不求值，也是传名调用的一种用途吧 反过来，如果这个参数被用到多次，那么传名参数要被求值多次，反而效率不如传值参数。 1234567scala&gt; def maybeTwice(b: Boolean, i: =&gt; int) = { | lazy val j = i | if(b) j+j else 0 | }scala&gt; val x = maybeTwice(true, { println(&quot;hi&quot;); 42})hix: Int = 84 惰性求值参考 如何理解lazy12345678910scala&gt; val x = { println(&quot;i&apos;m positive&quot;); &quot;Howdy&quot;} //赋值时就积极执行expr求值 赋值给变量i&apos;m positivex: String = Howdyscala&gt; println(x)Howdyscala&gt; lazy val y = { println(&quot;i&apos;m lazy&quot;); &quot;Vigilance&quot;} //等用到y的时候在执行expry: String = &lt;lazy&gt;scala&gt; println(y)i&apos;m lazyVigilance scala 的传名调用，传值调用() =&gt; Unit 是函数=&gt; Unit 是执行结果为Unit的表达式12345678910111213object Add { def addByName(a: Int, b: =&gt; Int) = a + b + b def addByValue(a: Int, b: Int) = a + b + b }scala&gt; Add.addByValue(2, {println(&quot;callByValue&quot;);3})callByValue # b 的求值只被执行了一次，传值调用res15: Int = 8scala&gt; Add.addByName(2, {println(&quot;callByName&quot;);3})callByName # b 被执行了2次，传名调用callByNameres17: Int = 8 到现在 你可以发现传名参数本质就是将参数的lazy化，类似于 def addByName(a: Int, lazy b: Expr)，只不过没有定义成这种语法而已 Chisel里的lazy module有什么用？官方解释The LazyModule construct was created as a way to delay calling the constructor until after there’s been a chance to calculate the parameters to give it. LazyModule decouples the point in the code where a circuit element is instantiated, from the point in the code where the constructor is called and that instance is actually built. In Rocket, one main driver of this lazy approach is Diplomacy), which creates the TileLink2 and AXI connections on the chip. Diplomacy, in turn, is built on top of the Cake pattern 怎么理解函数式编程无副作用？","link":"/sicp/20190414-fp-closure-iterator.html"},{"title":"Hexo 技巧收录","text":"草稿功能草稿相当于很多博客都有的“私密文章”功能。1$ hexo new draft \"new draft\" 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。如果你希望强行预览草稿，更改配置文件： 1render_drafts: true 或者，如下方式启动server：1$ hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面：1$ hexo publish [layout] &lt;filename&gt;","link":"/others/hexo_utlis.html"},{"title":"Python lambda实现Y组合子","text":"也许你我都难以理解，为什么有人对她痴迷疯狂，铭记在心中不说，还要刻在身上： 她让人绞尽脑汁，也琢磨不定！她让人心力憔悴，又百般回味！ 她，看似平淡，却深藏玄机！她，貌不惊人，却天下无敌！ 她是谁？ 她就是 Y 组合子：Y = λf.(λx.f (x x)) (λx.f (x x)) ，不动点组合子中最著名的一个。 原文出处 python 利用Y算子实现递归阶乘函数 1((lambda S : (lambda x: (S(lambda y: x(x)(y))))(lambda x: (S(lambda y: x(x)(y)))))(lambda f:lambda n: 1 if(n==0) else (n*f(n-1))))(10) 复制此段代码到python shell可以看到阶乘10的正确结果","link":"/sicp/python-fp.html"},{"title":"Chisel BugList","text":"[ ] BitPat length bugs BitPat.pare(&quot;b1100_0000&quot;) = (192,255,9) 实际8bit，返回9bit BitPat.pare(&quot;b11000000&quot;) = (192,255,8) 12335: (bits, mask, x.length - 1) fix 剔除字符&apos;_&apos; 后统计长度35: (bits, mask, x.filter(_!=&apos;_&apos;).length - 1) [ ] bug2","link":"/chisel/chisel_bugs.html"},{"title":"Chisel版本","text":"如何查看当前使用的chisel版本一般情况下chisel的版本会在build.sbt里显式定义，但有时候像jupter-notebook里并不能看到版本号这种情况下有一个方法可以得到版本号即生成的firrtl文件头会打印版本信息 12;buildInfoPackage: chisel3, version: 3.1.2, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2018-07-25 16:52:17.431, builtAtMillis: 1532537537431circuit T1 : 修改chisel 版本 12libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.1.2\"libraryDependencies += \"edu.berkeley.cs\" %% \"chisel-iotesters\" % \"1.2.2\" 如何知道最新release的chisel 版本号 ，可以访问 https://index.scala-lang.org/ 搜索chisel3 查看当前release版本比如当前最新版本为3.1.7 , 修改build.sbt 重新sbt run时会自动下载最新版本库到~/.ivy2 libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.1.7\" chisel Scala 版本对应关系 scala sbt chisel firrtl 状态 2.11.x x.x.x 3.1.x x.x.x 正常 2.12.x x.x.x 3.1.x x.x.x Fail, IO Bundle Error chisel 3.1.x firrtl版本策略","link":"/chisel/20190411_chisel_version.html"},{"title":"Chiel Keep变量名","text":"how to keep chisel variable name when generate verilogThere are several reasons why a name may be disappearing. Constant PropagationFor many reasons, including interoperability with existing CAD tools, performance, and Verilog debug-ability, Chisel (actually the FIRRTL compiler underneath Chisel) will propagate constants and direct wire connections. For example: 123456789class MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val wire = Wire(UInt(8.W)) wire := io.in io.out := wire} In the above code, wire will be removed because it is simply connected to io.in, the Verilog will just show: assign io_out = io_in;Inability to nameChisel Modules are implemented as Scala Classes. Due to implementation reasons, by default Chisel can only name “top-level” vals in the body of the Module, for example: 12345678910111213141516class MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val in2 = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val sum = io.in + io.in2 // this is a top-level val, will be named // A method, we can call to help generate code: def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented } io.out := inc(sum)} suggestNameYou can manually name any signal by calling .suggestName(“name”) on it, eg. 1234def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented.suggestName(&quot;incremented&quot;) // Now it is named!} Enter @chiselNameWe can fix the above issue with an experimental feature called @chiselName like so: 12345678910111213141516171819import chisel3.experimental.chiselName@chiselNameclass MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val in2 = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val sum = io.in + io.in2 // this is a top-level val, will be named // A method, we can call to help generate code: def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented } io.out := inc(sum)} @chiselName is an annotation that can be used on any class or object definition and will ensure vals like incremented can get named. @chiselName effectively rewrites your code to put .suggestName all over the place. I hope this helps! EDIT more info:Disabling OptimizationsI don’t think it’s in a release yet (most recent being 3.1.7, this will be in 3.2.0), but we do have an option to disable all optimizations. You can change the “compiler” used from verilog to mverilog (for “minimum” Verilog, ie. no optimizations). This can be done with the command-line argument -X mverilog either in Chisel or FIRRTL. Don’t TouchYou can also use chisel3.experimental.dontTouch to mark a signal as something that shouldn’t be deleted. This will prevent optimizations from removing the signal. For example: 123456789import chisel3.experimental.dontTouchclass MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val wire = dontTouch(Wire(UInt(8.W))) wire := io.in io.out := wire I’ve edited my response to talk about how to disable optimizations (not in the current release, you can wait for 3.2 which should be out in a couple of weeks or build Chisel manually from master and use that). I should caution that running formal equivalence tools tend to struggle comparing large designs with and without optimizations, but you can try it. For specific signals, dontTouch can help with what you want. o 原文链接","link":"/chisel/20190401_chisel_keep_name.html"},{"title":"Verilog 模块重名问题","text":"Chisel 不同开发生产的Verilog 模块名冲突同学A 负责开发AP同学B 负责开发CP其中都会用到Queue，生产的AP_system_top.v CP_system_top.v中可能都会包含一个module Queue (集成到SOC_top.v时会面临模块名冲突的问题，目前Chisel 本身没有提供解决该问题的方法。只能依赖于原始verilog 的解决方法 Verilog 模块名冲突解决方法仿真命令如下 1vcs -top $top_cfg_name_in_libmap -libmap $libmap_file 1234567891011121314library default_lib $project;library cp_rocket_lib $project/cp/rocket_chip/*.v;library top_rocket_lib $project/top/rocket_chip/*.v;library i2c_ahb_lib $project/top_peri/i2c_ahb/*.v;config chip_cfg; design tb_top ; default liblist default_lib; instance tb_top.U_chip.U_system_top.U_cp_top.U_cp_rocket liblist cp_rocket_lib ; instance tb_top.U_chip.U_system_top.U_top_rocket liblist top_rocket_lib; instance tb_top.U_chip.U_system_top.U_top_peri_sys.U_i2c_ahb liblist i2c_ahb_lib ;endconfig 综合应该也差不多","link":"/chisel/20190322_chisel_module_confilict.html"},{"title":"Chisel组合逻辑时序逻辑","text":"时序逻辑的声明和写法123456789101112131415161718192021实例1 val tiRomStartAddr = RegInit(0.U(6.W)) //显示的声明Reg when (io.swif.K&lt;40.U ){tiRomStartAddr := 25.U } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := 21.U } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := 35.U } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := 15.U } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := 10.U } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := 5.U } .otherwise {tiRomStartAddr := 25.U }实例2 val RRomRdata = RegInit(0.U(log2Up(pm.MaxR).W)) //显示的声明Reg并初始化（switch语句不带default) switch (io.RRomAddr) { is (0.U) {RRomRdata := intraRowTi.RRomVal(0).U} is (1.U) {RRomRdata := intraRowTi.RRomVal(1).U} is (2.U) {RRomRdata := intraRowTi.RRomVal(2).U} is (3.U) {RRomRdata := intraRowTi.RRomVal(3).U} is (4.U) {RRomRdata := intraRowTi.RRomVal(4).U} is (5.U) {RRomRdata := intraRowTi.RRomVal(5).U} is (6.U) {RRomRdata := intraRowTi.RRomVal(6).U} is (7.U) {RRomRdata := intraRowTi.RRomVal(7).U} } 组合逻辑的声明与写法123456789101112131415161718192021222324252627实例1 val tiRomStartAddr = Wire(UInt()) //显示的声明Wire when (io.swif.K&lt;40.U ){tiRomStartAddr := 25.U } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := 21.U } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := 35.U } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := 15.U } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := 10.U } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := 5.U } .otherwise {tiRomStartAddr := 25.U }实例2 val RRomRdata = Wire(UInt()) //显示的声明Wire RRomRdata := 0.U //一定要设默认值，否则组合逻辑条件不全chisel编译不过（verilog组合逻辑条件不全会产生锁存器） switch (io.RRomAddr) { is (0.U) {RRomRdata := intraRowTi.RRomVal(0).U} is (1.U) {RRomRdata := intraRowTi.RRomVal(1).U} is (2.U) {RRomRdata := intraRowTi.RRomVal(2).U} is (3.U) {RRomRdata := intraRowTi.RRomVal(3).U} is (4.U) {RRomRdata := intraRowTi.RRomVal(4).U} is (5.U) {RRomRdata := intraRowTi.RRomVal(5).U} is (6.U) {RRomRdata := intraRowTi.RRomVal(6).U} is (7.U) {RRomRdata := intraRowTi.RRomVal(7).U} } 实例3 val PrimeRom = Vec(PrimeAndRoot.map(_.U)) //ROM默认生成的是组合逻辑，寄存器输出自己加一级 io.out3 := PrimeRom(io.i)","link":"/chisel/20190321_chisel_comb_reg.html"},{"title":"Scala 初探.三(sbt组织scala代码1)","text":"上一节我们用Makefile来组织scala代码，这里有更好的选择sbt来管理项目sbt推荐将scala代码放在src路径，如下为标准的组织方式(代码还是原封使用第二节的样例代码)总共3个文件 1234567├── build.sbt└── src └── main └── scala ├── a.scala ├── b.scala └── c.scala 输入命令 sbt test 编译没报错输入命令 sbt run 提示找到了2个入口函数12345678Multiple main classes detected, select one to run: [1] com.east.objectMain [2] com.north.NorthWolf[info] Packaging E:\\nutstore\\2017pc\\lab\\scala\\sbtProj\\target\\scala-2.11\\sbtproj_2.11-0.1.0-SNAPSHOT.jar ...[info] Done packaging.Enter number: 跟我们的预期一致，确实a.scala中 和c.scala分别存在两个main入口 ,用不同的方式实现 12345678910111213141516//a.scalapackage com.east import com.west._object objectMain extends App{ println(\"add Function from west used in east, 1+2=%d\".format(Add.add(1,2))) } //c.scalapackage com.north import com.west._object NorthWolf { def main(args:Array[String]) { println(\"add Function from west used in north, 3+4=%d\".format(Add.add(3,4))) args.map(println) }} 也可以sbt &quot;runMain com.north.NorthWolf arg1 arg2&quot; 直接选定要执行的main入口 其他sbt 相关的命令可以自行在网上搜索 SBT打包jarsbt compile 后会在根目录下生成","link":"/scala/20190308_scala_sbt1.html"},{"title":"Scala 初探.二(package组织方式)","text":"多个文件的package组织方式123456//a.scala package com.east import com.west._object objectMain extends App{ println(\"add Function from west used in east, 1+2=%d\".format(Add.add(1,2)))} 12345//b.scala package com.west object Add { def add(a:Int, b:Int) = a + b} 多个文件的package组织方式编译 scalac a.scala b.scala 生成com文件夹（JVM 编译完的.class文件）运行 scala com.east.main 正确打印信息 object main 方式 1234567891011121314151617181920212223//c.scala package com.north object NorthWolf { def main(args:Array[String]){ println(\"add Function from west used in north, 3+4=%d\".format(Add.add(3,4))) }} ``` 编译 `scalac a.scala b.scala c.scala` 更新com文件夹 运行 `scala com.north.NorthWolf` 正确打印信息 Makefile 如下```Makefileobjects = comsource = a.scala b.scala c.scala.PHONY: runrun:com scala com.east.objectMain scala com.north.NorthWolf $(objects) : $(source) scalac $(source) SCALA编译生成的com为package目录, *.class 为class字节码，可以被JVM执行(所以SCALA编译玩的.scala可以在任何JVM上执行，也就说scala的程序也可以在Android上运行)比如com/east/main.class ,可以直接scala com.east.main来执行 123456789101112$:tree com com├── east│ ├── main$.class│ ├── main$delayedInit$body.class│ └── main.class├── north│ ├── NorthWolf$.class│ └── NorthWolf.class└── west ├── Add$.class └── Add.class 关于*.scala 和 *$.scala 的区别可以在网上自行搜索 原则上只要把com文件夹打包就可以发布为一个SCALA/JAVA程序 jar打包和运行如何讲程序打包成jar 命令行运行jar cvf com.jar com 得到com.jar在任意地方 scala -classpath com.jar com.north.NorthWolf 可直接运行函数 实例参见目录/nutstore/2017pc/lab/scala/packageTest","link":"/scala/20190308_scala_package.html"},{"title":"Scala 初探.四(sbt组织scala代码2)","text":"package and import1234567├── build.sbt└── src └── main └── scala ├── Interleave.scala ├── utils.scala └── config.scala 对于同一目录下的两个文件，可以不用import，默认在一个package内 12345//Interleave.scalaclass A { val a = new ClassInUtils} 12345//utils.scala class ClassInUtils{ } Interleave.scala 不需要import ClassInUtils ,直接使用就可以，sbt 会帮你搞定编译 sbt import 错误解决12345scalaDSL&gt; tree src ~/lab/scalaDSLsrc├── main └── scala └── parser.scala 12345678910import scala.util.parsing.combinator._class Arith extends JavaTokenParsers {}object XXtest { def main(args: Array[String]) { println(\"Hello scala ***\") }} sbt run 总是会显示123.....object parsing is not a member of pacakge util[error] import scala.util.parsing.combinator._[error] ^ scala src/main/scala/parser.scala 可以正常打印Hello scala *** 命令行的scala版本2.12.6， build.sbt 还是scala 2.12.6 ，所以怀疑是不是sbt的版本有问题查看project/build.property版本号为1.2.8 ，改为1.1.1， 1.1.2都是同样的问题后来在网上搜到，build.sbt需要添加librarydependence 。如下12345name := \"scalaDSL\"version := \"0.1\"//添加下面一行libraryDependencies += \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"1.0.2\"scalaVersion := \"2.11.12\" 重新sbt run编译正常备注：由于在网上搜到的scala-parser-combinators版本为1.0.2，对应的scala版本是2.11因此 scalaVersion := &quot;2.12.6&quot; 改成 scalaVersion := &quot;2.11.12&quot; 同理IDEA设置中有时候发现scala sbt版本都设置正确了，但是有些库还是找不到，显示红色，很可能就是 libraryDependencies 设置问题","link":"/scala/20190308_scala_sbt2.html"},{"title":"Scala 初探.一(main函数)","text":"SCALA 程序的几种运行方式方法1脚本式的使用，scala a.scala 可正常打印1234def main() = { println(\"Hello, Scala way1\")}main() 但这种写法不能被 scalac a.scala正确编译，可能JVM对象必须要有个main入口函数 方法2 object mainJava中一个类要独立运行，必须具有静态的main方法，如下123public static void main(String[] args) { ... } scala 种借鉴了这种方法，为了独立运行一个SCALA程序，必须定义一个scala object并且为其定义main方法命令行scala a.scala会直接运行main函数，其中args为命令行参数 123456object RunAppDemo { def main(args:Array[String]) { println(\"Hello, Scala within object main\") args.map(println) } } Scala中的Object相当于java中的静态类，在其上可以定义静态的方法。Scala允许一个类定义自己的“伴生对象”(Companion Object)，它们具有相同的名字，必须位于同一个文件中，并且可以互相引用各自的私有成员。Scala的Object也可以独立存在。如果一个Scala Object没有伴生对象，我们称之为“独立对象”（Standardalone Object），反之，对象和类互为友元。上述代码main方法中的参数args是从命令行中传入的参数列表，具体用法和java类似。 如果a.scala 定义两个main函数，会默认执行第一个出现的main函数123456789101112object RunAppDemo { def main(args:Array[String]) { println(\"Hello, Scala within object main\") args.map(println) } } object RunAppDemo2 { def main(args:Array[String]) { println(\"Hello, Scala within object main2\") } } 方法3 extends App为了使代码更简洁，Scala还提供了另外一种运行Scala程序的方式，那就是直接继承scala.App接口（Trait）。 123object RunAppWithoutMain extends App { println(\"runing scala app without main\") } 之所以这里无须定义main方法，那是因为在App这个接口中定义了一个main方法，main方法在执行时会初始化RunAppWithoutMain这个对象，并执行它的主构造方法，而所有直接写在对象中的代码都会被scala编译器收集到主构造方法中，于是就被运行了。 这种方法虽然省略了一些代码，但是也有一些副作用。 直接继承自Application导致的副作用: 无法接受命令行参数。因为args参数不会被传入 在Scala中，如果一个程序是多线程的，那么这个程序必须具有一个main方法。所以这种写法只能适用于单线程的程序 App这个接口在执行一个程序的代码之前，需要进行一些初始化。而某些JVM不会对这些初始化代码进行优化。 所以第二种方法只适用于一些非常简单的场合，大部分情况不推荐使用。","link":"/scala/20190308_scala_main.html"},{"title":"RISCV 矢量处理器","text":"RISC-V向量的工作过程 setp1 : 首先要确定向量的类型 比如你要做一个向量运算 Y = a*X + Y ,如果X, Y 都是双精度的浮点的向量，那么就需要申请两个F64类型的向量v0和v1, 如果是 Z = a*X + Y ,同样X,Y是双精度的浮点的向量，那么就需要至少申请3个F64类型的向量v0和v1,v2分别给X,Y,Z使用 RV32V 向量寄存器类型的编码如下 Type Floating Poing Signed Interger Unsigned Interger Width Name vetype Name vetype Name vetype 8bit — — X8 10100 X8U 11100 16bit F16 01101 X16 10101 X16U 11101 32bits F32 01110 X32 10110 X32U 11110 64bits F64 01111 X64 10111 X64U 11111 setp2 : 然后申请向量的个数 假如向量寄存器总共有1024Byte ，如果只给2个向量使用,那么对半分，每个向量可以分得512Byte的空间，F64=8Byte，所以 每个向量可以有512/8=64个F64类型的元素，也就是mvl(max_vecotr_length)=64， 一次可以计算的个数是64个元素。 如果我们的X,Y的长度假设是100，那么完成 Y = a*X + Y 需要2次向量操作， 第一次vl选64， 计算64个F64向量的运算 第二次vl选100-64= 36, 计算剩余的36个F64向量的运算 FAQ 何为mvl max_vector_ 何为ml","link":"/riscv/20181221_riscv_verctor.html"},{"title":"Chisel 实例问题汇总","text":"chisel-example \\ chisel-tutorial 同样代码，生成器输出不一致问题同样的一份代码src/main/scala/GCD.scalasrc/test/scala/GCDTester.scala 其中生成vcd波形的代码12345object GCDTester extends App { iotesters.Driver.execute(Array(\"--target-dir\", \"generated\", \"--fint-write-vcd\"), () =&gt; new GCD){ c =&gt; new GCDTests(c) }} 在chisel-example 目录下 sbt &quot;test:runMain simple.GCDTester&quot; 可以生成GCD波形1234&gt;&gt; l generated/examples.GCDTester1802184992-rwxr-xr-x+ 1 Administrator None 6 Dec 5 14:53 GCD.anno.json-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.fir-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.lo.fir 在chisel-tutorial 目录下 sbt &quot;test:runMain simple.GCDTester&quot; 不能生成GCD波形 1234&gt;&gt; l generated/examples.GCDTester1802184992-rwxr-xr-x+ 1 Administrator None 6 Dec 5 14:53 GCD.anno.json-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.fir-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.lo.fir 导致的原因是，build.sbt 不一样 , 可能是引入的库的版本不一致导致，123456789//chisel-tutorial/build.sbtval defaultVersions = Map( // \"chisel3\" -&gt; \"3.1.+\", // \"chisel-iotesters\" -&gt; \"1.2.+\" //将上面两行注释掉，改为3.1.2， 1.2.2 //否则可能会默认使用.ivy2/cache/edu.berkeley.cs/chisel3_2.11/jars/chisel3_2.11-3.1.3.jar \"chisel3\" -&gt; \"3.1.2\", \"chisel-iotesters\" -&gt; \"1.2.2\" ) iotesters.Driver.execute(Array(&quot;--target-dir&quot;, &quot;generated&quot;, &quot;--fint-write-vcd&quot;), () =&gt; new GCD){ chisel-example下的build.sbt chisel-tutorial下的build.sbt 结论：保险起见，使用一下两个版本号：12libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chisel3&quot; % &quot;3.1.2&quot;libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chisel-iotesters&quot; % &quot;1.2.2&quot;","link":"/chisel/20181205_chisel_learning.html"},{"title":"从Shell传递变量给verilog的两种方法","text":"通过define宏传递 首先在命令行中定义define 1234567vcs -sverilog -debug_all +define%s+CASENAME=\\\"%s\\\" -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log -f top.f 尤其要注意CASENAME=\\&quot;%s\\&quot;的转义“\\”的应用，比如命令行被包含在python脚本内部，需要两次转义, 而shell可能只要一次 123def run(case,defines=\"\"): os.system('vcs -sverilog -debug_all +define%s+CASENAME=\\\\\"%s\\\\\" -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log -f top.f'%(defines,case)) os.system('./simv -l sim.log +notimingcheck +nospecify +loopreport +memcbk +novopt') 否则verilog文件是无法获取CASENAM的意思 然后在verilog中通过宏取出 1fp_reg = $fopen({\"./case/\",`CASENAME,\"/source_dpp.txt\"},\"r\"); 这种方式比较繁琐，而且转义嵌套难以理解，另外一种方便的方法如下 通过option arg传递 首先在命令行的option里定义两个puls类型的args, +DUMPWAVE和TESTCASE 1234run: compile rm -rf ${TEST_RUNDIR} mkdir ${TEST_RUNDIR} cd ${TEST_RUNDIR}; ${SIM_EXEC} +DUMPWAVE=${DUMPWAVE} +TESTCASE=${TESTCASE} |&amp; tee ${TESTNAME}.log; cd ${RUN_DIR}; 然后在verilog文件中通过$val$plusargs()获取val 123456789101112131415reg [8*300:1] testcase;integer dumpwave;initial begin if($value$plusargs(\"TESTCASE=%s\",testcase))begin $display(\"TESTCASE=%s\",testcase);endinitial begin $value$plusargs(\"DUMPWAVE=%d\",dumpwave); if(dumpwave != 0)begin // To add your waveform generation function $fsdbDumpfile(\"./e203.fsdb\") ; $fsdbDumpvars(0,tb_top); $fsdbDumpflush; endend","link":"/eda/how_to_send_param2tb.html"},{"title":"Chisel-Verilog查找表优先级问题讨论","text":"Chisel 查找表电路优先级问题verilog ROM的两种写法及区别1234567891011121314151617181920212223方法1always @(posedge clk )begin case(addr0) 6'd0 : data0 &lt;= 8'd214; 6'd1 : data0 &lt;= 8'd213; 6'd2 : data0 &lt;= 8'd212; 6'd3 : data0 &lt;= 8'd211; 6'd4 : data0 &lt;= 8'd210; 6'd5 : data0 &lt;= 8'd209; 6'd6 : data0 &lt;= 8'd208; 6'd7 : data0 &lt;= 8'd207; 方法2always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; 方法2是不是带优先级？ 实际上是不带优先级逻辑上if取的条件都是addr1的值，一定是互斥的，综合工具也能自动识别出这种if else它有别于以下这种情况，这种情况下是真实带有优先级的电路，其中another_cond_A,another_cond_B是独立的两个输入条件，和addr1的取值可能同时发生，所以不能被综合器当做查找表来对待。 12345678910always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(another_cond_A ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(another_cond_B ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; chisel中查找表的写法以及对应电路1234567891011121314方法一switch (addr) { is( 0.U ) { rdata:= 8'd150 } is( 1.U ) { rdata:= 8'd149 } is( 2.U ) { rdata:= 8'd148 } is( 3.U ) { rdata:= 8'd147 } is( 4.U ) { rdata:= 8'd146 } is( 5.U ) { rdata:= 8'd145 } is( 6.U ) { rdata:= 8'd144 } is( 7.U ) { rdata:= 8'd143 }}方法二val ROM = Vec(Array(150.U,149.U,148.U, 143.U))val rdata = ROM(addr) 两种方法都会生成以下类似电路，等效CASE语句写法。所以不用担心优先级的问题。 12345678910always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; 综合工具对上面电路的处理也是没有优先级的。 综合对比Verilog DEMO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104module caseifelse_top ( clk,in_en0,in_addr0,out_data0,in_en1,in_addr1,out_data1);input clk ;input in_en0 ;input in_en1 ;input [5:0] in_addr0 ;input [5:0] in_addr1 ;output [7:0] out_data0 ;output [7:0] out_data1 ;reg [7:0] out_data0 ;reg [7:0] out_data1 ;reg [5:0] addr0 ;reg [5:0] addr1 ;reg en0 ;reg en1 ;wire [7:0] data0 ;wire [7:0] data1 ;always @(posedge clk )begin en0 &lt;= in_en0 ; en1 &lt;= in_en1 ; addr0 &lt;= in_addr0 ; addr1 &lt;= in_addr1 ; out_data0 &lt;= data0 ; out_data1 &lt;= data1 ;end rom u_rom_table(.clk (clk ),.en0 (en0 ),.addr0 (addr0 ),.data0 (data0 ) );ifelse u_ifelse_table(.clk (clk ),.en1 (en1 ),.addr1 (addr1 ),.data1 (data1 ) );endmodule module rom(clk,rstn,en0,addr0,data0);input clk ;input rstn ;input en0 ;input [5:0] addr0 ;output [7:0] data0 ;reg [7:0] data0 ;always @(posedge clk )begin case(addr0) 6'd0 : data0 &lt;= 8'd214; 6'd1 : data0 &lt;= 8'd213; 6'd2 : data0 &lt;= 8'd212; 6'd3 : data0 &lt;= 8'd211; 6'd4 : data0 &lt;= 8'd210; 6'd5 : data0 &lt;= 8'd209; 6'd6 : data0 &lt;= 8'd208; 6'd7 : data0 &lt;= 8'd207;。。。 6'd63: data0 &lt;= 8'd151; default : data0 &lt;= 8'd0; endcase end endmodule module ifelse(clk,en1,addr1,data1);input clk ;input en1 ;input [5:0] addr1 ;output [7:0] data1 ;reg [7:0] data1 ;always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143;。。。 else if(addr1 == 6'd63) data1 &lt;= 8'd87; else data1 &lt;= 8'd1 ;end endmodule 综合后的网表 看到两种方法都是基本相同，没有优先级区别 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465module caseifelse_top_ifelse_1 ( clk, en1, addr1, data1 ); input [5:0] addr1; output [7:0] data1; input clk, en1; wire N67, N69, n8, n9, n10, n17, n18, n19, n1, n2, n3, n4, n5; SDFKCNQD1BWP7T40P140UHVT data1_reg_7_ ( .D(n8), .CN(n10), .SI(n9), .SE(n9), .CP(clk), .Q(data1[7]) ); SDFKSNQD1BWP7T40P140UHVT data1_reg_6_ ( .SN(n10), .D(addr1[5]), .SI(n9), .SE(n9), .CP(clk), .Q(data1[6]) ); MB2SRLSDFQD1BWP7T40P140LVT data1_reg_1_0_ ( .D1(n19), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[1]), .D2(addr1[0]), .Q2(data1[0]) ); MB2SRLSDFQD1BWP7T40P140UHVT data1_reg_5_4_ ( .D1(N69), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[5]), .D2(n17), .Q2(data1[4]) ); OA21D1BWP7T35P140UHVT U3 ( .A1(n4), .A2(n2), .B(n1), .Z(N67) ); ND2D1BWP7T30P140UHVT U4 ( .A1(addr1[4]), .A2(n1), .ZN(n10) ); ND2D1BWP7T30P140UHVT U5 ( .A1(n2), .A2(n4), .ZN(n1) ); ND3D1BWP7T30P140UHVT U6 ( .A1(addr1[0]), .A2(addr1[1]), .A3(addr1[2]), .ZN( n4) ); ND2D1BWP7T35P140UHVT U7 ( .A1(addr1[0]), .A2(addr1[1]), .ZN(n3) ); INVD1BWP7T35P140UHVT U8 ( .I(addr1[3]), .ZN(n2) ); INVD1BWP7T35P140UHVT U9 ( .I(addr1[5]), .ZN(n8) ); OAI21D1BWP7T35P140UHVT U10 ( .A1(addr1[0]), .A2(addr1[1]), .B(n3), .ZN(n19) ); OAI21D1BWP7T35P140UHVT U11 ( .A1(n5), .A2(addr1[2]), .B(n4), .ZN(n18) ); MAOI22D1BWP7T40P140UHVT U14 ( .A1(n10), .A2(n8), .B1(n8), .B2(n10), .ZN(N69) ); MB2SRLSDFQD1BWP7T40P140UHVT data1_reg_3_2_ ( .D1(N67), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[3]), .D2(n18), .Q2(data1[2]) ); TIELBWP7T40P140LVT U12 ( .ZN(n9) ); INVD1BWP7T40P140UHVT U13 ( .I(n3), .ZN(n5) ); OAI21D1BWP7T40P140UHVT U15 ( .A1(addr1[4]), .A2(n1), .B(n10), .ZN(n17) );endmodulemodule caseifelse_top_rom_1 ( clk, rstn, en0, addr0, data0 ); input [5:0] addr0; output [7:0] data0; input clk, rstn, en0; wire N235, N237, N238, n7, n14, n15, n16, n1, n2, n3, n4, n5, n6; SDFQOPPSAD1BWP7T40P140UHVT data0_reg_0_ ( .D(addr0[0]), .SI(n7), .SE(n7), .CP(clk), .Q(data0[0]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_2_1_ ( .D1(n15), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[2]), .D2(n16), .Q2(data0[1]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_4_3_ ( .D1(n14), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[4]), .D2(N235), .Q2(data0[3]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_6_5_ ( .D1(N238), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[6]), .D2(N237), .Q2(data0[5]) ); AO21D1BWP7T35P140UHVT U3 ( .A1(n6), .A2(n5), .B(n4), .Z(n14) ); AO21D1BWP7T35P140UHVT U4 ( .A1(n3), .A2(n2), .B(n1), .Z(n15) ); INVD1BWP7T35P140UHVT U5 ( .I(addr0[2]), .ZN(n2) ); ND2D1BWP7T35P140UHVT U6 ( .A1(addr0[0]), .A2(addr0[1]), .ZN(n3) ); NR2D1BWP7T35P140UHVT U7 ( .A1(n2), .A2(n3), .ZN(n1) ); INVD1BWP7T35P140UHVT U8 ( .I(addr0[4]), .ZN(n5) ); NR2D1BWP7T35P140UHVT U9 ( .A1(addr0[3]), .A2(n1), .ZN(n6) ); NR2D1BWP7T35P140UHVT U10 ( .A1(n5), .A2(n6), .ZN(n4) ); OAI21D1BWP7T35P140UHVT U11 ( .A1(addr0[0]), .A2(addr0[1]), .B(n3), .ZN(n16) ); AOI21D1BWP7T35P140UHVT U12 ( .A1(n1), .A2(addr0[3]), .B(n6), .ZN(N235) ); AOI21D1BWP7T35P140UHVT U13 ( .A1(addr0[5]), .A2(n4), .B(N238), .ZN(N237) ); NR2D1BWP7T35P140UHVT U14 ( .A1(n4), .A2(addr0[5]), .ZN(N238) ); TIELBWP7T40P140LVT U15 ( .ZN(n7) );endmodule 代码目录：/nutstore/2017pc/lab/turbo/scala/work 结论chisel 虽然生成的电路没有CASE语句，也完全没有问题，if else的写法也能满足查找表的实现，并不会有优先级的问题 扩展同样一下两种chisel和verilog的写法对于综合器来说其实都是没有优先级的，综合器可以根据时序情况将其打平，并不影响电路的功能（本质上每个条件都不重叠，所以没有真实的优先级物理意义）因此可以大胆的采用这种写法而不用考虑优先级进位链太长而产生的时序问题。 1234567891011121314151617181920212223 when (io.swif.K&lt;40.U ){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := baseR5 } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := baseR10 } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := baseR10 } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;2480.U){tiRomStartAddr := baseR20 } .elsewhen (io.swif.K&lt;3160.U){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;3210.U){tiRomStartAddr := baseR20 } .otherwise {tiRomStartAddr := baseRAny } ``` ```verilog if (K&lt;40 ){addr := 5&apos;d0 } else if (K&lt;159 ){addr := 5&apos;d1 } else if (K&lt;200 ){addr := 5&apos;d2 } else if (K&lt;481 ){addr := 5&apos;d4 } else if (K&lt;530 ){addr := 5&apos;d6 } else if (K&lt;2881){addr := 5&apos;d0 } else if (K&lt;2480){addr := 5&apos;d9 } else if (K&lt;3160){addr := 5&apos;d0 } else if (K&lt;3210){addr := 5&apos;d8 } else {addr := 5&apos;d0 }","link":"/chisel/20190320_verilog_case_ifelse.html"},{"title":"IDEA Scala开发环境配置","text":"IDEA 下载社区版本是免费的，scala开发够用，专业版面向web部分是收费的 启动idea ，import project 按钮倒入 .sbt 文件 setting java JDK, File&gt;&gt;Project Structure&gt;&gt;Project&gt;&gt;Project SDK, 按new ,选择JAVA jdk. 默认会自动识别，否则手动下载指定xxx/1.8.0-openjdk-amd64)(一般要求1.8版本) ![01](http://ppw74l91w.bkt.clouddn.com/IDEA/01.png) setting scala JDK, 下载scala 太慢，可以直接brows选择 你的ivy2目录，如果是mac隐藏目录，可以按shift + command + .切换是否显示隐藏目录 如果你的ivy2目录下有不同版本的scala，默认会全部倒入，只选择你要安装的版本号，其他版本list按delete删除。 restart IDEA build.sbt 设置正确的版本依赖 set root directory Rigth click on project root dir “rocket-chip” ,右键选择Mark Directory as &gt;&gt; Sources Root IDE主要用来写代码，但是不推荐在IDED 内部Build，在terminal 利用Makefile来维护和build 会更可靠。","link":"/riscv/20181130_idea_scala_config.html"},{"title":"Makefile 笔记","text":"规则伪目标变量变量定义的3种方式 1 foo = bar (递归展开式变量) 会在引用$(foo)地方原地替换，直到不能再替换，这种方式称之为递归展开式变量 1234foo = $(bar)bar = $(ugh)ugh = Huh?all @echo $(foo) 以上例子会在@echo $(foo) 地方递归展开 缺点一 ： 是当嵌套定义 foo = $(foo) bar 时讲进入死循环，导致Make失败 其他例子 x = $(y) y = $(x) $(z) 同样会陷入死循环，所以这种定义方法只推荐在不引用变量的时候应用 缺点二 这种定义中如果使用函数，只会在变量被引用时展开，而不是在定义时展开 会使得Make的效率降低，另外有可能会在变量函数的引用会出现非预期结果，特别当变量 定义引用到shell wildcard 函数的情况下，出现不可控的结果 123456x = fooy = $(x) bar //$(x) 不会被立即替换，只有在$(y)被用到的地方才用x的值替换x = later //将会覆盖 原来的 x , 等价于y = later barx = later 2 foo := bar (直接展开式变量) 123456x := fooy := $(x) bar ; 会立即替换成 foo barx := later 等价于y := foo barx := later bar 在复杂的Makefile中，推荐使用立即展开式变量，变量的定义会比较明确 ，也和大多数变成语言中的变量定义使用方法一致。 尽量避免和减少使用第一种递归式变量的使用 定义空格 dir := /foo/bar # directory to put the frobs in 变量“dir”的值是“/foo/bar ”（后面有 4 个空格），这可能并不是想要实现的。如果一个文件以它作为路径来表示“$(dir)/file”，那么大错特错了。 在书写 Makefile 时。推荐将注释书写在独立的行或者多行，防止出现上边例子中 的意外情况，而且将注释书写在独立的行也使得 Makefile 清晰，便于阅读。对于特殊 的定义，比如定义包含一个或者多个空格空格的变量时进行详细地说明和注释。 如果定义个空格变量 12nullstring :=space := $(nullstring) # end of the line 3 foo ?= bar 条件赋值操作符 只有变量之前没有赋值的情况下才会对这个变量赋值，如果之前已经定义了，就不改变原来的值 12345FOO ?= bar其等价于：ifeq ($(origin FOO), undefined) FOO = barendif 4 foo += jar 追加变量值 123456objects = main.o foo.o bar.o utils.oobjects += another.o上边的两个操作之后变量“objects”的值就为：“main.o foo.o bar.o utils.o another.o”。使用“+=”操作符，相当于：objects = main.o foo.o bar.o utils.oobjects := $(objects) another.o 5 define 定义多行变量 1234define two-linesecho fooecho $(bar)endef 6 override 变量 123456override foo = bar override foo := bar override define two-linesfoo$(bar)endef override定义变量是，防止变量的值被命令行指定 变量的高级用法变量的替换引用格式为“$(VAR:A=B)”（或者“${VAR:A=B}”），意思是，替换变量“VAR”中所有“A”字符结尾的字为“B”结尾的字。“结尾”的含义是空格之前（变量值多个字之间使用空格分开）。而对于变量其它部分的“A”字符不进行替换。例如：12foo := a.o b.o c.obar := $(foo:.o=.c) 变量的替换引用其实是函数“patsubst”（参考 8.2 文本处理函数 一节）的一个简化实现所实现功能相同。例如：12foo := a.o b.o c.obar := $(foo:%.o=%.c) 这个例子同样使变量“bar”的值为“a.c b.c c.c”。这种格式的替换引用方式比第一种方式更通用 变量的嵌套引用1234x = $(y)y = zz = Helloa := $($(x)) a的值最后为Hello，嵌套引用往往最后一个变量定义要用立即展开变量定义,有点像C语言的指针 函数","link":"/riscv/20181128_makefile_acc.html"},{"title":"RISCV 编译 Link探究","text":"问题： 如何将代码编译到指定的mem地址？在用$RISCV/bin/riscv64-unknown-elf-gcc hello.c时生成的目标文件默认的都是从0x0000_1000地址开始，如何自定义指定到从0x8000_0000地址开始？那么就得熟悉连接器的原理 默认链接脚本gcc在编译和链接的时候，如果不指定链接脚本，会指向默认的链接脚本默认的链接脚本可以用 $RISCV/bin/riscv64-unknown-elf-ld -verbose 来查看 如何更改链接脚本12345678SECTIONS{ . = 0x8000000; .text : { *(.text) } . = 0x9000000; .data : { *(.data) } .bss : { *(.bss) }} 在编译时指定$RISCV/bin/riscv64-unknown-elf-gcc -T link.lds hello.c -o hello.out默认会报错，没有指定_start 就没有办法分配堆和栈空间12345xxxx/bin/../lib/gcc/riscv64-unknown-elf/8.1.0/../../../../riscv64-unknown-elf/lib/rv64imafdc/lp64d/crt0.o: In function `_start':(.text+0x0): undefined reference to `__global_pointer$'(.text+0x8): undefined reference to `_edata'(.text+0x10): undefined reference to `_end'collect2.exe: error: ld returned 1 exit status 简单起见添加option -nostartfiles 忽略指定_start$RISCV/bin/riscv64-unknown-elf-gcc -T link.lds hello.c -o hello.out -nostartfiles然后$RISCV/bin/riscv64-unknown-elf-objdump -d hello.out &gt; hello.dump可以看到.text 从0x8000000地址开始123456789hello.out: file format elf64-littleriscvDisassembly of section .text:0000000008000000 &lt;main&gt;: 8000000: 1101 addi sp,sp,-32 8000002: ec06 sd ra,24(sp) 8000004: e822 sd s0,16(sp) 8000006: 1000 addi s0,sp,32 完整的参考实例参见hbird-e-sdk是RISCV开源E200系列开发板的sdk https://github.com/SI-RISCV/hbird-e-sdk ./generate_test4sim.csh 生成指定地址的out以及.verilog 二进制可读文件 编译新的case只需make dasm PROGRAM=hellowrold BOARD=hbird-e200 CORE=e203 DOWNLOAD=itcm即可展看来看，实际上执行的是123456789101112make -C software/hello_world \\ SIZE=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-size \\ CC=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-gcc \\ RISCV_ARCH=rv32imac \\ REPLACE_PRINTF=0 \\ NANO_PFLOAT=1 \\ USE_NANO=1 \\ DOWNLOAD=itcm \\ RISCV_ABI=ilp32 \\ AR=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-ar \\ BSP_BASE=/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp \\ BOARD=hbird-e200 \\ 具体执行的是hbird-e-sdk/Makefile下的makefile，具体过程如下：12345678910111213141516171819202122232425262728# cd /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/software/hello_world$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-gcc -O2 -g -march=rv32imac -mabi=ilp32 \\ -ffunction-sections -fdata-sections -fno-common \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/drivers \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/include \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/start.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/entry.o \\ hello_world.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/init.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/close.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/_exit.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/write_hex.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/fstat.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/isatty.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/lseek.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/read.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/sbrk.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/write.o \\ -o hello_world \\ -T /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/link_itcm.lds -nostartfiles \\ -Wl,--gc-sections -Wl,--check-sections --specs=nano.specs -u _printf_float \\ -L/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env \\$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-size hello_world# Leaving /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/software/hello_world 还可以在bsp/env/common.k 中添加一行查看C编译成的hello.s汇编程序文件 1234$(TARGET): $(LINK_OBJS) $(LINK_DEPS) $(CC) $(CFLAGS) $(INCLUDES) $@.c -S #添加该行，可以在对于目录下生成 .s汇编程序 $(CC) $(CFLAGS) $(INCLUDES) $(LINK_OBJS) -o $@ $(LDFLAGS) $(SIZE) $@ 具体link脚本先关细节可见：hbird-e-sdk/bsp/hbird-e200/env/common.mk 文件中 LDFLAGS +=的定义对应脚本 hbird-e-sdk/bsp/hbird-e200/env/link_itcm.lds 下载目标ITCM 链接细节的描述 hbird-e-sdk/bsp/hbird-e200/env/link_flash.lds 下载目标Flash 链接细节的描述 hbird-e-sdk/bsp/hbird-e200/env/link_flashxip.lds 编译好的二进制可读文件在e200的vsim目录下make run_test TESTCASE=$PWD/../riscv-tools/fpga_test4sim/hello4sim/hello_world 即可启动仿真环境 lds 链接脚本的原理介绍完整的文章 链接器把一个或多个输入文件合成一个输出文件.输入文件: 目标文件或链接脚本文件.输出文件: 目标文件或可执行文件. 目标文件(包括可执行文件)具有固定的格式, 在UNIX或GNU/Linux平台下, 一般为ELF格式有时把输入文件内的section称为输入section(input section), 把输出文件内的section称为输出section(output sectin).目标文件的每个section至少包含两个信息: 名字和大小. 大部分section还包含与它相关联的一块数据, 称为section contents(section内容). 一个section可被标记为“loadable(可加载的)”或“allocatable(可分配的)”.loadable section: 在输出文件运行时, 相应的section内容将被载入进程地址空间中.allocatable section: 内容为空的section可被标记为“可分配的”. 在输出文件运行时, 在进程地址空间中空出大小同section指定大小的部分. 某些情况下, 这块内存必须被置零.如果一个section不是“可加载的”或“可分配的”, 那么该section通常包含了调试信息. 可用objdump -h命令查看相关信息.每个“可加载的”或“可分配的”输出section通常包含两个地址: VMA(virtual memory address虚拟内存地址或程序地址空间地址) LMA(load memory address加载内存地址或进程地址空间地址). 通常VMA和LMA是相同的. 在目标文件中, loadable或allocatable的输出section有两种地址: VMA(virtual Memory Address)和LMA(Load Memory Address). VMA是执行输出文件时section所在的地址, 而LMA是加载输出文件时section所在的地址. 一般而言, 某section的VMA == LMA. 但在嵌入式系统中, 经常存在加载地址和执行地址不同的情况: 比如将输出文件加载到开发板的flash中(由LMA指定), 而在运行时将位于flash中的输出文件复制到SDRAM中(由VMA指定).可这样来理解VMA和LMA, 假设: (1) .data section对应的VMA地址是0×08050000, 该section内包含了3个32位全局变量, i、j和k, 分别为1,2,3. (2) .text section内包含由”printf( “j=%d “, j );”程序片段产生的代码. 连接时指定.data section的VMA为0×08050000, 产生的printf指令是将地址为0×08050004处的4字节内容作为一个整数打印出来。如果.data section的LMA为0×08050000，显然结果是j=2如果.data section的LMA为0×08050004，显然结果是j=1还可这样理解LMA:.text section内容的开始处包含如下两条指令(intel i386指令是10字节，每行对应5字节):jmp 0×08048285movl $0×1,%eax如果.text section的LMA为0×08048280, 那么在进程地址空间内0×08048280处为“jmp 0×08048285”指令, 0×08048285处为movl $0×1,%eax指令. 假设某指令跳转到地址0×08048280, 显然它的执行将导致%eax寄存器被赋值为1.如果.text section的LMA为0×08048285, 那么在进程地址空间内0×08048285处为“jmp 0×08048285”指令, 0×0804828a处为movl $0×1,%eax指令. 假设某指令跳转到地址0×08048285, 显然它的执行又跳转到进程地址空间内0×08048285处, 造成死循环.符号(symbol): 每个目标文件都有符号表(SYMBOL TABLE), 包含已定义的符号(对应全局变量和static变量和定义的函数的名字)和未定义符号(未定义的函数的名字和引用但没定义的符号)信息.符号值: 每个符号对应一个地址, 即符号值(这与c程序内变量的值不一样, 某种情况下可以把它看成变量的地址). 可用nm命令查看它们. (nm的使用方法可参考本blog的GNU binutils笔记) 脚本格式链接脚本由一系列命令组成, 每个命令由一个关键字(一般在其后紧跟相关参数)或一条对符号的赋值语句组成. 命令由分号‘;’分隔开.文件名或格式名内如果包含分号’;’或其他分隔符, 则要用引号‘”’将名字全称引用起来. 无法处理含引号的文件名./ /之间的是注释。","link":"/riscv/20181127_riscv_link.html"},{"title":"RISCV GDB debug调试","text":"RISCV-GDB启动步骤 hello.c12345678#include &lt;stdio.h&gt;int main(){ long a = 0x876543210 ; float pi = 3.1415926 ; printf(\"Hello %s!\\n\",\"World\"); a = a*pi; return a ;} 如何生成汇编代码riscv64-unknown-elf-gcc -S hello.c 只会生成汇编代码hello.s 不会生成.out文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC2: .string &quot;World&quot; .align 3.LC3: .string &quot;Hello %s!\\n&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd ra,24(sp) sd s0,16(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) sd a5,-24(s0) lui a5,%hi(.LC1) flw fa5,%lo(.LC1)(a5) fsw fa5,-28(s0) lui a5,%hi(.LC2) addi a1,a5,%lo(.LC2) lui a5,%hi(.LC3) addi a0,a5,%lo(.LC3) call printf ld a5,-24(s0) fcvt.s.l fa4,a5 flw fa5,-28(s0) fmul.s fa5,fa4,fa5 fcvt.l.s a5,fa5,rtz sd a5,-24(s0) ld a5,-24(s0) sext.w a5,a5 mv a0,a5 ld ra,24(sp) ld s0,16(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 .align 2.LC1: .word 1078530010 .ident &quot;GCC: (GNU) 8.1.0&quot; 如何反汇编.out文件首先生成.out文件riscv64-unknown-elf-gcc -o hello.out hello.c 然后反汇编 riscv64-unknown-elf-objdump -d hello.out &gt; hello_disassemble.s 即可查看反汇编代码,搜索main函数如下，当然也包括其他内置函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748hello.out: file format elf64-littleriscvDisassembly of section .text:00000000000100b0 &lt;_start&gt;: 100b0: 0000d197 auipc gp,0xd 100b4: fd818193 addi gp,gp,-40 # 1d088 &lt;__global_pointer$&gt; 100b8: 84818513 addi a0,gp,-1976 # 1c8d0 &lt;_edata&gt; 100bc: 8d818613 addi a2,gp,-1832 # 1c960 &lt;_end&gt; ..... ...000000000001038c &lt;printf&gt;: 1038c: 711d addi sp,sp,-96 1038e: f832 sd a2,48(sp) 10390: fc36 sd a3,56(sp) .... ..0000000000010198 &lt;main&gt;: 10198: 1101 addi sp,sp,-32 1019a: ec06 sd ra,24(sp) 1019c: e822 sd s0,16(sp) 1019e: 1000 addi s0,sp,32 101a0: 67e9 lui a5,0x1a 101a2: a687b783 ld a5,-1432(a5) # 19a68 &lt;__clzdi2+0x54&gt; 101a6: fef43423 sd a5,-24(s0) 101aa: 67e9 lui a5,0x1a 101ac: a707a787 flw fa5,-1424(a5) # 19a70 &lt;__clzdi2+0x5c&gt; 101b0: fef42227 fsw fa5,-28(s0) 101b4: 67e9 lui a5,0x1a 101b6: a5078593 addi a1,a5,-1456 # 19a50 &lt;__clzdi2+0x3c&gt; 101ba: 67e9 lui a5,0x1a 101bc: a5878513 addi a0,a5,-1448 # 19a58 &lt;__clzdi2+0x44&gt; 101c0: 1cc000ef jal ra,1038c &lt;printf&gt; 101c4: fe843783 ld a5,-24(s0) 101c8: d027f753 fcvt.s.l fa4,a5 101cc: fe442787 flw fa5,-28(s0) 101d0: 10f777d3 fmul.s fa5,fa4,fa5 101d4: c02797d3 fcvt.l.s a5,fa5,rtz 101d8: fef43423 sd a5,-24(s0) 101dc: fe843783 ld a5,-24(s0) 101e0: 2781 sext.w a5,a5 101e2: 853e mv a0,a5 101e4: 60e2 ld ra,24(sp) 101e6: 6442 ld s0,16(sp) 101e8: 6105 addi sp,sp,32 101ea: 8082 ret .... ... gdb 查看CPU寄存器-print $x0-p $x0-p $pc-info reg-display $x0 ;每跑一步都会显示寄存器-ni ;next inst","link":"/riscv/20181125_gdb_debug.html"},{"title":"IPC进程通信、消息队列","text":"计算机进程通信原理、IPC、消息队列，常见的方法 共享内存模式 消息传递模式 共享文件模式 主要使用的是前两种方法 多处理器之间通信处理器之间不能通过消息传递模式通信，只能共享内存处理器本身是异步执行的，消息队列没办法实现（接受消息和消耗消息有可能会冲突）而共享内存的方法也有可能会导致冲突，可以为不同处理器划分不同地址空间来避免冲突 单处理器进程通信进程之间的通信最常见最安全的方法就是消息队列。每个进程会维护一个消息队列（常见的是FIFO队列，也有带优先级的队列本文不做讨论） 进程A给进程B发消息，首先获取进程B消息队列（链表）的地址，将消息插入到链表后面。当进程B执行是会去取消息队列最前面的消息然后执行。由于进程A进程B是在同一处理器上占不同的时间片（跟操作系统进程的调度算法有关），同一时刻消息队列不可能即recive 又 consume，所以不存在队列读写冲突的问题。 消息可以是简单的数据编码标志，也可以携带数据（数据起始地址以及长度），或者其他数据结构体格式 scala 的Actor的消息传递也是用此方式实现。","link":"/sicp/ipc_msg_communication.html"},{"title":"RISCV C开发调试笔记","text":"hello.c12345678#include &lt;stdio.h&gt;int main(){ long a = 0x876543210 ; float pi = 3.1415926 ; printf(\"Hello %s!\\n\",\"World\"); a = a*pi; return a ;} 如何指定target编译riscv64-unknown-elf-gcc -c hello.c mylib.c i2c.c 只会编译生成hello.o myprint.o i2c.o ,但不会生成.out可执行文件 12``````mylib.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162````riscv64-unknown-elf-gcc hello.c mylib i2c.c -o hello_exec.out ` 不仅会编译还会链接成最终的可执行文件hello.out链接后的地址从101b0开始### 如何生成汇编代码`riscv64-unknown-elf-gcc -S hello.c` 只会生成汇编代码hello.s 不会生成.out文件```s .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC2: .string &quot;World&quot; .align 3.LC3: .string &quot;Hello %s!\\n&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd ra,24(sp) sd s0,16(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) sd a5,-24(s0) lui a5,%hi(.LC1) flw fa5,%lo(.LC1)(a5) fsw fa5,-28(s0) lui a5,%hi(.LC2) addi a1,a5,%lo(.LC2) lui a5,%hi(.LC3) addi a0,a5,%lo(.LC3) call printf ld a5,-24(s0) fcvt.s.l fa4,a5 flw fa5,-28(s0) fmul.s fa5,fa4,fa5 fcvt.l.s a5,fa5,rtz sd a5,-24(s0) ld a5,-24(s0) sext.w a5,a5 mv a0,a5 ld ra,24(sp) ld s0,16(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 .align 2.LC1: .word 1078530010 .ident &quot;GCC: (GNU) 8.1.0&quot; 如何反汇编.out文件首先生成.out文件riscv64-unknown-elf-gcc -o hello.out hello.c 然后反汇编 riscv64-unknown-elf-objdump -d hello.out &gt; hello_disassemble.s 即可查看反汇编代码,搜索main函数如下，当然也包括其他内置函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748hello.out: file format elf64-littleriscvDisassembly of section .text:00000000000100b0 &lt;_start&gt;: 100b0: 0000d197 auipc gp,0xd 100b4: fd818193 addi gp,gp,-40 # 1d088 &lt;__global_pointer$&gt; 100b8: 84818513 addi a0,gp,-1976 # 1c8d0 &lt;_edata&gt; 100bc: 8d818613 addi a2,gp,-1832 # 1c960 &lt;_end&gt; ..... ...000000000001038c &lt;printf&gt;: 1038c: 711d addi sp,sp,-96 1038e: f832 sd a2,48(sp) 10390: fc36 sd a3,56(sp) .... ..0000000000010198 &lt;main&gt;: 10198: 1101 addi sp,sp,-32 1019a: ec06 sd ra,24(sp) 1019c: e822 sd s0,16(sp) 1019e: 1000 addi s0,sp,32 101a0: 67e9 lui a5,0x1a 101a2: a687b783 ld a5,-1432(a5) # 19a68 &lt;__clzdi2+0x54&gt; 101a6: fef43423 sd a5,-24(s0) 101aa: 67e9 lui a5,0x1a 101ac: a707a787 flw fa5,-1424(a5) # 19a70 &lt;__clzdi2+0x5c&gt; 101b0: fef42227 fsw fa5,-28(s0) 101b4: 67e9 lui a5,0x1a 101b6: a5078593 addi a1,a5,-1456 # 19a50 &lt;__clzdi2+0x3c&gt; 101ba: 67e9 lui a5,0x1a 101bc: a5878513 addi a0,a5,-1448 # 19a58 &lt;__clzdi2+0x44&gt; 101c0: 1cc000ef jal ra,1038c &lt;printf&gt; 101c4: fe843783 ld a5,-24(s0) 101c8: d027f753 fcvt.s.l fa4,a5 101cc: fe442787 flw fa5,-28(s0) 101d0: 10f777d3 fmul.s fa5,fa4,fa5 101d4: c02797d3 fcvt.l.s a5,fa5,rtz 101d8: fef43423 sd a5,-24(s0) 101dc: fe843783 ld a5,-24(s0) 101e0: 2781 sext.w a5,a5 101e2: 853e mv a0,a5 101e4: 60e2 ld ra,24(sp) 101e6: 6442 ld s0,16(sp) 101e8: 6105 addi sp,sp,32 101ea: 8082 ret .... ... 更多信息尝试riscv64-unknown-elf-objdump --help123456789101112131415161718192021Usage: objdump &lt;option(s)&gt; &lt;file(s)&gt; Display information from object &lt;file(s)&gt;. At least one of the following switches must be given: -a, --archive-headers Display archive header information -f, --file-headers Display the contents of the overall file header -h, --[section-]headers Display the contents of the section headers -x, --all-headers Display the contents of all headers -d, --disassemble Display assembler contents of executable sections -D, --disassemble-all Display assembler contents of all sections -s, --full-contents Display the full contents of all sections requested -G, --stabs Display (in raw form) any STABS info in the file.... Display DWARF info in the file -t, --syms Display the contents of the symbol table(s) -T, --dynamic-syms Display the contents of the dynamic symbol table.... The following switches are optional: -b, --target=BFDNAME Specify the target object format as BFDNAME -m, --architecture=MACHINE Specify the target architecture as MACHINE 如何指定target编译riscv64-unknown-elf-rvgcc --target-help显示更多指定目标编译 默认 riscv64-unknown-elf-rvgcc 会生成RV64IMADF，如果你指向生成RV32IM指令集的机器码，如下操作 rvgcc -march=rv32im -mabi=ilp32 -o b_rv32im.out b.c 注意如果用-march=rvxxxx必须要加-mbi=xxxx RISC-V 编译器支持多个 ABI，具体取决于 F 和 D 扩展是否存在。RV32 的 ABI 分别名为 ilp32，ilp32f 和 ilp32d。ilp32 表示 C 语言的整型（int），长整型（long）和指针（pointer）都是 32 位，可选后缀表示如何传递浮点参数。在 lip32 中，浮点参数在整数寄存器中传递；在 ilp32f 中，单精度浮点参数在浮点寄存器中传递；在 ilp32d 中，双精度浮点参数也在浮点寄存器中传递。 自然，如果想在浮点寄存中传递浮点参数，需要相应的浮点 ISA 添加 F 或 D 扩展（见第 5 章）。因此要编译 RV32I 的代码（GCC 选项-march=rv32i），必须使用 ilp32 ABI（GCC选项-mabi=lib32）。反过来，调用约定并不要求浮点指令一定要使用浮点寄存器，因此RV32IFD 与 ilp32，ilp32f 和 ilp32d 都兼容。 对于C代码1234void main(){ int val = 0xf; val++;} gcc 使用rv32im，和默认64位编译的区别如下可以看出32im的指令都是16bit， 而右边指令集有采纳C，有压缩到16bit gdb 查看CPU寄存器RISCV-GDB启动步骤 print $x0 p $x0 p $pc info reg display $x0 ;每跑一步都会显示寄存器 ni ;next inst","link":"/riscv/20181120_riscv_c_dev_setp.html"},{"title":"RISCV 汇编指令调试","text":"RISCV汇编指令调试，立即数使用分析新建文件 test.s 123456.global main.textmain: li a5, 0x12345678 ret riscv.....gcc test.s 编译成汇编代码riscv.....gdb test.s 用调试器运行 进入调试器12345(gdb) disassemble mainDump of assembler code for function _init:0x000000000001019c &lt;+182&gt;: lui a5,0x123450x00000000000101a0 &lt;+186&gt;: addiw a5,a5,16560x00000000000101a4 &lt;+190&gt;: ret 在windows 和Ubuntu上打印的汇编信息由所区别，Windows上会打印额外的很多信息，但是从0x0000000001019c开始的3行信息都是和Ubuntu上一致。一般情况下RISCV程序地址从0x10000开始其余信息可能是一些stdio程序，并不是很清楚 用Spike 调试12345678910111213141516171819202122$: $RISCV/bin/spike -d pk a.out: until pc 0 0x1019c: reg 0 a50x0000000000000002: reg 0 #查看core0 的所有32个寄存器zero: 0x0000000000000000 ra : 0x00000000000100e2 sp : 0x000000007f7e9b50 gp : 0x00000000000123d0 tp : 0x0000000000000000 t0 : 0x00000000000100c8 t1 : 0x0000000000000000 t2 : 0x0000000000000000 s0 : 0x0000000000000000 s1 : 0x0000000000000000 a0 : 0x0000000000000001 a1 : 0x000000007f7e9b58 a2 : 0x0000000000000000 a3 : 0x0000000000000001 a4 : 0x0000000000000010 a5 : 0x0000000000000002 a6 : 0x000000000000001f a7 : 0x0000000000000000 s2 : 0x0000000000000000 s3 : 0x0000000000000000 s4 : 0x0000000000000000 s5 : 0x0000000000000000 s6 : 0x0000000000000000 s7 : 0x0000000000000000 s8 : 0x0000000000000000 s9 : 0x0000000000000000 s10 : 0x0000000000000000 s11 : 0x0000000000000000 t3 : 0x0000000000000000 t4 : 0x0000000000000000 t5 : 0x0000000000000000 t6 : 0x0000000000000000 : help #查看调试命令: run 1 #单步执行core 0: 0x000000000001019c (0x123457b7) lui a5, 0x12345: reg 0 a50x0000000012345000 #可以看到将原来的 0x0000000000000002 覆盖成 0x12345000 ,低12bit覆盖为0: run 1 core 0: 0x00000000000101a0 (0x6787879b) addiw a5, a5, 1656: reg 0 a5 0x0000000012345678 #成功写入 试验12345main: li a5, 0x12345678 li a1, 0xabc li a2, 0x12345 ret 编译后的汇编指令12345678910(gdb) disassemble main Dump of assembler code for function main:0x000000000001019c &lt;+0&gt;: lui a5,0x123450x00000000000101a0 &lt;+4&gt;: addiw a5,a5,16560x00000000000101a4 &lt;+8&gt;: lui a1,0x1 # a1=0x00001000 , 低12bit=0 0x00000000000101a8 &lt;+12&gt;: addiw a1,a1,-1348 # hex(0x1000 - 1348) = 0xabc0x00000000000101ac &lt;+16&gt;: lui a2,0x120x00000000000101b0 &lt;+20&gt;: addiw a2,a2,8370x00000000000101b4 &lt;+24&gt;: retEnd of assembler dump. 即便是小于12bit 的立即数也不能被立即load到,因为LUI指令加载的最小数是0x1000(除了0), 所以所有小于12bit的数val还是要用两条指令完成12LUI rd, 0x1 #load rd 0x1000ADDIW rd, rs, (val-0x1000) C代码编译调试例子11234void main() { int val = 1 ; val+=3 ;} 123456789101112131415161718192021 .file &quot;a.c&quot; .option nopic .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 #sp指针默认从比较大的地址开始，反向增长开辟了32byte的空间 sd s0,24(sp) #将s0的8个字节(64bit)压入栈指针-32+24=-8 addi s0,sp,32 #然后将栈BASE地址放入s0 (s0 被用来当中间寄存器) li a5,1 #加载立即数1到a5 （小于32位的立即数会直接通过立即数指令加载） 否则就需要在内存开辟双字节整形，然后通过ld 加载 sw a5,-20(s0) #给val开辟栈空间，变量都会在栈里面，只有申请内存空间才会在dynamicdata(堆) lw a5,-20(s0) #再读回来 addiw a5,a5,3 #+3 sw a5,-20(s0) #再写回去,(不开优化，每一次操作都会存取) nop ld s0,24(sp) #恢复s0 寄存器 addi sp,sp,32 #恢复栈指针 jr ra #main函数返回 .size main, .-main .ident &quot;GCC: (GNU) 8.1.0&quot; 编译后进gdb调试 a.out123456789101112131415(gdb) disassemble main Dump of assembler code for function main:0x000000000001019c &lt;+0&gt;: addi sp,sp,-320x000000000001019e &lt;+2&gt;: sd s0,24(sp) #表示sp寄存器的内容+立即数偏移240x00000000000101a0 &lt;+4&gt;: addi s0,sp,320x00000000000101a2 &lt;+6&gt;: li a5,10x00000000000101a4 &lt;+8&gt;: sw a5,-20(s0)0x00000000000101a8 &lt;+12&gt;: lw a5,-20(s0)0x00000000000101ac &lt;+16&gt;: addiw a5,a5,10x00000000000101ae &lt;+18&gt;: sw a5,-20(s0)0x00000000000101b2 &lt;+22&gt;: nop0x00000000000101b4 &lt;+24&gt;: ld s0,24(sp)0x00000000000101b6 &lt;+26&gt;: addi sp,sp,320x00000000000101b8 &lt;+28&gt;: retEnd of assembler dump. 定义大于32bit的整数12345long main(){ long val = 0x876543210; //超过32位的长整数 val+=1; return val;} 不开启优化123456789101112131415161718192021222324252627 .file &quot;a.c&quot; .option nopic .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd s0,24(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) #load doubleworld from (.LC0)地址 sd a5,-24(s0) ld a5,-24(s0) addi a5,a5,1 sd a5,-24(s0) ld a5,-24(s0) mv a0,a5 ld s0,24(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 #开辟一块双字节的MEM空间， .ident &quot;GCC: (GNU) 8.1.0&quot; 发现超过32bit的整数，不能通过立即数加载到寄存器（立即数受限于指令的长度最大只能是32bit，而且需要两条指令完成), 只能在内存中开辟一块地址先存放0x876543210,然后ld a5,该地址 例子21234#include &lt;stdio.h&gt;void main(){ printf(\"hello world\");} hello.s 查看汇编代码1234567891011121314151617181920212223242526 .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC0: .string &quot;hello world&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-16 #sp 开辟16byte栈空间 sp=-16 sd ra,8(sp) #将ra的8Byte（64bit)内容从sp=-8处压栈 , 0 ~-8 存ra的值 sd s0,0(sp) #将s0的8Byte（64bit)内容从sp=-16处压栈,-8 ~-16存s0的值 addi s0,sp,16 #将sp=offset0的值存入s0 lui a5,%hi(.LC0) #计算string .LC0的地址，存入a0 addi a0,a5,%lo(.LC0) #这两条指令等价于 伪指令 li &amp;(.LC0) call printf #调用 printf 函数 ,printf 使用a0的内容作为参数 nop ld ra,8(sp) #恢复栈 0~-8 的内容到ra ld s0,0(sp) #恢复栈-8~-16的内容到s0 addi sp,sp,16 #栈指针恢复到0 jr ra #返回ra .size main, .-main .ident &quot;GCC: (GNU) 8.1.0&quot; gdb hell.out 查看汇编以后的机器码123456789101112131415(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: sd s0,0(sp) 0x000000000001019e &lt;+6&gt;: addi s0,sp,16 0x00000000000101a0 &lt;+8&gt;: lui a5,0x1a # (.LC0)的起始地址就是0x19a10 0x00000000000101a2 &lt;+10&gt;: addi a0,a5,-1520 # 0x19a10 0x00000000000101a6 &lt;+14&gt;: jal ra,0x10354 &lt;printf&gt; # pc+4 存入ra, 跳转到pc+0x10354*2的printf函数地址 0x00000000000101aa &lt;+18&gt;: nop 0x00000000000101ac &lt;+20&gt;: ld ra,8(sp) # 恢复ra 0x00000000000101ae &lt;+22&gt;: ld s0,0(sp) # 恢复s0 0x00000000000101b0 &lt;+24&gt;: addi sp,sp,16 # 释放栈 0x00000000000101b2 &lt;+26&gt;: retEnd of assembler dump. print内容稍加修改1234#include &lt;stdio.h&gt;void main(){ printf(\"Hello %s!\\n\",\"World\");} 查看效果1234567891011121314151617(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: sd s0,0(sp) 0x000000000001019e &lt;+6&gt;: addi s0,sp,16 0x00000000000101a0 &lt;+8&gt;: lui a5,0x1a 0x00000000000101a2 &lt;+10&gt;: addi a1,a5,-1504 # 0x19a20 #加载字符串&quot;Hello %s!\\n&quot; 的地址 0x00000000000101a6 &lt;+14&gt;: lui a5,0x1a 0x00000000000101a8 &lt;+16&gt;: addi a0,a5,-1496 # 0x19a28 #加载字符串&quot;Wrold&quot;的地址 0x00000000000101ac &lt;+20&gt;: jal ra,0x1035a &lt;printf&gt; #调用printf, printf会从a0,a1内获取参数 0x00000000000101b0 &lt;+24&gt;: nop 0x00000000000101b2 &lt;+26&gt;: ld ra,8(sp) 0x00000000000101b4 &lt;+28&gt;: ld s0,0(sp) 0x00000000000101b6 &lt;+30&gt;: addi sp,sp,16 0x00000000000101b8 &lt;+32&gt;: retEnd of assembler dump. 字符串的只需要知道起始地址即可，结束位由隐藏的固定格式构成 例31234567#include &lt;stdio.h&gt;int main(){ int a = 2 ; printf(\"Hello %s!\\n\",\"World\"); a++; return a ;} 查看机器码1234567891011121314151617181920212223(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-32 # 开辟32Byte栈空间 0x000000000001019a &lt;+2&gt;: sd ra,24(sp) # 0 ~-8 存ra 0x000000000001019c &lt;+4&gt;: sd s0,16(sp) #-9 ~-16存s0 0x000000000001019e &lt;+6&gt;: addi s0,sp,32 # 栈根给s0 0x00000000000101a0 &lt;+8&gt;: li a5,2 0x00000000000101a2 &lt;+10&gt;: sw a5,-20(s0) # 2存入a5 压栈到-16~-20 0x00000000000101a6 &lt;+14&gt;: lui a5,0x1a # a0 0x00000000000101a8 &lt;+16&gt;: addi a1,a5,-1488 # 0x19a30 #加载字符串&quot;Hello %s!\\n&quot; 的地址到a1 0x00000000000101ac &lt;+20&gt;: lui a5,0x1a 0x00000000000101ae &lt;+22&gt;: addi a0,a5,-1480 # 0x19a38 #加载字符串&quot;World&quot; 的地址到a0 0x00000000000101b2 &lt;+26&gt;: jal ra,0x1036e &lt;printf&gt; 0x00000000000101b6 &lt;+30&gt;: lw a5,-20(s0) #从栈-20 读出32bit=4Byte 出来 0x00000000000101ba &lt;+34&gt;: addiw a5,a5,1 0x00000000000101bc &lt;+36&gt;: sw a5,-20(s0) 0x00000000000101c0 &lt;+40&gt;: lw a5,-20(s0) 0x00000000000101c4 &lt;+44&gt;: mv a0,a5 #a++结果从栈中读出给a0 ,a0 a1 寄存器常用作返回值 0x00000000000101c6 &lt;+46&gt;: ld ra,24(sp) 0x00000000000101c8 &lt;+48&gt;: ld s0,16(sp) 0x00000000000101ca &lt;+50&gt;: addi sp,sp,32 0x00000000000101cc &lt;+52&gt;: ret #返回End of assembler dump. 开启优化选项 -O1234567891011121314(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: lui a1,0x1a 0x00000000000101a0 &lt;+8&gt;: addi a1,a1,-1520 # 0x19a10 0x00000000000101a4 &lt;+12&gt;: lui a0,0x1a 0x00000000000101a8 &lt;+16&gt;: addi a0,a0,-1512 # 0x19a18 0x00000000000101ac &lt;+20&gt;: jal ra,0x10358 &lt;printf&gt; 0x00000000000101b0 &lt;+24&gt;: li a0,3 # 2 + 1 =3 在编译阶段就计算完 0x00000000000101b2 &lt;+26&gt;: ld ra,8(sp) 0x00000000000101b4 &lt;+28&gt;: addi sp,sp,16 0x00000000000101b6 &lt;+30&gt;: retEnd of assembler dump. 总结LUI 指令会讲20比特的立即数放到 寄存器的31:12位置，并且将低12bit覆盖为0 ADDIW 指令会将 rs1 寄存器的值导入到rd 寄存器，并且用立即数[11:0] 覆盖 rd的低12比特 LU是伪指令，因为汇编指令的立即数肯定小于32bit，所以为了实现完整的32bit的立即数load 编译器使用了2条指令LUI,ADDIW 实现了LU的功能 对于一般变量比如int类型，会分配给栈来存放 如果比较大的常数变量，超过32bit或者64bit的数， 地址会分配堆内存给地址 对于数字串分配堆内存地址 参考-RISC-V Reference Card(指令绿卡片) -RISC-V 指令集编码","link":"/riscv/20181116_RISCV_inst_test.html"},{"title":"SBT 版本问题","text":"QA sbt 指向 “java -Dsbt.ivy.home=/nishome/jijing/ivy2 -jar /DATA/jijing/rocket-chip/sbt-launch.jar” 现象ivy2 也是最新的，包含 org.scala-lang#scala-library;2.11.12 正确的版本号 依然会报错！！ 12345[warn] ::::::::::::::::::::::::::::::::::::::::::::::[warn] :: UNRESOLVED DEPENDENCIES ::[warn] ::::::::::::::::::::::::::::::::::::::::::::::[warn] :: org.scala-lang#scala-library;2.11.12: public: unable to get resource for org/scala-lang#scala-library;2.11.12: res=https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.pom: java.net.UnknownHostException: repo1.maven.org: Temporary failure in name resolution[warn] :::::::::::::::::::::::::::::::::::::::::::::: 原因 ~/.sbt 目录可能存在旧的版本，导致问题， 解决 删除 ~/.sbt 目录，如果联网，直接重新sbt run ，会自动下载更新，否则copy 别的机子上正确的 .sbt 到home 目录下。 IDEA，rochi-chip:sync failed ，但在terminal下正常编译 ，也是~/.sbt导致的 C 程序编译好的.out文件不能再 rocket-chip/emulator 目录下运行，而 run-asm-isa-test 则会没有问题 这是由于直接用rvgcc 编译的文件，并没有按照处理器的格式做link，因此想要正确的在处理器上运行，需要正确的link 可以参见 bootrom/link.lds 文件 ： 1234567891011 1 SECTIONS 2 { 3 ROM_BASE = 0x10000; /* ... but actually position independent */ 4 5 . = ROM_BASE; 6 .text.start : { *(.text.start) } 7 . = ROM_BASE + 0x40; 8 .text.hang : { *(.text.hang) } 9 . = ROM_BASE + 0x80;10 .rodata.dtb : { *(.rodata.dtb) }11 } rvgcc -T link.ld bootrom.S -nostdlib -static -wl,--no-gc-section -o bootrom.img 同理C代码编译的时候也需要使用正确的linkfile 文件 。 如何编译指定CPU的可执行文件必要信息： $(CC) 需要默认的target (例如intel x86, AMD64, MIPS 等等， 如果RISCV， 需要支持的指定指令集 (例如 rv32imc rv64g,rv32imdfc 等等) link 脚本，如果不指定，会有导入默认的脚本，否则需要显示指定，尤其是自己设计的处理器，需要显式的指定堆栈起始地址，程序默认存放地址，这些信息响应的也会体现在CPU硬件设计当中。需要正确match 12","link":"/eda/20181130_sy_QA.html"},{"title":"Terminal配置常见问题","text":"Teriminal 配置常见问题 ls后文件名包含引号,例如 'Program file' 在 ~/.zshrc 里面配置 MACOS ls 目录后没有颜色显示， 'alias ls =/bin/ls -G' , 一定要指到/bin/ls 其他","link":"/others/terminal_FAQ.html"},{"title":"综合时序分析回顾","text":"时序分析静态时序分析工具STA，在分析时序的时候会统一从一个点出发开始计算分析（这样才有可行性），往往是从时钟PLL出来以后开始计算 一般情况下都会设一个clock network delay 表示从PLL 到寄存器段clk的群延迟 ，理想情况下，到每个寄存器的群延迟都是一样的（时钟balance） 看一个timing报告： 1234567891011121314151617181920212223242526272829303132333435363738394041**************************************** Startpoint: U_xx/_ram_sp1024x8/srsp_1024x8 (rising edge-triggered flip-flop clocked by clk) Endpoint: U_xx/nS_bit_reg_1_ (rising edge-triggered flip-flop clocked by clk) Path Group: clk Path Type: max Des/Clust/Port Wire Load Model Library ------------------------------------------------ xx_top ZeroWireload tef40ulp128x8hd_ph_ssg0p99v2p25vm40c Point Incr Path -------------------------------------------------------------------------- clock clk (rise edge) 0.0000 0.0000 clock network delay (ideal) 2.0000 2.0000 #时钟群延迟设为2ns xx/srsp_1024x8/CLK (sadr41p1024x8m4b1) 0.0000 2.0000 r #arrival + 2ns xx/srsp_1024x8/Q[0] (sadr41p1024x8m4b) 2.2361 4.2361 f xx/U37/X (SVN_ND2_T_2) 0.0290 4.2651 r xx/U47/X (SVN_ND2_2) 0.0323 4.2974 f .... .. xx/U188/X (SVN_EN2_F_1) 0.0956 4.8690 f xx/nS_bit_reg_1_/D (SVN_FSDPRBQ_D_4) 0.0000 4.8690 f data arrival time 4.8690 clock clk (rise edge) 3.3300 3.3300 #300Mhz = 3.33ns clock network delay (ideal) 2.0000 5.3300 #required + 2 =5.33ns clock uncertainty 0.3000 5.0300 #恶化抖动 xxx/nS_bit_reg_1_/CK (SVN_FSDPRBQ_D_4) 0.0000 5.0300 r library setup time 0.3303 4.6997 #- setup time data required time 4.6997 -------------------------------------------------------------------------- data required time 4.6997 # = clk_arvl_time - Setuptime - skew data arrival time -4.8690 # -------------------------------------------------------------------------- slack (VIOLATED) -0.1693**************************************** Clock Setup Slack = Data Required Time – Data Arrival Time Clock Arrival Time = Latch Edge + Clock Network Delay to Destination Register Data Required = Clock Arrival Time – μtSU – Setup Uncertainty Data Arrival Time = Launch Edge + Clock Network Delay Source Register + μtCO + Register-to-Register Delay","link":"/eda/timing_analysis.html"},{"title":"综合时序分析回顾","text":"关于计算机大小端一般计算机所讲的大小端指的是字节序的大小端，比特序一般默认都是小端无论字节序为大端还是小端 字节序大小端HSB(大端格式):按字节从大到小排布123byte0,byte1,byte2,byte3byte4,byte5,byte6,byte7... LSB(小端格式):按字节从小到大排布123byte3,byte2,byte1,byte0byte7,byte6,byte5,byte4... 比特序大小端bit大端 =[01234567]bit小端 =[76543210]一般常见的都是bit小端","link":"/others/lsb_hsb.html"},{"title":"VCS仿真option","text":"VCS、verdi的命令的配置该Makefile可作为仿真工作脚本，参考了开源处理器蜂鸟e200的仿真环境 https://github.com/SI-RISCV/e200_opensource/blob/master/vsim/bin/run.makefile 1234567891011121314151617181920212223242526272829303132333435363738394041424344RUN_DIR := ${PWD}TESTCASE := 00DUMPWAVE := 1VSRC_DIR := ${RUN_DIR}/../rtlVTB_DIR := ${RUN_DIR}/../tbINC_DIR := ${RUN_DIR}/../rtl/dir_inc_defines1INC_DIR += ${RUN_DIR}/../rtl/dir_inc_defines2# TESTNAME := $(notdir $(patsubst %.dump,%,${TESTCASE}.dump))TESTNAME := case${TESTNAME}TEST_RUNDIR := ${TESTNAME}RTL_V_FILES := $(wildcard ${VSRC_DIR}/*/*.v)TB_V_FILES := $(wildcard ${VTB_DIR}/*.v)# The following portion is depending on the EDA tools you are using, Please add them by yourself according to your EDA vendorsSIM_TOOL := vcs # this is a free solution here to use iverilog to compile the codeSIM_OPTIONS := -sverilog -debug_all +incdir+${INC_DIR} -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log SIM_EXEC := ${RUN_DIR}/simv -l sim.log +notimingcheck +nospecify +loopreport +memcbk +novoptWAV_TOOL := verdi #To-ADD: to add the waveform toolWAV_OPTIONS := -timescale=1ns/100ps +notimingcheck +nospecify #To-ADD: to add the waveform tool options WAV_PFIX := #To-ADD: to add the waveform file postfixall: runcompile.flg: ${RTL_V_FILES} ${TB_V_FILES} @-rm -rf compile.flg ${SIM_TOOL} ${SIM_OPTIONS} ${RTL_V_FILES} ${TB_V_FILES} ; touch compile.flgcompile: compile.flg wave: # gvim -p ${TESTCASE}.spike.log ${TESTCASE}.dump &amp; ${WAV_TOOL} ${WAV_OPTIONS} ${RTL_V_FILES} ${TB_V_FILES} &amp; run: compile rm -rf ${TEST_RUNDIR} mkdir ${TEST_RUNDIR} cd ${TEST_RUNDIR}; ${SIM_EXEC} +DUMPWAVE=${DUMPWAVE} +TESTCASE=${TESTCASE} |&amp; tee ${TESTNAME}.log; cd ${RUN_DIR}; .PHONY: run clean all","link":"/eda/eda_option.html"},{"title":"晶振，PLL, VCO介绍","text":"晶振，vco区别晶振分有源晶振和无源晶振，一般会产生1～200Mhz时钟频率vco亚控振荡器，可以产生比较高的频率比如2Ghz，但是不稳定 为什么既要晶振还要vco？就是为了能够产生稳定的高频时钟信号，就需要用到PLL, PLL内部会有一个VCO 产生高频时钟，通过分频器假设得到10分频的时钟2，再拿这个时钟2和晶振产生的100mhz基用鉴相器做比较，输出一个比较的波形后经过低通滤波，用输出电压控制VCO的输出, 那么就能是vco输出的高频时钟得到稳定的频率，达到了倍频的效果。 20Mhz一下的晶振基本上都是基频的器件，稳定度好，20mhz以上的晶振大多是谐波(如3次，5次谐波)稳定度差，因此强烈建议使用低频的器件，毕竟倍频器用的pll电路需要的周边配置主要是电容，电阻，电感，其稳定度和价格方面要远远浩宇晶体晶振器件。 如果只需要一个20mhz以内的时钟频率，完全可以不用pll，直接接晶振就够了 晶振一般有哪些参数晶振有几个重要参数： 1，晶体元件规格书中所指定的频率，也是工程师在电路设计和元件选购时首要关注的参数。晶振常用标称频率在1～200MHz之间，比如32768Hz、8MHz、12MHz、24MHz、125MHz等，更高的输出频率也常用PLL（锁相环）将低频进行倍频至1GHz以上。我们称之为标称频率。 2，输出信号的频率不可避免会有一定的偏差，我们用频率误差（Frequency Tolerance）或频率稳定度（Frequency Stability），用单位ppm来表示，即百万分之一（parts per million）（1/106），是相对标称频率的变化量，此值越小表示精度越高。比如，12MHz晶振偏差为±20ppm，表示它的频率偏差为12×20Hz=±240Hz，即频率范围是（11999760～12000240Hz） 3，还有一个温度频差（Frequency Stability vs Temp）表示在特定温度范围内，工作频率相对于基准温度时工作频率的允许偏离，它的单位也是ppm。 4，另外，负载电容CL（Load capacitance），它是电路中跨接晶体两端的总的有效电容（不是晶振外接的匹配电容），主要影响负载谐振频率和等效负载谐振电阻，与晶体一起决定振荡器电路的工作频率，通过调整负载电容，就可以将振荡器的工作频率微调到标称值。更准确而言，无源晶体的负载电容是一项非常重要的参数，因为无源晶体属于被动元器件，所谓的被动元器件即是自身不能工作，需要外部元器件协助工作，无源晶体即是！ 其中： CS为晶体两个管脚之间的寄生电容（又名晶振静态电容或Shunt Capacitance），在晶体的规格书上可以找到具体值，一般0.2pF~8pF不等。如图二是某32.768KHz的电气参数，其寄生电容典型值是0.85pF（在表格中采用的是Co）。 CG指的是晶体振荡电路输入管脚到GND的总电容，其容值为以下三个部分的和。 需加外晶振主芯片管脚芯到GND的寄生电容 Ci 晶体震荡电路PCB走线到到GND的寄生电容CPCB 电路上外增加的并联到GND的外匹配电容 CL1CD指的是晶体振荡电路输入管脚到GND的总电容。容值为以下三个部分的和。 需加外晶振主芯片管脚芯到GND的寄生电容, Co 晶体震荡电路PCB走线到到gnd的寄生电容，CPCB 电路上外增加的并联到GND的外匹配电容, CL2 既然晶振的负载电容是一个非常重要的参数，如果此项参数与外部电容匹配不正确会导致什么样的现象？晶振两端的等效电容与晶振标称的负载电容匹配不正确，晶振输出的谐振频率将与标称工作的工作频率会产生一定偏差（又称之为频偏），负载电容（load capacitance）主要影响负载谐振频率和等效负载谐振电阻，它与石英谐振器一起决定振荡器的工作频率，通过调整负载电容，一般可以将振荡器的工作频率调到标称值。应用时我们一般外接电容，便是为了使晶振两端的等效电容等于或接近负载电容，对于要求高的场合还要考虑ic输入端的对地电容，这样便可以使得晶振工作的频率达到标称频率。所以合理匹配合适的外加电容使晶振两端的等效电容等于或接近负载电容显得十分重要。 负载电容常用的标准值有12.5 pF，16 pF，20 pF，30pF,负载电容和谐振频率之间的关系不是线性的，负载电容变小时，频率偏差量变大；负载电容提高时，频率偏差减小。图3是一个晶体的负载电容和频率的误差的关系图。 例外情况： 现在有很多芯片内部已经增加了补偿电容（internal capacitance），所以在设计的时候，只需要选按照芯片datasheet推荐的负载电容值的选择晶体即可，不需要额外再加电容。但是因为实际设计的寄生电路的不确定性，最好还是预留CL1/CL2的位置。","link":"/others/crystals-pll-vco.html"},{"title":"Verilog仿真不打拍分析","text":"现象例如：出现： 原因这是由于采样的时钟tx_gen_symbol_clk 和数据信号subframe_start之间存在竞争关系导致的。我们的设计意图是时钟tx_gen_symbol_clk应该采到subframe_start信号的后沿有人可能会说在代码中加入延迟#1来解决，实际上不推荐这样做，还会存在两个#1的信号同样还会存在竞争。 仿真模型原理分析要搞清楚产生这种问题的原因首先要了解仿真器对于时序仿真的模型。第4级的时钟不能正常采到第3级输出的数据，但是第2级的时钟能采到第二级时钟打出来的数据（D3），原因就是，仿真器会在寄存器输出的时候添加一个虚拟的延迟δ，虽然这个虚拟延迟我们是看不到的，在仿真器上都是0，但是对于仿真器工作的时候，到遇到always采样事件时先要判断这个δ延迟，决定触发器的采样输出。（当延迟相等时，clk延迟的优先级会比data延迟的优先级高，即clk1能采到D1的前沿， 也就是我们看到的数据不打拍，这跟我们的预期是不一致的，而clk1能采不到D2的前沿，但能采到D2的后沿，这跟我们的预期一样的。这些讨论仅限于前仿，实际器件上我们必须有时序约束来保证建立保持时间，也不会存在这样的问题。但是硬件设计就是要保证仿真和物理器件一致。因此我们要注意这个现象。 如何解决 在你的TB里时钟都由一个单独的模块产生送给DUT，不管产生多少个时钟，这些时钟保证都经历了n级分频下来的然后送入DUT，这样数据就不会出现不delay的现象。","link":"/eda/verilog_simu_0delay.html"}],"tags":[{"name":"Chisel","slug":"Chisel","link":"/tags/Chisel/"},{"name":"verilog","slug":"verilog","link":"/tags/verilog/"},{"name":"firrtl","slug":"firrtl","link":"/tags/firrtl/"},{"name":"riscv","slug":"riscv","link":"/tags/riscv/"},{"name":"make","slug":"make","link":"/tags/make/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"开发环境","slug":"开发环境","link":"/tags/开发环境/"},{"name":"verctor","slug":"verctor","link":"/tags/verctor/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/函数式编程/"},{"name":"scala","slug":"scala","link":"/tags/scala/"},{"name":"计算机","slug":"计算机","link":"/tags/计算机/"}],"categories":[{"name":"chisel","slug":"chisel","link":"/categories/chisel/"},{"name":"others","slug":"others","link":"/categories/others/"},{"name":"riscv","slug":"riscv","link":"/categories/riscv/"},{"name":"sicp","slug":"sicp","link":"/categories/sicp/"},{"name":"scala","slug":"scala","link":"/categories/scala/"},{"name":"eda","slug":"eda","link":"/categories/eda/"}]}