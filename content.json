{"pages":[{"title":"","text":"","link":"/about/index.html"},{"title":"","text":"RISCV SCALA Chisel EDA","link":"/topic/index.html"},{"title":"","text":"SpinalHDL开发 2020-07-30: SpinalHDL(九):不变应万变-Mem接口适配 2020-05-16: SpinalHDL(八):开发仿真测试一条龙 2020-01-25: Scala单例模式的几个有趣的应用 2020-01-01: Spinal-BootCamp 2020-12-05: SpinalHDL(七):逢山开路-寄存器接口 2019-11-14: SpinalHDL(六):定点化-饱和截位 2019-11-04: SpinalHDL(五):时钟和时钟域 2019-10-31: SpinalHDL(四):一窥总线四两拨千斤 2019-10-22: SpinalHDL(三):一行代码生成SOC 2019-10-20: SpinalHDL(一):此CHISEL非彼Chisel 2019-10-28: SpinalHDL参数化设计 Scala相关 2019-11-21: Scala3 Macro系统Tasty进展 2020-07-22: Scala泛型","link":"/spinalhdl/index.html"},{"title":"","text":"SpinalHDL开发 2020-07-30: SpinalHDL(九):不变应万变-Mem接口适配 2020-05-16: SpinalHDL(八):开发仿真测试一条龙 2020-01-25: Scala单例模式的几个有趣的应用 2020-01-01: Spinal-BootCamp 在线新手教程 2020-12-05: SpinalHDL(七):逢山开路-寄存器接口 2019-11-14: SpinalHDL(六):定点化-饱和截位 2019-11-04: SpinalHDL(五):时钟和时钟域 2019-10-31: SpinalHDL(四):一窥总线四两拨千斤 2019-10-22: SpinalHDL(三):一行代码生成SOC 2019-10-20: SpinalHDL(一):此CHISEL非彼Chisel 2019-10-28: SpinalHDL参数化设计 Lambda演算python实现 2019-04-19: lambda演算python实现.(二)之数字和运算 2019-04-19: lambda演算python实现.(三)之Bool值和逻辑运算 函数式编程 2019-10-25: Lisp之根 2019-04-29: CPS变化/尾调用/尾递归 2019-04-21: 为什么要FP 2019-04-11: Python lambda Y组合子(Y算子)实现 Scala 笔记 2019-03-08: SCALA 程序初探.一(main函数) 2019-03-08: SCALA 程序初探.二(package组织方式) 2019-03-08: SCALA 程序初探.三(sbt组织scala代码1) 2019-03-08: SCALA 程序初探.四(sbt组织scala代码2) 2019-11-21: Scala3 Macro系统Tasty进展 RISCV 开发调试 2018-11-28: IDEA scala chisel环境配置 2018-11-28: Makefile使用笔记 2018-11-27: RISC-V 编译链接脚本 2018-11-20: RISC-V C代码编译调试笔记 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-15: RISCV-Vector介绍 2019-04-28: C函数调用汇编代码分析 Chisel 笔记 2018-12-05: Chisel 示例问题汇总 2019-03-21: chisel 组合逻辑，时序逻辑写法 2019-04-01: chisel Keep变量名 2019-04-11: chisel 版本问题 2019-03-20: Chisel-Verilog 查找表优先级问题讨论 EDA工具 如何从shell中传递变量给verilog文件 EDA仿真环境Makefile配置(vcs,verdi) 时序分析回顾 Moudle名冲突解决办法 仿真不打拍 通信 AGC调整 想法 为什么”简单”如此复杂 其他 Terminal Shell 常见配置问题 RISCV ISA todo list Markdown 使用手册 晶振,PLL,VCO初识 计算机大小端详解 进程通信，消息队列","link":"/main/index.html"}],"posts":[{"title":"索引置顶","text":"SpinalHDL开发 2020-07-30: SpinalHDL(九):不变应万变-Mem接口适配 2020-05-16: SpinalHDL(八):开发仿真测试一条龙 2020-01-25: Scala单例模式的几个有趣的应用 2020-01-01: Spinal-BootCamp 2020-12-05: SpinalHDL(七):逢山开路-寄存器接口 2019-11-14: SpinalHDL(六):定点化-饱和截位 2019-11-04: SpinalHDL(五):时钟和时钟域 2019-10-31: SpinalHDL(四):一窥总线四两拨千斤 2019-10-22: SpinalHDL(三):一行代码生成SOC 2019-10-20: SpinalHDL(一):此CHISEL非彼Chisel 2019-10-28: SpinalHDL参数化设计 Lambda演算python实现 2019-04-19: lambda演算python实现.(二)之数字和运算 2019-04-19: lambda演算python实现.(三)之Bool值和逻辑运算 函数式编程 2019-10-25: Lisp之根 2019-04-29: CPS变化/尾调用/尾递归 2019-04-21: 为什么要FP 2019-04-11: Python lambda Y组合子(Y算子)实现 Scala 笔记 2019-03-08: SCALA 程序初探.一(main函数) 2019-03-08: SCALA 程序初探.二(package组织方式) 2019-03-08: SCALA 程序初探.三(sbt组织scala代码1) 2019-03-08: SCALA 程序初探.四(sbt组织scala代码2) 2019-11-21: Scala3 Macro系统Tasty进展 RISCV 开发调试 2018-11-28: IDEA scala chisel环境配置 2018-11-28: Makefile使用笔记 2018-11-27: RISC-V 编译链接脚本 2018-11-20: RISC-V C代码编译调试笔记 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-15: RISCV-Vector介绍 2019-04-28: C函数调用汇编代码分析 Chisel 笔记 2018-12-05: Chisel 示例问题汇总 2019-03-21: chisel 组合逻辑，时序逻辑写法 2019-04-01: chisel Keep变量名 2019-04-11: chisel 版本问题 2019-03-20: Chisel-Verilog 查找表优先级问题讨论 EDA工具 如何从shell中传递变量给verilog文件 EDA仿真环境Makefile配置(vcs,verdi) 时序分析回顾 Moudle名冲突解决办法 仿真不打拍 通信 AGC调整 想法 为什么“简单”如此复杂 其他 Terminal Shell 常见配置问题 RISCV ISA todo list Markdown 使用手册 晶振,PLL,VCO初识 计算机大小端详解 进程通信，消息队列 revealjs导出PDF","link":"/top-index.html"},{"title":"SpinalHDL(九):不变应万变-MemWrap适配","text":"对于IC开发工程师我们可能都有这样的痛苦经历，经常需要手动为不同工艺库替换Mem。有些团队的MemWrapper可能是有专门的脚本来生成，内部会用宏来区分不同工艺，相对来说还比较省事一点，即便这样MemWrpper的集成也是需要你手动连线。但是如果你是IP提供商，不同的团队或者公司的MemWrapper的信号命名也各不相同。同样替换Mem是一件极其无聊并且容易出错的事情。 另外我发现SpinalHDL自带的mem类型并不适合直接拿来做例化，所以需要为此创建一个新的解决方案来满足IC设计中这种常见的需求。spinal的mem模型我会放到Blackbox内部做为行为模型，这样在仿真的时候你可以clearBox来使用mem参考模型来仿真，不需要真正的去包含一个memwrap.v文件，这样在前期设计中非常方便。 因此对于设计者来讲，我本来只需要关心这地方例化的Mem类型（双口，真双口，单口），数据位宽，mem深度即可。除此之外工艺相关的事情对设计者应该是透明的。 可以总结为两点诉求 MemWrap替换不应修改HDL代码， 对开发者透明 添加新的Vendor memWrap不应修改Spinal源码，保持前向兼容 因此，对于开发者来讲，只需要知道统一的RAM例化接口，为此为Spinal设计常见的3种MEM类型.1234567891011121314151617181920212223242526272829303132333435363738394041424344case class Ram1rw(mc: MemConfig, memName: String = \"\") extends Component with MemWrap{ val io = new Bundle{ val cs, wr = in Bool() val bwe = mc.genBWE() val addr = in UInt(mc.aw bits) val wdata = in Bits(mc.dw bits) val rdata = out Bits(mc.dw bits) } noIoPrefix() val ram = mc.vendor.build(this)}case class Ram1rw(mc: MemConfig, memName: String = \"\") extends Component with MemWrap{ val io = new Bundle{ val cs, wr = in Bool() val bwe = mc.genBWE() val addr = in UInt(mc.aw bits) val wdata = in Bits(mc.dw bits) val rdata = out Bits(mc.dw bits) } noIoPrefix() val ram = mc.vendor.build(this)}case class Ram2rw(mc: MemConfig, memName: String = \"\") extends Component with MemWrap{ val io = new Bundle{ val Aclk = in Bool() val Awr, Acs = in Bool() val Abwe = mc.genBWE val Aaddr = in UInt() val Awdata = in Bits() val Ardata = out Bits() val Bclk = in Bool() val Bwr, Bcs = in Bool() val Bbwe = mc.genBWE val Baddr = in UInt() val Bwdata = in Bits() val Brdata = out Bits() } noIoPrefix() val ram = mc.vendor.build(this)} 开发者仅需要关心Ram1rw、Ram1r1w、Ram2rw的例化和集成即可。而它们和Vendor生成的MemWrapper的库的例化连接则应当自动完成。仔细看上面的代码不难发现其中mc.vendor.build(this) 实际上就是通过类似于回调函数的方式来执行vendor的build函数，build函数则完成当前wrap和MemWrapper的连接。 1234567891011121314151617181920212223trait Vendor {//默认使用umc的wrapper def build(mw: Ram1rw): MemBlackBox = new umc.mbb1rw(mw).Build() def build(mw: Ram1r1w): MemBlackBox = new umc.mbb1r1w(mw).Build() def build(mw: Ram2rw): MemBlackBox = new umc.mbb2rw(mw).Build() def build(mw: Rom): MemBlackBox = new umc.mbbrom(mw).Build()}case object Intel extends Vendor{ override def build(mw: Ram1rw): MemBlackBox = new intel.mbb1rw(mw).Build() override def build(mw: Ram1r1w): MemBlackBox = new intel.mbb1r1w(mw).Build() override def build(mw: Ram2rw): MemBlackBox = new intel.mbb2rw(mw).Build() override def build(mw: Rom): MemBlackBox = new intel.mbbrom(mw).Build()}//对于不同的公司不同的工艺可以定义不同的Wrapper，前提extends Vendorcase object SPRD extends Vendor{...}case object FishSemi extends Vendor{...}case object AMD extends Vendor{...}case object HuaWei extends Vendor{...}case object HuaWei10nm extends Vendor{...}case object ZTE extends Vendor{...}case object Invida extends Vendor{...}.... 其中build接受不同的参数，这是一个典型设计模式之生成器模式（The builder design pattern），对于Scala来说是非常简单自然，无需额外操作。不同的参数调用不同的vendor.memblackbox实现，比如我们来看下UMC 单口mem wrap的具体实现，我们需要将公共的wrap作为参数传递给厂商的wrapper，厂商的wrapper将自己的信号跟公共的wrap通过创建Build()函数来明确指出连接关系。这点非常重要，只有这样才能保持向后的扩展性，因为spinal不会也不可能把所有厂家的wrapper给你创建好, 也办不到，自己厂家的wrapper也有可能不断的在变化，唯一不变的是公共wrap的信号命名，所以只需要创建Build（）函数高速连接关系，设计者在例化RAM对象的时候只需要高速Vendor的名称即可。 1234567891011121314151617181920212223242526272829303132333435package memlib.vendors.umcclass mbb1rw(wrap: Ram1rw) extends MemBlackBox{ this.setDefinitionName(s\"Mwrapper_rfsp${mc.depth}x${mc.dw}m2b1w1\") val io = new Bundle { iobd =&gt; val CLK = in Bool val A = in UInt(mc.aw bits) val D = in Bits(mc.dw bits) val CEN = in Bool() val WEN = in Bool() val BWEN = mc.genBWE val Q = out Bits(mc.dw bits) } val cd = ClockDomain(io.CLK) def Build(): MemBlackBox = { wrap.clockDomain.setSyncWith(cd) this.io.CLK := wrap.clockDomain.readClockWire this.io.A := wrap.io.addr this.io.CEN := ~wrap.io.cs this.io.WEN := ~wrap.io.wr if(mc.needBWE){ this.io.BWEN := ~wrap.io.bwe } this.io.D := wrap.io.wdata wrap.io.rdata := this.io.Q if(mc.withBist) {wrap.io.bist &gt;&gt; io.bist} if(mc.withScan) {wrap.io.scan &gt;&gt; io.scan} this } noIoPrefix() ....} 实际例化 传入Vendor信息， Vendor也可以放到全局配置，这样当我们的IP更换不同的vendor是只需要修改配置，不需要修改HDL代码 1234567class CacheCell(c: GnssConfig, name: String = \"\") extends Component{ val io = new Bundle{ val rp = slave(rdPort(c.caw, IQ(c.dw))) val wp = slave(wrPort(c.caw, IQ(c.dw)))}val ram = Ram1rw(MemConfig(dw = 32, depth =512, vendor = HuaWei10nm)ram &lt;&lt; (io.rp merge io.wp) 除了Mem之外，还有一些公共的cell，比如clkgate, clkmux, asyncCell, clkdiv 等等，RTL代码中会显示的例化， 不同的公司或者团队使用的wrapper名称也各不相同，当项目切换时，使用不同的工艺或者lib时，通常在cell-wrapper中通过宏来选择不同的lib。对于IP提供商来说，cell-wrapper的耦合例化，不同公司集成时，可能需要专门的的按照原来的wrapper Name来创建一套wrapper库。总之都是不够优雅。 123gate_cell u_deR_cg_cell(.CLK(clk), .TSE(test_mode), .E(deR_gate_en), .ECK(deR_clk));gate_cell u_deC_cg_cell(.CLK(clk), .TSE(test_mode), .E(deC_gate_en), .ECK(deC_clk));gate_cell u_deI_cg_cell(.CLK(clk), .TSE(test_mode), .E(deI_gate_en), .ECK(deI_clk)); 优雅的解决方案是同上面的mem_wrapper 思路一致，HDL代码接受不同的Vendor作为参数来例化不同的wrapper。不管是项目切换还是工艺切换，只需要修改顶层配置的Vendor对象即可。不用修改任何HDL代码。 123456789class clkGate(vendor: Vendor) extends Component{ //创建接口模块 val io = new Bundle{ val clk = in Bool() val tse = in Bool() val cgen = in Bool() val cgclk = out Bool() } vendor.Build(this)} SpinalHDL来写HDL时，对于clockgate这种cell的例化并不会像Verilog那样去做，那样会显得非常啰嗦，一个简单的方式就是val newcd = this.clockDomian.gateBy(io.clken) 因此我们需要位clockDomian隐式扩展添加方法 gateBy ，具体的例化在函数内部完成。 12345678910111213implicit class ClockGateExtend(cd: ClockDomain){ def gateBy(en: Bool, tse: Bool): ClockDomain = { val cg = new gate_cell(globalData.getVendor) cg.io.clk:= cd.readClockWire cg.io.tse:= tse cg.io.cgen := en val cde = ClockDomain(clock = cg.io.cgclk, reset = cd.readResetWire ) cde.setSynchronousWith(cd) //gate后的时钟和原时钟应该是同步关系 cde } } 分频cell, 异步cell都可以用以上方式来实现，对于RTL工程师不需要关心具体例化，只需要在全局定义Vendor对象，或者在IP顶层的配置中定义Vendor对象，例如对于模块Gnss的配置参数，仅仅修改vendor的对象就可以替换所有的底层lib或者mem-lib。 12345678910111213case class GnssConfig(diQ: QFormat = SQ(2, 1), ddc_diQ: QFormat = SQ(3,2), ddc_doQ: QFormat = SQ(5,4), corr_dow: Int = 16, coh_dow: Int = 10, noncoh_dow: Int = 16, baseAddress: Long = 0x00000, vendor: Vendor = FishSemi, //定义Vendor withScan: Boolean = false, withBist: Boolean = false ){....} vendor对象应该考虑将其放置到SpinalConfig中去，这样的好处是一些commonCell的例化时vendor参数可以通过globalData获取，避免手工例化。","link":"/spinal/spinal9.html"},{"title":"SpinalHDL(八):开发仿真测试一条龙","text":"鉴于被chisel的peek poke test愚弄以后，我一度对Scala上的仿真环境不是特别有信心，当看到spinal.sim的时候觉得可能只是一个能work的demo而已，并没有足够重视。 我用Spinal开发的前几个模块依然走的传统的验证流程，先生成Verilog，然后再用scala生成激励，最后打包丢到Linux服务器上, 用Verilog/SV编写tesbech， 搭建测试比对环境，仿真工具不是VCS就是NcSim这些老牌商业软件。 直到一个偶然的机会，有一些很零碎的模块需要测试，不想再为此搭建一整套仿真环境，我想干脆用spinal.sim 简单做个测试，不测不知道，一测一发不可收拾。 SpinalHDL就是这样的汉子，一次又一次的轻视它，但它又不时的给你惊喜。 不同于iotest的peak poke， 它的后台是verilator, verilator非常强大，性能比起商业软件VCS、NC毫不逊色。 spinal.sim 通过包装verilator提供的VPI，能够很方便灵活，实时的跟dut交互通信, 加上Scala本身语言的灵活性，它能做的不比UVM少。 今年chisel貌似后知后觉的回过神了，摒弃iotest，重新设计iotester2, iotester2和spinal.sim的思路很类似了, 后台是verilator, 有兴趣的可以自己试试 接下来我主要借助通信基带的两个模块来介绍一些如何使用SpinalHDL进行仿真测试，以及如何构建组织管理回归你的测试CASE。 对于spinal.sim的基础操作和使用请浏览官方文档Spinal-sim，这里不再赘述。 一：简单的数字混频器数字下混频模块的顶层如下，有相位步长，相位初始值，输入输出数据123456789class FreqMixer(cfg: FreqMixerConfig) extends Component{ val io = new Bundle{ val init = in Bool() val thetaStep = in SInt(cfg.thetaStepQ.width bits) val thetaInit = in SInt(cfg.thetaAccQ.width bits) val din = slave Flow(IQ(cfg.diQ.width)) val dout = master(Flow(IQ(cfg.doQ.width))) }} 起初你可能像verilog一样一个一个配置参数和灌入激励 1234567891011121314151617181920212223242526272829303132.compile(new FreqMixer(cfg, true)).doSimUntilVoid(\"freqmixSim\"){ dut =&gt; dut.clockDomain.forkStimulus(5) //添加时钟激励,时钟周期为5ns dut.io.din.valid #= false dut.io.thetaStep #= thetaStep.fixAsLong(cfg.thetaStepQ)//设置频偏步长 dut.io.thetaInit #= thetaInit.fixAsLong(cfg.thetaAccQ) //设置相位初始值 sleep(100) dut.clockDomain.waitSampling() fork {//fork灌入进程 for(x &lt;- source){//将激励one by one灌入 dut.io.din.payload.I #= x.re.toLong dut.io.din.payload.Q #= x.im.toLong dut.io.din.valid #= true dut.clockDomain.waitSampling() } sleep(100) simSuccess() //仿真结束 } fork {//fork读取比对进程 while(true){ sleep(1) if(dut.io.dout.valid.toBoolean){ val res = dut.io.dout.payload.toLong val ref = refs.dequeue //计分板实时取数 dut.clockDomain.waitSampling() assert(res == ref.fixAsLong(cfg.doQ)) //实时数据比对 } } }} 对于一个功能单一比较小的模块这样可能也能凑合应付，但是对于一个复杂的测试场景复杂的模块顶层，一个一个的去灌入激励，就会变的非常麻烦。我们完全可以将其抽象成4个独立的操作步骤，这些步骤可以串行，也可以通过fork join并行。 1234567.compile(new FreqMixer(cfg, true)).doSimUntilVoid(\"freqmixSim\"){ dut =&gt; dut.init() // 初始化 包括端口信号初始化，添加时钟激励 dut.forcePara(thetaStep, thetaInit) //配置参数 dut.forkData(source) dut.forkCompare()} 新的tb看上去就简洁多了，不光简洁，这些独立出来的函数可以更方便的复用和组合成测试激励。有人可能好奇，这些组合的函数放到哪儿去了？实际你可以把它放到top模块下面，它并不产生电路，所以不用担心。 123456789class FreqMixer(cfg: FreqMixerConfig) extends Component{ val io = new Bundle{ .... } def init() .... def forcePara(thetaStep： Long, thetaInit: Long) .... def forckData(source) .... def frokCompare().....} 对于习惯了verilog开发的人，喜欢保持顶层干净，不希望将HDL代码中加入其它非逻辑代码，那么你也可以为FreqMixer专门继承出一个TB类型，将测试相关的代码放入TB，这样在保证能够访问顶层的所有变量方法以外完全不影响顶层模块的代码。 class FreqMixer(cfg: FreqMixerConfig) extends Component{ val io = new Bundle{ .... } .... } class FreqMixerTB(cfg: FreqMixerConfig) extends FreqMixer(cfg){//简单继承即可 //这样FreqMixer内的接口和变量完全可见 def init(){ clockDomain.forkStimulus(5) //clockDomain可见 io.din.valid #= false //io 可见 } def forcePara(thetaStep： Long, thetaInit: Long){ io.thetaStep #= thetaStep //配置相位步长 io.thetaInit #= thetaInit //配置相位初始值 } def forkData(source) .... def forkCompare()..... } 我们知道对于一个直流信号，添加一个频偏相当于就添加了一个正弦波分量。我们试试以下代码。 dut.forcePara((2*Pi/40).fixAsLong(SQ(32,28), 0)//设置2Pi/40的,相当于一个正玄波周期40个样点 dut.forkData(List.fill(1000)(0.5+0*j).fixAsLong(SQ(8,7))) //灌入直流，SQ(8,7)量化 当给dut灌入直流，输出出现完美的正弦波我们再做点好玩的事情，给输入信号添加一些高斯白噪声。 val source = List.fill(1000)(0.5+0*j) val sourceWithNoise = AWGN(source, snr = 3) //添加一组信噪比为3dB的高斯白噪声 dut.forkData(soureWithNoise.fixAsLong) dut.forcePara((2*Pi/200).fixAsLong(SQ(32,28), 0)//同时把周期设大一点 当我们把snr设置到-3db是，2倍的噪声已经对信号造成严重的变形 val sourceWithNoise = AWGN(source, snr = -3) //信噪比设为 -3dB 当然我们还可以调整接受机输入的功率以便放到合适的AD范围内，一般蜂窝通信的AD功率增益会调整到-9 ~-12dB左右， 而像GPS接收机位宽比较低，可能只有2bit，会强制饱和30%，把它调到1.549db以便获得最佳效果 val sourceWithNoise = GainTo(AWGN(source, snr = -3), -9) //信噪比-3dB，功率增益调到 -9dB 用2bit不太容易看出来，用一个8bit，把增益控制在1.549db,可以看出明显的饱和截断给一个输入信号加点噪声用analog显示，本身并没有什么实际意义，但是通过这个演示我想说明的，通过简单的几行像伪代码一样的代码可以及时的反应到DUT上，这在以前是不可想象的，传统的IC开发流程里面，需要算法组帮你生成激励，硬件设计人员很难自己构造功能性的case。现在scala平台上你可以将复杂的参考设计和硬件设计完美结合，实时仿真，形成闭环。我最近在做BD/GPS双模基带开发，所有的硬件代码，Golden参考模型，测试向量全部都在Scala平台上完成，可以很方便的构造各种case，比如一次发多颗星，一次跟踪不同的卫星，每颗卫星的信噪比，频偏，码相位构造都能够方便配置。往常对于一些稍微特殊的需求或者case，你需要协调算法同事帮你产生，算法平台的侧重点可能更多的关注性能极限仿真，所以有些对算法平台来说并不是非常方便，同时组间的需求响应周期也比较大。这时候你有scala写的参考平台（这个会跟算法对齐），这些任务可以快速闭环的在自己的平台上完成。 添加总线读写函数我们开发的模块经常会有AHB, 或者APB总线接口作为寄存器配置接口，一般情况下自测的时候不会为了配置参数再去给他添加一个VIP，但是你直接操作dut上总线接口的信号，那显然非常的啰嗦，如果能在端口上直接 dut.write(0x02, 0x32322)操作那就方便多了 class GPSTop extends Component{ val io = new Bundle{ ... val ahb = AHBLite3(AHBLite3Config(32,32)) } } 不过我找了一下spinal.sim, 目前并没有这样的函数，如果你不想麻烦作者立马给你加上，或者自己暂时也不想动spinal的源码，你完全可以在本地通过隐式扩展，悄悄的给已有的class扩展方法。如果这些方法足够通用，并且在你本地经过充分的验证，你也可以给spinal提个PR merge 到合适的地方去。 implicit class AhbLite3Extends(ahb: AhbLite3){ //给AHBlite3隐式扩展simWrite, simReda方法 import spinal.core._ import spinal.core.sim._ def simWrite(addr: Long, data: BigInt)(cd: ClockDomain) = { cd.waitSampling()// 等待时钟沿 ahb.HSEL #= true ahb.HWRITE #= true ahb.HREADY #= true ahb.HADDR #= addr ahb.HTRANS #= 2 cd.waitSampling()// 等待时钟沿 ahb.HWDATA #= data while(!ahb.HREADYOUT.toBoolean){cd.waitSampling()} //握手等待 } def simRead(addr: Long)(cd: ClockDomain): BigInt = { cd.waitSampling() // 等待时钟沿 ahb.HSEL #= true ahb.HWRITE #= false ahb.HREADY #= true ahb.HADDR #= addr ahb.HTRANS #= 2 cd.waitSampling()// 等待时钟沿 while(!ahb.HREADYOUT.toBoolean){cd.waitSampling()}// 握手等待 sleep(0) ahb.HRDATA.toLong } } 然后在顶层模块集成来的TB里添加write， read 方法，还可以进一步的包装，此时你可以像写C语言一样对你的模块进行配置。 class GPSTopTB extends GPSTOP{ def write(addr: BigInt, data: BigInt) = io.ahb.simWrite(addr, data)(this.clockDomain) def read(addr: BigInt): BigInt = io.ahb.simRead(addr)(this.clockDomain) def forceGPSPara(cs: GPSCase) = { //可以进一步封装寄存器配置函数 write(0x00, cs.para.modes) write(0x04, cs.para.parameter0) write(0x08, cs.para.parameter0) write(0x0c, cs.para.intEnables) ....... write(0x40, cs.para.....) } } 二：验证CASE规划测试回归传统的IC开发流程中，由测试case都输出统计到一个文档，一般是excel表格。我们不光需要维护表格，还要维护生成的激励，以及验证环境，这些东西分散在不同的地方,而且有些case或者仿真环境也不一定纳入版本控制。 所以我们经常有这样的遭遇，对于已开发完成的一个IP，一年半载以后你要重新把它跑起来，有时候不得不重新调试环境，有时候找不到case，有些case文件很大，时间长了会把它清理掉，这时候你需要重新找算法帮你生成，反正把原有得模块跑起来有时候会是一件比较费事的事情，所以如果有一种办法能够清晰的管理并维护验证CASE，并且能够不受时间，不受平台限制，在任何时刻能够快速回归浮现，对IC开发人员是一件非常享受的事情。 验证case分为两类 一类是交互类，异常的测试， 还有一类是算法功能测试，由算法来生成向量集 交互异常测试，不过目前我会把它交给验证人员去仔细的敲打, 他们可能更专业。在scala上做UVM那样的事情也完全具备条件。SpinalSIM也没准备要替代传统的验证Flow，不管开发自测多模充分，我们还是会让验证去做最后的把关。 但是功能性的case，验证人员对你的功能case的构造并不一定特别清楚，我们再指定验证规划的时候这类case往往由设计和算法来一起出，所以这类case设计人员更为清楚，让设计评估测试更为合适, 如果我们在前期经过充分的功能性测试，在交付软件的时候比较稳定收敛，这也会直接加速验证的总体收敛进度，进而加快项目进度。 下面我会展示第二类的case. 当我们开发完HDL代码以后，需要造一些常规case，和边界case, 不同于传统的ICflow，这些case 代码会跟HDL放到一个project下面, 它并不会生成数据，非常清晰简洁。即便很长时间过去以后你依然能够方便的再把它们跑起来。 //GPS发送case， 卫星编号， 信噪比，位置偏移， 频偏一目了然， 实现细节全部封装在对应的类里面 object GPSTxCases { val case00: List[SatCase] = List( SatCase(Sat(GPS, 1), ChannelCase(snr = 100, chipOffset = 0, Fdoppler = 0 Hz))) .... val case04 : List[SatCase] = List( SatCase(Sat(GPS, 1 ), ChannelCase(snr = 0, chipOffset = 399 , Fdoppler = 10 Hz)), SatCase(Sat(GPS, 31), ChannelCase(snr = 0, chipOffset = 100 , Fdoppler = 500 kHz)), SatCase(Sat(GPS, 7), ChannelCase(snr = 0, chipOffset = 100 , Fdoppler = 500 kHz)), SatCase(Sat(GPS, 15), ChannelCase(snr = -2, chipOffset = 2047, Fdoppler = 27 Hz))) ... } 跟踪测试case, 可以有发送数据 和 跟踪jobs组合而成，除了构造典型case以外，构造随机Case也是不是任何难题。 object GPSTECases { val case00 = TECase(GPS, sendcase = GPSTxCases.case00, jobs = GPSTEJobs.case00, maxMs = 32 ) val case01 = TECase(GPS, sendcase = GPSTxCases.case01, jobs = GPSTEJobs.case01, maxMs = 32 ) 回归集通过层层包装最后寥寥几行，干干净净，再也看不到在dut上force一大堆的信号让你迷惑, 配合IDEA的变量函数追踪功能，你也很容易看明白该case具体进行哪些测试，有些人看到上面的Sat， GPSTEjobs 可能不清楚这些具体是干什么的，不明觉厉，这时候你别忘了IDEA的 Ctrl+B跳转大法 ，scala 只要你看不懂的函数或者各种类似于 :=,&lt;-&lt; 的符号，尽管大胆Ctrl+B进入，维多利亚不再有秘密。 最后，这些case能直接很方便的添加到持续集成CI集（CI持续集成在传统的IC开发流程中使用并不是很广泛，但是scala 开发HDL的时候CI还是非常有必要，原因后面会单独出一篇介绍） class TESimRegression extends FunSuite { test(\"tesim_case00\"){ val s = new TESim(GnssConfig(), GPSTECases.case00,//force GPS信号以及跟踪job BDTECases.case00, //force BD信号以及跟踪job withWave = false, dumpNode = false) s.sim(ms = 30) } ... test(\"tesim_caseN\"){ ... } } 三：开源工具目前开发的模块全部都是基于SpinalHDL + IDEA社区版 + verilator + gtkWave 这4个都是开源免费软件，最最重要的是：跨平台 之前我们可能只能在Linux上做RTL开发，现在你在windows， mac上开发完全OK， 没有任何障碍。 虽然是免费开源软件，相比商业EDA工具看上去像草台班子，但实际使用上这套开源软件并不是你印象中的学术玩具，或者是实验性质的东西，它是能体现生产力的工具。 verilator 相比VCS速度上几乎没区别，唯一的gtkWave相比verdi要弱一些，我自己本来是一个重度的Verid依赖着，以为离开verdi 都不会看波形，经过一段时间的适应gtkWave好像也没那么糟糕，配合上IDEA的追踪，并且SpinalHDL生成的代码会原封不动的保留信号名，所以快速定位追踪波形没有任何问题。当你遍历回归时，可以关闭文件dump，以及波形，速度会更快。 当然为SpinalHDL添加VCS、irun后台也是完全没有问题的，这样就可以dump fsdb，使用verdi了，不过我印象当中vcs，verdi应该只有Linux版本。Linux 多半会在公司的服务器上，一般也不会联网。所以对于个人来讲想学习或者做一些好玩的东西，没有平台限制可能更为方便。","link":"/spinal/spinal8.html"},{"title":"Maven Windows 配置","text":"Maven 仓库timeOut 问题Scala 工程打包发布依赖repo1.maven.org\\maven2\\org\\scalaz\\scalaz-core_2.12\\7.2.141234567891011121314151617181920212223242526[error] lmcoursier.internal.shaded.coursier.error.FetchError$DownloadingArtifacts: Error fetching artifacts:[error] https://repo1.maven.org/maven2/org/scalaz/scalaz-core_2.12/7.2.14/scalaz-core_2.12-7.2.14.jar: wrong checksum: C:\\Users\\Administrator\\AppData\\Local\\Coursier\\cache\\v1\\https\\repo1.maven.org\\maven2\\org\\scalaz\\scalaz-core_2.12\\7.2.14\\scalaz-core_2.12-7.2.14.jar (expected SHA-1 71066d053b1e2ced2ce7476c0716eedb4f36d634 in C:\\Users\\Administrator\\AppData\\Local\\Coursier\\cache\\v1\\https\\repo1.maven.org\\maven2\\org\\scalaz\\scalaz-core_2.12\\7.2.14\\.scalaz-core_2.12-7.2.14.jar__sha1, got 479f9b2484893c97063ce9510be0f6f3eae2edaa)[error][error] at lmcoursier.internal.shaded.coursier.Artifacts$.$anonfun$fetchArtifacts$8(Artifacts.scala:359)[error] at lmcoursier.internal.shaded.coursier.util.Task$.$anonfun$flatMap$2(Task.scala:14)[error] at scala.concurrent.Future.$anonfun$flatMap$1(Future.scala:307)[error] at scala.concurrent.impl.Promise.$anonfun$transformWith$1(Promise.scala:41)[error] at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)[error] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)[error] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)[error] at java.lang.Thread.run(Thread.java:748)[error] Caused by: lmcoursier.internal.shaded.coursier.cache.ArtifactError$WrongChecksum: wrong checksum: C:\\Users\\Administrator\\AppData\\Local\\Coursier\\cache\\v1\\https\\repo1.maven.org\\maven2\\org\\scalaz\\scalaz-core_2.12\\7.2.14\\scalaz-core_2.12-7.2.14.jar (expected SHA-1 71066d053b1e2ced2ce7476c0716eedb4f36d634 in C:\\Users\\Administrator\\AppData\\Local\\Coursier\\cache\\v1\\https\\repo1.maven.org\\maven2\\org\\scalaz\\scalaz-core_2.12\\7.2.14\\.scalaz-core_2.12-7.2.14.jar__sha1, got 479f9b2484893c97063ce9510be0f6f3eae2edaa)[error] at lmcoursier.internal.shaded.coursier.cache.FileCache.$anonfun$validateChecksum$4(FileCache.scala:749)[error] at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)[error] at scala.util.Success.$anonfun$map$1(Try.scala:255)[error] at scala.util.Success.map(Try.scala:213)[error] at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)[error] at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)[error] at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)[error] at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)[error] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)[error] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)[error] at java.lang.Thread.run(Thread.java:748)[error] (update) lmcoursier.internal.shaded.coursier.error.FetchError$DownloadingArtifacts: Error fetching artifacts:[error] https://repo1.maven.org/maven2/org/scalaz/scalaz-core_2.12/7.2.14/scalaz-core_2.12-7.2.14.jar: wrong checksum: C:\\Users\\Administrator\\AppData\\Local\\Coursier\\cache\\v1\\https\\repo1.maven.org\\maven2\\org\\scalaz\\scalaz-core_2.12\\7.2.14\\scalaz-core_2.12-7.2.14.jar (expected SHA-1 71066d053b1e2ced2ce7476c0716eedb4f36d634 in C:\\Users\\Administrator\\AppData\\Local\\Coursier\\cache\\v1\\https\\repo1.maven.org\\maven2\\org\\scalaz\\scalaz-core_2.12\\7.2.14\\.scalaz-core_2.12-7.2.14.jar__sha1, got 479f9b2484893c97063ce9510be0f6f3eae2edaa)Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? 方法一更新 C:\\Users\\Administrator.m2 下的settings.xml1234567891011121314151617181920&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus-osc&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus osc&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus-osc-thirdparty&lt;/id&gt; &lt;mirrorOf&gt;thirdparty&lt;/mirrorOf&gt; &lt;name&gt;Nexus osc thirdparty&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/repositories/thirdparty/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 方法二在中国，sbt访问maven-central很慢，可以改用阿里云的maven repository，或者jcenter作为备选在.sbt目录下，新建或修改repositories文件12345[repositories]localaliyun: http://maven.aliyun.com/nexus/content/groups/publicjcenter: http://jcenter.bintray.comtypesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly 方法三：如果上面两个都不行，手动下载 打开https://mvnrepository.com/ 搜索 scalaz-core 找到需要下载的版本手动下载，也可以复制链接用迅雷下载 覆盖本地C:\\Users\\Administrator\\AppData\\Local\\Coursier\\cache\\v1\\https\\repo1.maven.org\\maven2\\org\\scalaz\\scalaz-core_2.12\\7.2.14\\scalaz-core_2.12-7.2.14.jar 重新编译pass","link":"/scala/20200221_maven_windows.html"},{"title":"Scala 单例对象的三个应用","text":"一 进度条有时候我们在编写代码时希望能够查看运行时间，最简单的方法： 123456def main(args: Array[String]) { val startTime: Long = System.currentTimeMillis 待测试的代码块 val endTime: Long = System.currentTimeMillis System.out.println(\"程序运行时间： \" + (endTime - startTime) + \"ms\")} 但这个方法显然不是那么优雅。如果你在使用Scala的时候注意运行log，你会发下进度条更漂亮直观的。 1234567[Runtime] SpinalHDL v1.3.9 git head : a4cb4aadf0820174c1b48023bfcd3e9981de1d4a[Runtime] JVM max memory : 1820.5MiB[Runtime] Current date : 2020.01.23 10:44:55[Progress] at 0.000 : Elaborate components[Progress] at 0.513 : Checks and transforms[Progress] at 0.705 : Generate Verilog[Done] at 0.806 实现非常简单，首先得创建一个单例对象，单例对象一旦被实例化以后，startTime就会确定，不管Driver后面被调用多少次只会用到第一次被实例化的对象，startTime也不会改变。 1234object Driver { val startTime = System.currentTimeMillis() def executionTime: Double = (System.currentTimeMillis - startTime) / 1000.0} 再创建一个名叫“MyProgress”的用户接口, 每次执行“MyProgress”时调用单例对象Driver的executionTime打印当前时刻。 1234object MyProgress { def apply(message: String) = println(s\"${MyLog.tag(\"Progress\", Console.BLUE)} at ${f\"${Driver.executionTime}%1.3f\"} : $message\")} 以下是一个基带仿真的case，每个关键节点调用MyProgress， 每步耗费的时间一目了然（单位s）。 123456789[Progress] at 0.000 : Coherence correlation start[Progress] at 0.076 : DopplerOffset HertzNumber(250.0)[Progress] at 0.296 : Sample done[Progress] at 0.481 : add AWGN noise[Progress] at 0.488 : Normalized rx power to 0 dB[Progress] at 0.489 : Receive data with AWGN, Sampled at 2.048/40.96MHz[Progress] at 0.529 : Quantization to 2bit done[Progress] at 0.538 : 2 bit AD data remaping done[Progress] at 2.243 : carrier Mixing done 我也听到有人抱怨Rocket生成时间巨长，自己也搞不清楚时间到底耗费在什么地方，有可能是编译，也有可能是逻辑代码，也有可能是firrtl的解析生成。 现在你就可以用MyProgress来诊断瓶颈到底出在哪儿。 我自己用Scala编写算法参考平台时就遇到一个怪异的问题，按理说Scala是静态语言比Python更快，但是大致相同的算法，运行时间奇慢无比，后来就用MyProgress的进行二分法，找到问题的症结，我在打印文件时代用折叠的方式拼接字符串，foldLeft在功能上并没有问题，但是在字符串拼接是时间复杂度应该不是线性的（具体我没有深究，有兴趣的同学可以研究一下），导致很慢。 1fp.write(content.foldLeft(\"\")(_+\"\\n\"+_)) 正确的方法是用mkString，速度回复正常，问题解决 1fp.write(content.mkString(\"(\"\\n\"))) 最后这里的MyProgress正是SpinalHDL的SpinalProgress，有兴趣可以阅读其源码 二 开关开关应用还是比较广泛，用过Matlab你就会比较熟悉 12grid ongrid off 我举另外一个例子，算法在设计完功能和性能仿真以后要做定点性能仿真，定点的过程是需要修改代码，但是算法需要经常在全精度和定点之间切换调试，因为有时候性能不过，我们不清楚是逻辑的问题还是定点的问题。 当一个很大的project中定点地方可能非常多，我们不可能每次去来回修改定点代码，优雅的方式应该设置一个开关，而不是去修改代码。 首先设置一个开关单例对象 12345678910111213protected object FixSwitch { private var switch: Boolean = true def state: Boolean = switch def on: Boolean = { SpinalInfo(\"FixPoint Switch on\") switch = true state } def off: Boolean = { SpinalInfo(\"FixPoint Switch off\") switch = false state } 然后设置2个开关动作来改变单例对象的状态。 1234567object FixOn{ def apply(): Boolean = FixSwitch on}object FixOff{ def apply(): Boolean = FixSwitch off} 定点源码中加入开关状态 1234567891011class FixData(...){ ... def fixProcess(): Double ={ if(FixSwitch.state){ fixPoint logic ..... } else { raw } } ...} 性能仿真 1234object PerformanceRegression extends App{ FixOff() //关闭定点，默认定点开启 Simulation5G() //代码中的定点自动失效，不需要手动修改} 有些人发现本质上这就是设置了一个全局可变的变量而已, 1var FixSwitchState: Boolean = true 但是我们为什么不用全局变量, 而是单例对象，留给大家思考。 三 全局默认参数同样也是定点上的一个例子，SpinalHDL提供定点工厂函数 1val wire5bit = wire10bit.fixTo( 6 downto 2, roundType = FLOOR, symmetric = true) 但是一个Project可能有成百上千的定点处理, 每个定点都添加roundType, symmetric显然很累赘，当然你可以选择默认参数 1val wire5bit = wire10bit.fixTo( 6 downto 2) 不同的团队，不同的项目，可能使用不同的Round方式还有对称方式，我们希望默认参数也是可配置的。SpinalHDL UInt/SInt定点源码： 12def fixTo(x: Range.Inclusive): IQ = fixTo(x, round = getFixRound(), sym = getFixSym()) 默认的round，和 symmetric 参数通过getFixRound, getFixSym从全局获得。 一般一个工程种round 和 symmetric都是固定的，直接在SpinalConfig种设置即可。 12SpinalConfig(mode = Verilog, fixPointConfig = FixPointConfig(ROUNDUP, true)) 当然也可以在通过以下方式来刷新默认配置。 1FixPointConfig(ROUNDUP, true).flush() 具体实现参见源码","link":"/scala/20200119_scala_single_object.html"},{"title":"Spinal-sim Verilator install on Windows","text":"Verilator install on WindowsStep1 : install MSYS32到官网https://www.msys2.org/ 下载最近安装文件 msys2-x86_64-20190524.exe 运行安装到d:/msys64,安装完毕后打开 mingw64.exe 在命令行输入 pacman -Suyy 如果遇到以下异常12345# pacman -Syuu错误：无法初始化事务处理 (无法锁定数据库)错误：无法锁定数据库：File exists 如果你确认软件包管理器没有在运行， 你可以删除 /var/lib/pacman/db.lck。 解决办法，删掉之前的文件： /var/lib/pacman/db.lck出现错误的原因是，之前同步的时候，由于异常中断，导致之前进程锁文件未被释放。 Step2 Change mirrors for China user如果更新库很慢导致失败1234567# pacman -Syuu:: 正在同步软件包数据库...错误：无法从 repo.msys2.org : Operation too slow. Less than 1 bytes/sec transferred the last 10 seconds 获取文件 &apos;mingw32.db&apos;] 49%错误：无法从 sourceforge.net : Operation too slow. Less than 1 bytes/sec transferred the last 10 seconds 获取文件 &apos;mingw32.db&apos; 3%错误：无法从 www2.futureware.at : Operation too slow. Less than 1 bytes/sec transferred the last 10 seconds 获取文件 &apos;mingw32.db&apos;7%错误：无法从 mirror.yandex.ru : Operation too slow. Less than 1 bytes/sec transferred the last 10 seconds 获取文件 &apos;mingw32.db&apos; 10%错误：无法升级 mingw32 (下载数据库出错) 请更新 清华镜像 编辑 /etc/pacman.d/mirrorlist.mingw32 ，在文件开头添加：1Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686 编辑 /etc/pacman.d/mirrorlist.mingw64 ，在文件开头添加：1Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64 编辑 /etc/pacman.d/mirrorlist.msys ，在文件开头添加：1Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch 然后执行 pacman -Sy 刷新软件包数据即可。 Step3: Install Verilator123456pacman -Syuu#Close the MSYS2 shell once you're asked topacman -Syuupacman -S --needed base-devel mingw-w64-x86_64-toolchain \\ git flex\\ mingw-w64-x86_64-cmake 1pacman -S mingw-w64-x86_64-verilator Step4: Add to ENVAdd D:\\msys64\\usr\\bin;D:\\msys64\\mingw64\\bin to you windows PATH Step4: Spinal simulation by verialtor123456789101112[Progress] Verilator compilation startedVDFT2Cell.mk:67: /mingw64/share/verilator/include/verilated.mk: No such file or directorymake: *** No rule to make target '/mingw64/share/verilator/include/verilated.mk'. Stop.Exception in thread \"main\" java.lang.AssertionError: assertion failed: Verilator C++ model compilation failed at scala.Predef$.assert(Predef.scala:170) at spinal.sim.VerilatorBackend.compileVerilator(VerilatorBackend.scala:376) at spinal.sim.VerilatorBackend.&lt;init&gt;(VerilatorBackend.scala:429) at spinal.core.sim.SpinalVerilatorBackend$.apply(SimBootstraps.scala:120) at spinal.core.sim.SpinalSimConfig.compile(SimBootstraps.scala:400) at spinal.core.sim.SpinalSimConfig.compile(SimBootstraps.scala:364) at FFT.DFT2CellTest$.main(FFTsim.scala:27) at FFT.DFT2CellTest.main(FFTsim.scala) 显示verilated.mk路径找不到，我忍为应该是VERILATOR_ROOT目录设置有误， 查找verilated.mk的目录所在地，然后在windows Env 中添加系统变量 VERILATOR_ROOT= /d/msys64/mingw64/share/verilator 任然遇到问题123456789x86_64-w64-mingw32-g++.exe: error: /d/msys64/mingw64/share/verilator/include/verilated.cpp: No such file or directoryx86_64-w64-mingw32-g++.exe: fatal error: no input filescompilation terminated.make: *** [/d/msys64/mingw64/share/verilator/include/verilated.mk:192: verilated.o] Error 1make: *** Waiting for unfinished jobs....x86_64-w64-mingw32-g++.exe: error: /d/msys64/mingw64/share/verilator/include/verilated_vcd_c.cpp: No such file or directoryx86_64-w64-mingw32-g++.exe: fatal error: no input filescompilation terminated.Exception in thread &quot;main&quot; java.lang.AssertionError: assertion failed: Verilator C++ model compilation failed x86_64-w64-mingw32-g++.exe 不能访问/d/myss64/….，后来重新安装MSYS2到 C盘，并且将系统变量删除 VERILATOR_ROOT 任然遇到问题：检查环境变量Paht的值为C:\\Users\\Administrator\\.babun\\cygwin\\bin;D:\\Program\\emacs-26.2\\bin;C:\\Users\\Administrator\\.babun;C:\\Users\\Administrator\\AppData\\Roaming\\npm;%IntelliJ IDEA Community Edition%;C:\\Users\\Administrator\\AppData\\Local\\Pandoc\\;c:\\msys64\\usr\\bin\\;c:\\msys64\\mingw64\\bin\\ 发现很乱 ,删除一些不用的D:\\Program\\emacs-26.2\\bin;C:\\Users\\Administrator\\.babun;C:\\Users\\Administrator\\AppData\\Local\\Pandoc\\;c:\\msys64\\usr\\bin\\;c:\\msys64\\mingw64\\bin\\;更新PATH 重新开启Project , 运行Spinal-sim ，Wow 居然成了， 非常痛苦， 饶了一大圈，居然是PATH变量的问题。总算是解决了 最后：特别注意： 尽量把MSYS2安装到C盘 在环境变量Path末尾追加C:\\msys64\\usr\\bin;C:\\msys64\\mingw64\\bin 不要多此一举设置VERILATOR_ROOT， Spinal会默认识别到 /mingw64/share/verilator 如果运行不成功，请检查你的PATH，设置是不是非常杂乱，请删除不用的，尽量保持干净。","link":"/eda/install_verilator_on_windows.html"},{"title":"浮点避坑","text":"浮点数相加我们知道浮点数尽量避免不同量纲的数相加12&gt; 1023 + 0.00000000000001Double = 1023.0 浮点数除法不同量纲之间的除法也会得到不一样的结果1234&gt; 1.023/2.047Double = 0.49975574010747426&gt; 1023.0/2047.0Double = 0.49975574010747437 因此对于有些应用可能引入意向不到的结果比如1234&gt; 1023.0/2047.0*2.047 == 1.023Boolean = false&gt; 1023.0/2047.0*2047 == 1023Boolean = true 避免不同量纲的数做加减法，还要注意不同量纲的数做乘除法带来的意外结果 典型的例子1230.3 - 0.1floor( 0.3*10 - 0.1 *10 ) //2.0floor((0.3 - 0.1)*10 ) //1.0 Double Eps 精度12Float (B=2 / p=24): Eps = 2^(-24) = 5.9604644775390625E-8Double (B=2 / p=53): Eps = 2^(-53) = 1.1102230246251565E-16 也就是说计算机能表示的最小绝对值120+1E-16 = E-161+1E-16 = 1.0 他的精度跟指数位有关，总共E-16次方的误差范围，指数位占n位，那么误差就等与E(-16+n)12341000+1e-16= 1000.01000+1e-15= 1000.01000+1e-14= 1000.01000+1e-13= 1000.0000000000001 只要指数位和分数位之和不要超过16，都可以表示12345671E10+1E-6 = 1.0000000000000002E10 //能表示1E-6不能表示1E10+1E-7 = 1.0E10 //误差1E-7不能表示1E8+1E-7 = 1.000000000000001E8 //指数位8，误差1E-7可以表示1000000 +1E-10 = 100000.0000000001 //可以表示1E-1010000000 +1E-10 = 10000000.0 //不能表示1E-10误差,指数位占了71E18 + 13 = 1e18 所以你在用浮点计算的时候，要看数的量纲，量纲越大，Eps要设置的大一些, 否则就失去了意义 Scala EPS 所以在判断一个数是否为0是， 不能 a == 0 而是要 abs(a) &lt;= Eps ,同样在比较两个数是否相等时，不能 a == b 而是要 abs(a - b) &lt;= Eps BigDecimalDouble的问题是精度有限123val a = 0.02val b = 0.03val c = b - a c的结果不是0.01，而是c: Double = 0.009999999999999998因此有些系统设计中不能用double，不如金融银行金额计算为什么会这样呢? 因为float和double都是浮点数, 都有取值范围, 都有精度范围. 浮点数与通常使用的小数不同, 使用中, 往往难以确定.常见的问题是定义了一个浮点数, 经过一系列的计算, 它本来应该等于某个确定值, 但实际上并不是!double相减会转换成二进制，因double有效位数为 16位这就会出现存储小数位数不够的情况，这种情况下就会出现误差，解决方法就是使用BigDecimal，它的有效长度足够长可存储小数位数。因此可代替double来进行加减乘除， 金额必须是完全精确的计算, 故不能使用double或者float, 而应该采用java.math.BigDecimal.123val a = BigDecimal(0.02)val b = BigDecimal(0.03)val c = b - a c的结果得到0.01 123val a = BigInt(&quot;1234567890123456&quot;).toLongval b = 0.001val c = a + b c的值为1234567890123456，0.01丢失123val a = BigDecimal(&quot;1234567890123456&quot;)val b = BigDecimal(0.001)val c = a + b c的值为1234567890123456.001，精度并不会丢失 BigDecimal(value), value可以用数字初始化，太大的值只能用字符串初始化如“123456789012345678” 1234567val a = BigDecimal(&quot;1234567890123456001&quot;)val b = BigDecimal(0.1231)val c = a * b c.precisionc.roundedc.scalec.pow(2) 123val c= BigDecimal(&quot;1234.5000&quot;)c.doubleValuec.round(new java.math.MathContext(4, java.math.RoundingMode.HALF_UP))","link":"/others/float_trap.html"},{"title":"Spinal-Bootcamp 在线新手教程","text":"最近花了点时间基于Jupyter-notebook做了一个SpinalHDL教程.方便立即运行查看一个Spinal用法和对应生成的verilog代码，大多数例子来源于SpinalHDL的官方文档，也新增了一些实例和Scala的高级用法，这些可以帮助你理解SpinalHDL如何工作。 目前可以直接点击运行，国内访问Binder速度有点慢，也可以clone到本地运行。 为什么做这个事情 提供一个SpinalHDL的在线环境，方便测试功能用法，直接查看verilog，而不用新建工程 提供一个Scala的在线环境，方便你测试一些Scala的用法","link":"/spinal/spinal-bootcamp.html"},{"title":"SpinalHDL(七):逢山开路-寄存器接口","text":"目前大量存在手写寄存器接口的情况，对于几十个甚至几百个寄存器的IP，即便你有体力，也不能保证不犯错。 存在的问题 纯体力活,工作量繁重 容易引入错误，增加验证工作量 文档和代码不同步，增加软件调试工作量 在这类问题上耗费测试debug时间非常不值当，只要你手写寄存器必然会遇到这了问题，软件调了好半天，最后发现文档跟代码不一致，人是懒惰的，谁能完全保证代码更文档能同步更新，也肯定会犯错的，所以只能通过验证和测试来覆盖，如果问题能够越早发现，成本越低 这里分享二张图： 一张是某软件产品在各个阶段bug的成本 另外一张是IC开发各个阶段bug的成本 所以尽可能的在前期解决问题，第一次把事情做对，就是节约成本。 如何优雅的生成寄存器接口 唯一源头, 代码文档严格保存一致 错误检查能力, 输出的代码一定是正确无误的。 一次书写，多种输出，节省工作量 Excel表格自动生成寄存器接口代码为了达到以上效果，很多公司可能都有类似的工具，通过Excel表格或者在网页定制寄存器，然后一键生成verilog代码和Word文档.在生成之前会做严格的检查，比如命名重复，地址重复，字段冲突，复位值位宽不匹配等等，保证生成的代码一定是正确的。 SpinalHDL寄存器接口方案SpinalHDL采用的方法跟Excel表格略有不同，通过书写SpinalHDL代码生成文档和verilog代码，不过原则是一样的，都是源头唯一，一到多的思路 寄存器地址自动分配通过newReg来自动分配，也可以newRegAt(address=0x100)，切换锚点，后续的地址将从0x100递增。 123456789101112class RegBankExample extends Component{val io = new Bundle{ apb = Apb3(Apb3Config(16,32))}val busSlave = BusInterface(io.apb,(0x0000, 100 Byte)val M_REG0 = busSlave.newReg(doc=\"REG0\")val M_REG1 = busSlave.newReg(doc=\"REG1\")val M_REG2 = busSlave.newReg(doc=\"REG2\")val M_REGn = busSlave.newRegAt(address=0x40, doc=\"REGn\")val M_REGn1 = busSlave.newReg(doc=\"REGn1\")} 同时还会检测最大分配地址是否超越总线Mapping分配的空间，保证生成的代码是安全正确的。 寄存器字段自动分配同理通过field来自动分配字段，也可以fieldAt（pos=16）来切换锚点，后续字段从16bit位置递增 12345678val M_REG0 = busSlave.newReg(doc=\"REG1\")val fd0 = M_REG0.field(2 bits, RW, doc= \"fields 0\")M_REG0.reserved(5 bits)val fd1 = M_REG0.field(3 bits, RW, doc= \"fields 0\")val fd2 = M_REG0.field(3 bits, RW, doc= \"fields 0\")//auto reserved 2 bitsval fd3 = M_REG0.fieldAt(pos=16, 4 bits, doc= \"fields 3\")//auto reserved 12 bits 同样自动的分配会自动插入reserved，也可以手动插入。同时会保证字段分配不会超过总线数据位宽的最大值。 一个中断寄存器实例中断寄存器场景的有两种方案 中断使能和中断状态 中断使能中断MASK和中断状态 第二种类型更为通用，可以让软件打开所有中断，也可以通过Mask来屏蔽部分信号的中断，这里以第二种类型来举例 1234567891011121314151617181920212223242526272829303132class InterruptRegIf extends Component {val io = new Bundle{val psc_done, pth_done, ssc_done, grp_done, scd_done, srch_finish = in Bool()val interrupt = out Bool()val apb = slave(Apb3(Apb3Config(16, 32)))}val busif = Apb3BusInterface(io.apb, (0x000, 100 Byte))val M_SRCH_INT_EN = busif.newReg(doc=\"srch int enable register\")val psc_int_en = M_SRCH_INT_EN.field(1 bits, RW, doc=\"psc interrupt enable register\")val pth_int_en = M_SRCH_INT_EN.field(1 bits, RW, doc=\"pth interrupt enable register\")...val M_SRCH_INT_MASK = busif.newReg(doc=\"srch int mask register\")val psc_int_mask = M_SRCH_INT_MASK.field(1 bits, RW, doc=\"psc interrupt mask register\")val pth_int_mask = M_SRCH_INT_MASK.field(1 bits, RW, doc=\"pth interrupt mask register\")...val M_SRCH_INT_STATUS = busif.newReg(doc=\"srch int status register\")val psc_int_status = M_SRCH_INT_STATUS.field(1 bits, RC, doc=\"psc interrupt status register\")val pth_int_status = M_SRCH_INT_STATUS.field(1 bits, RC, doc=\"pth interrupt status register\")...when(io.psc_done &amp;&amp; psc_int_en.asBool){psc_int_status(0).set()}when(io.pth_done &amp;&amp; pth_int_en.asBool){pth_int_status(0).set()}...io.interrupt := (psc_int_status &amp; pth_int_status &amp; ssc_int_status &amp; grp_int_status &amp; scd_int_status &amp; srch_finish_status).lsb} 生成verilog代码的同时生成如下文档 你可以发现中断的3个寄存器非常类似，这种方式书写依然有大量的重复。能不能更简单的方式生成中断类型，答案是肯定的，在scala上这一切都不是问题 12345678910111213class InterruptRegIf2 extends Component {val io = new Bundle {val psc_done, pth_done, ssc_done, grp_done, scd_done, srch_finish = in Bool()val interrupt = out Bool()val apb = slave(Apb3(Apb3Config(16, 32)))}val busif = Apb3BusInterface(io.apb, (0x000, 100 Byte))val int = busif.FactoryInterruptWithMask(\"M_INT\",io.psc_done,io.pth_done,io.ssc_done,io.grp_done,io.scd_done,io.srch_finish)io.interrupt := int} 实际上就用了一个函数factorInterrruptWithMask(namePre:String, triggers:Bool*)就完成了前面那段一模一样的工作。并且也会生成一样的寄存器表格你只需要把所有触发中断的脉冲信号作为参数丢进去，factorInterruptWithMask会抓取信号名，重新生成3组寄存器，并且正确命名。背后的机理会用到1点宏的知识，后面章节会介绍。 注：该方法会在SpinalHDL1.3.7以后版本中体现","link":"/spinal/spinal7.html"},{"title":"Scala3-Macro系统Tasty进展","text":"Scala3 重新设计Macro系统，这是官网英文原文。翻译的很烂，全当学习笔记而已，仅供参考 Or: Scala in a (Tasty) Nutshell如何迁移到 Scala 3这篇博文中提到最大的一个问题是关于宏的问题。目前我们正在努力将Tasty和macros对齐，接下来谈一谈我们的想法. What is Tasty?Tasty是Scala3的高级交换格式。它基于类型化的抽象语法树这些树在某种意义上包含了Scala程序中的所有信息。它们表示程序的语法结构，还包含有关类型和位置的完整信息.Tasty在语法检查之后（这样所有的类型都显式的知道了，并且隐式的东西都已经解释过了）给代码做一个快照，但是在快照之前不会经过任何转换，因此所有的信息都不会丢失。放语法树的文件为了紧凑会压缩优化（有点像javascript的压缩），这意味着我们可以在任何编译器运行期间生成完整的Tasty语法树，即便是单独编译也不依赖任何其他东西。Tasty语法树可以有很多用途 编译器可以用来支持单独编译 基于LSP-based language server 的语言可以支持超链接，自动补全，文档，查找引用，以及全局的重命名重构操作 构建工具可以在不同的平台上交叉构建，并将代码以二进制的方式迁移合并 优化器和分析器可以使用它进行深入的代码分析和高级代码生成 以上的CASE前两个已经完成，可以使用，另外两个在将来可以考虑实现 所以，到底什么是Tasty， 最新的Scala3的 dotc编译器的Tasty版本描述可以参见这里TastyFormat.scala What Does Tasty Have to Do with Macros?事实证明，Tasty也为新一代基于反射的宏提供了极好的基础，有可能解决当前版本中的许多问题。 当前Def Macros的第一个问题是它们完全依赖于当前的Scala编译器（内部名为nsc）事实上，def macros像是nsc内部结构之上的一层薄木板罩子, 这使得它功能非常强大，但也非常脆弱和难以使用正因为如此，他们一生都处于“实验”状态由于Scala 3使用不同的编译器（dotc），旧的基于反射的宏系统将不会移植，所以做一个不同并且更好的东西。 对于当前的宏的另一种批评是它缺乏一个基础。 Scala3已经有一个元编程的基础设施， 特别是一个非常好的explored基础。Quotes and Splices 是一种支持staging的方法，只需要向语言添加两个运算：Quote (')表示引用代码表达式，而splice(~)用来将一段代码插入另一段代码中。这个灵感来自于termporal logic MetaOCaml我们通过将两个时态操作符',~以及scala3 的inline功能得到了一个非常高层次的macro系统 inline 将代码从定义站点复制到调用站点 (') 将代码转换为语法树 (~) 在其他代码中嵌入语法树 这种处理宏的方法非常优雅，并且具有惊人的表达能力。但这可能有点太偏重原理，仍然有许多零碎的边角的问题需要处理, 特别是： 语法树是晦涩难懂的，我们缺少分解它们并分析其结构和内容的方法。 我们只能quote和splice表达式，但不能引用其他程序结构，如定义或参数。 我们一直在寻找一种通过分解和重构语法树的方式来加强元编程。这里的主要问题是太难选择了，因为基本上有无数种方法可以暴露底层结构。quasiquotes还是语法树？哪些应该明确的暴露出来？辅助类型和操作是什么？ 如果我们在这里要做一个选择的话，我们怎么知道这个选择对于今天的用户是正确的？如何在未来保证Api的稳定性？选择越多导致局面越尴尬，这是困扰def macros的根本原因。为了解决这一难题，我们计划自底向上来而不是自顶向下的方式。我们确立一下原则: The reflective layer of macros will be isomorphic to Tasty. Tasty会将反射和宏同构支持 将会有一下几点好处: 完整性. Tasty是Scala3的交换格式，因此基于Tasty的反射API将没有信息的丢失 稳定. Tasty作为交换格式会保持稳定，会按照严格的版本系统来谨慎管理Tasty的演进升级。因此反射的API可以以一种可控的方式发展。 独立于编译器. Tasty的设计将独立于支持它的编译器。除了Dotty的实现之外，在概念上也可以证明’scalac’也能生成Tasty语法树，甚至JAVA也可以生成。这就意外着反射API可以容易的移植到新的编译器，如果一个编译器支持Tasty格式的交换件，则可以同时支持反射API. Scala in a Nutshell作为实现这一目标的第一步，我们正在研究一套独立于编译器的数据结构来表示Tasty。目前的状态是已经提供了一个高层次的数据结构，用在Tasty的各个方面。目前大概有200行的定义，它能翻译类型检查后scala程序中包含的每一条信息。200行比mini-lisp的解释器要大，但是比起一个成熟的编译器前段差不多30000行要小的多。 Next Steps下一步WIP, 是将这些定义关联到Tasty文件格式我们将它重写为提取器来实现这一点，提取器根据dotc编译器使用的数据结构实现每种数据类型，然后以Tasty格式对这些数据进行pickle和unpickle另外一个有趣的选项是，直接书写Tasty的picklers和unpickler， 他们直接工作在反射语法树上。 Once this is done, we need to define and implement semantic operations such as 一旦这些工作完成以后，我们开始定义和实现语义和语法实现 what are the members that can be selected on this expression? which subclasses are defined for a sealed trait? does this expression conform to some expected type? 可以在此表达式上选择哪些成员？ 哪些子类是为一个密封特性定义的？ 此表达式是否符合某些预期类型？ 最后，我们将反射层和现有的基于quotes和spilices的宏链接起来, 这个看起来并不难。实际上，我们需要在scala.quoted.Expr[T]类型的高级树和Tasty.Term类型的低级树之间定义一对映射。将一个高级树映射到一个低级树简单的意思就是要暴露它的结构。将低层语法树树映射到高层scala.quoted.Expr[T]就意味着检查低层语法树是否确实具有给定的T类型。差不多就是这些。 Future Macros如果以上方案被接受，很大程度上决定了Scala3上Macro的样子，更重要的是，这些都在类型检查完成以后运行，这也正是Tasty语法树生成使用的时候。在类型检查以后运行Macro有很多优点 it is safer and more robust, since everything is fully typed, it does not affect IDEs, which only run the compiler until typechecking is done, it offers more potential for incremental compilation and parallelization. 它更安全、更健壮，没有类型擦除，类型完整保留 它不影响IDE，IDE只在类型检查完成之前运行编译器 它为增量编译和并行化提供了更大的潜力 不过这样做也限制了Macro的标识类型，Macro将是blackbox.这意味着从类型检查中看到的扩展表达式不能受Macro扩展的影响。只要满足这个约束条件，就能同时支持经典的def宏和宏注释。 例如，可以定义一个宏注释@json，将JSON的序列添加到类型种。与当前macro paradiseannotation macros(并不属于Scala的正式发行版本)的不同之处是, 在Scala3中由于注释驱动的扩展是在类型检查之后发生的，因此生成的序列化程序只能在下游项目中看到 （译注： 这段没看明白，生翻过来，见谅） 我们相信通过使用更具表现力的计算类型可以在一定程度上环境Whitebox macros的不足，[Dotty PR 3844](https://github.com/lampepfl/dotty/pull/3844中发布了该系统的草图。 Scala3语言还将直接包含一些更高级的结果，目前为止需要高级的Macro方式来定义。尤其： 直接通过by-name parameters为Lazy implicit建模，取代了之前通过Macro的方式 原生的 type lambdas 减少了kind projector的需求. 将会用一种不用宏的方式来派生类，其中有Kittens, Magnolia,scalaz-deriving，目前还在评估具体是哪一种替代方案。主要目标是开发一个易于使用且在编译和运行期间都能稳定的方案，第二个目标是通用性，只要他与主目标不冲突 Meta Programming in the Large未来Scala3宏的设计旨在取代现有的Macro和scala.reflect. 目前还有一个元编程系统Scalameta相当有竞争力, 他提供了高质量的语法和予以分析以及独立于Scala编译器的代码生成工具，顾名思义，ScalaMeta是在元级别上运行的，也就是说，他一程序为输入，生成语法和语义信息，或者以重写的程序为输入出。相反，Macro系统集成在语言中，并在翻译过程中扩展程序，这两个项目之间可能存在潜在的协作性。可以举两种可能性。 Scalameta或者由它派生出来的SemanticDB项目可以直接从Tasty获取信息，这将使得他们完全独立于编译器之外。 IDE可以在单个项目上使用Tasy， 而对于复杂的多项目多语言的构造请参考SemanticDB Please Give Us Your Feedback!如果你对于Macro的roadmap有更好的想法，欢迎到这里讨论，thread on Scala Contributors.你们的建议都非常重要，加入Dotty贡献你的力量，一起重建Scala未来","link":"/scala/20191121_scala3_Tasty.html"},{"title":"SpinalHDL(六):定点化-饱和截位","text":"首先为什么要定点化？在性能可接受的范围内尽可能的的压缩数据bit位宽以便节省资源一个扰码识别的定点流程灰色的全精度蓝色是定点截位以后的位宽,对于这个算法，定点以后在大大节省资源的情况下性能几乎没有任何损失。我们在定点的时候不是说每一个节点都需要压缩bit，而是在关键的节点尽可能压缩位宽才能做到事半功倍，比如以上例子中的求平方，和最后的累计和输出，这两个点对硬件来说非常敏感，一个是乘法器，另外一个是缓存MEM，是面积的开销大户，所以我们在定点的时候要特别有意去照顾这些节点，在性能可接受的情况下，能省1bit是1bit 定点介绍(低截高饱)一般我们会分为两步来操作 低位Round操作 低位的Round操作有非常多类型。参见https://en.wikipedia.org/wiki/Rounding 其实 RoundHalfUp, RoundHalfDown, RoundHalfToZero,RoundHalfToInf, RoundHalfToEven, RounHalfToOdd 非常接近,RoundToInf,最为常见。其中”RoundToeven,RoundToOdd”比较特别，这种Round比RoundToInf还要公平一些，但是相对稍微复杂一下，一般用在打数据统计中对精度非常敏感的场景。SpinalHDL目前不支持这两种类型，不同语言的round函数实际用的Round类型其实也各有不同，SpinalHDL为了保持通用，默认round采用RoundToInf，但是我们在一般的硬件设计当中推荐大家使用RoundToUp，这种方式选择器更少，时序面积更好，性能几乎没有太大损失。 高位饱和操作 主要是饱和操作，但是有时候直接截掉的需求，高位直接截掉没有数学意义，我不清楚具体用在什么地方。除此之外，高位还有一个对称操作，比如8bit的有符号数表示范围为（-128~ 127）如果不对称取反的话会出现+128 如果有符号数表示就得扩展为9bit为了避免这种情况，又是需要将(-128 ~127) 对称到（-127 ~ 127）,这样在取反的时候就不用扩展1bit，性能损失几乎忽略不计，在硬件设计当中非常常见。 Verilog是怎么做的？手动书写定点电路 封装fixpoint代码我们用Verilog来实现定点饱和截位时，起初都是手写饱和截位电路，包括现在我看很多人还是直接手写这个是极其容易出错，也是我们和算法debug追问题的高发地带。我想很多人都会遇到跟算法比对数据是遇到差1bit对不上（实际上就是+-1），追了半天发现定点方式理解不一致，或者电路里面写错了。这种问题反反复复的发生，非常耗时耗力，很没必要。后来出现了一种相对稳定一点的方式： 封装为饱和截位这个可能是在verilog上能做到的最好的方式了，但是不够完美 使用方式： 12fixpoint (15,11,4,1,1) u_add1_fix (.din(fixin),.dout(fixout));fixpoint (15,10,4,1,1) u_add2_fix (.din(fixin),.dout(fixout)); 源码实际上这里面也就才实现了Floor,RoundToInf,RoundUp三种Round方式，不得不用verilog generator配合一些宏，代码看上去已经是灾难了，调试到稳定也是非常痛苦。 SpinalHDL定点如何操作这一切到SpinalHDL上一句话就能搞定 12val A = SInt(10 bit)val B = A.fixTo(7 downto 3) //定点化 展开来等效于 1val B = A.roundToInf(3).sat(3) SpinalHDL完整的提供了8种Round Api 你可以直接像这样使用它 1234val x = UInt(8 bits)val y = round(n) // return x-n bits(default,align=true)val y = round(n,align=false) // return x-n+1 bits(need carry)val y = floor(n) // return x-n bits(floor with no align argment) 当然我们鼓励你 使用fixTo , 更直观也更安全，不需要你手动处理进位对齐的那些琐碎容易犯错的操作。当然你愿意你完全还是可以用A.roundToInf(2).sat(3).symmetry 这种方式式去处理，不做限制。 只要你配置好roundType，以及symmetric是否对称, 就可以自由的使用fixTo,一行搞定!","link":"/spinal/spinal6.html"},{"title":"为什么\"简单\"如此复杂","text":"软件工程中”简单”的复杂性简单可能比复杂更难：你必须努力使思维清晰才能简化它。但最终这一切都是值得的，因为它能使你翻越高山。—— Steve Jobs 我相信有两种设计软件的方式：一种是使软件足够简单而明显没有缺陷；另一种是使它如此的复杂，以至于没有明显的（可被轻易发现的）缺陷。 —— TonyHoare（译者注：英国计算机科学家、图灵奖得主、快速排序算法的发明人、哲学家就餐问题的提出者……） 简单，软件工程的圣杯。业界的前辈一直在驱策我们去追求它。 （软件设计）是一门手艺……相对”复杂”而言，它赋予”简单”更高的价值—— Barbara Liskov（译者注：2008年图灵奖得主） 如果我们想构建好的系统，就需要构建简单的系统 —— RichHickey(译者注：Clojure语言的发明人) 成功地开发复杂软件的唯一方法是降低它的整体复杂性，使用简单的部件来构建它。——Eric S. Raymond (译者注：著名黑客、开源运动领导者之一) 简单是可靠的先决条件。 —— Edsger Dijkstra（译者注：结构化程序设计的早期贡献者、一大批算法的发明人、哲学家就餐问题的解决者……） 可靠性的代价是对终极简单性的不谢追求 —— Tony Hoare 并且，与圣杯一样，简单性已被证明是极难获得的。主要有这样一些原因： 软件有其本质上的复杂性。软件的不同元素以非线性的方式互相交互。相对线性系统而言，这提升了整体的复杂性。 你不总是能控制必须使用的软件（例如第三方软件库、由公司内其他小组开发的库、遗留系统等。） 总是存在修改的压力。 不同的需求和利益之间常常会有冲突。 整体复杂性相对线性系统而言增加了很多。 非技术因素一个程序员必须控制的复杂性很多是由他必须与之打交道的人或组织所无理地强加于他的。——Fred Brooks (译者注：《人月神话》作者) 当我们无论何时考察一个软件时，我们的思维都必须超越技术层面。这（非技术因素）是软件存在的理由，而且它们与代码并无关系。 这些事物或人包括： 用户 业务与利益相关方 工程师、(UI)设计师、业主的需要和利益 财务约束 在很多场合，这些错综复杂的问题都是由不同人的利益和政治因素驱动的。也许我们不喜欢这些，但它们是真实存在的影响软件开发的因素。忽略它们的影响及其复杂性只会将我们自己至于危险中。 复杂性是无法避免的 长期来看所有的程序都会变成”洛可可”风格——然后是一片废墟（rubble）。——AlanPerlis （译者注：1966年首届图灵奖获得者。） (译者注：洛可可（rococo）是18世纪流行于欧洲的一种艺术风格。在装饰艺术上体现为大量使用繁复的、变化丰富的曲线。这里指程序变得越来越复杂，同时与后面的rubble读音上相似。) 在任何有意义的软件程序中，复杂性都是无法避免的。软件系统必须演化，否则就会过时。随着软件的演进，新的功能或修改原有的功能都会增加复杂性。因此，事实证明，将复杂性引入软件是我们的利益所在。 简单性不可能来自简单的思维当软件业迷失于复杂性之中时，如果有一种方法能保证带来高质量的软件，无疑会受人青睐。很多人曾经宣称过找到了某种带有魔力的技术或方法。现在让我们来考察其中的一些： 静态类型 框架 静态类型将解决所有问题曾经大量的宣传将静态类型奉为软件质量的救星。例如在Elm（一种编程语言）的网站上写道： 与手写的Javascript不同，Elm代码在实践中不会产生运行时异常。Elm使用类型推理机制在编译阶段就能发现问题并给出友好的提示。通过这种方式，错误永远不会出现在你的用户面前。 真是一个可爱的声明！如果它是真的话。如果正确使用静态类型就能解决我们的问题，那真是太迷人了。如果这一切是真的话，那么使用像Elm这样的语言就是每一个软件开发者的道德义务。其效应将是非常显著的、并也无疑是及其重要的。但遗憾的是，事实并非如此。 痴迷于静态类型的人试图使我们相信”只要妥当地使用类型系统，程序就不会出错”。这虽然听上去令人印象深刻，但实际只是句空话。静态类型检查是对程序的运营态行为的编译时抽象，因此它必然只是部分有效，并且是不完备的。这意味着程序依然会因为无法进行类型检查的属性而出错，同时某些程序虽然不会出错，但它们也无法进行类型检查。—— 《程序设计语言的冷战的终结》（Erik Meijer, Peter Drayton） 事实上，正如Meijer和Drayton指出的，对于静态类型的过分强调也可能造成问题，因为这种强调本身会引入新的复杂性： 如同”幽灵类型（phantom types）”和”摇摆类型（wobblytypes）”所描述的，使得静态类型更加完备的冲动可能使类型系统变得过分复杂和奇异。这就好像用链条在脚上拴个铁球去跑马拉松，然后欢呼自己差点就跑完了，而实际不到1英里就退出了。 关于Bug密度的数据显示他们的结论是正确的。相比静态类型而言，简单性与缺陷密度有更大的相关性。 上述研究的作者DanLebrero指出：”数据显示，没有证据表明静态/动态类型对缺陷密度有影响，但是数据显示出……在专注简单性的语言和不关注简单性的语言间有巨大的差异。” 你需要使用正确的框架编程语言是低层次的，用它编写的程序则需要关注与语言本身无关的东西。——Alan Perlis 软件业一直致力于提供能使编码更容易、更可靠的抽象层。我们今天可以不用机器语言来写程序就是这一努力的证明。当我们消除了很多偶然复杂性以后，系统固有的核心复杂性却始终存在。并且我们构建的抽象还带来了更多的问题。 JoelSpolsky的这个评论早已为众人所知：”所有非平凡的抽象都在某种程度上有所疏漏。”（原文：Allnon-trivial abstractions, to some degree, areleaky.”）他的意思是所有的抽象都会在某些方面无法掌握本来想要简化的复杂性，复杂性依然从抽象的裂缝中逃逸出来。 我们可以在ReactJS上看到这个理论的最近例证。React的一个主要目的是抽象掉DOM。但是React为需要直接操作DOM的场合提供了”refs”。当然，通过这种方式你可以理解如何与DOM交互。但这也意味着抽象失败了。事实上，必须理解如何绕过React以便与DOM交互，这一点导致了额外的复杂性。 同时，还有一些复杂性从抽象中产生。抽象来自隐藏实现细节的必要性，同时，也对我们所能做到的事情添加了限制。这就是为什么React需要”refs”，因为有些事它做不到。抽象本身可能具有内在的复杂性。 没有银弹上面的评论可能会招来一些充满宗教热情的争论，这并非我的本意。我的目的是要指出： 无论是在技术上还是在管理上，不存在一种新发明，单独使用就能使软件的生产率、可靠性和简洁性获得数量级的提升。——Fred Brooks 但是，与但丁的《神曲》不同，你还无需抛弃所有的希望。认识到不存在构建完美软件的神秘魔法有助于将你从魔法思维的王国中拯救出来。只有从这样的奇幻世界中出来你才能应对软件业的现实。于此同时你也将认识到，其实一切并非只关于软件。 其所关更大：它是人、是人际关系、是过程、是我们所处的环境、是现实也是历史、它持续数代又是当下，换句话说……这相关于系统。 如果没有银弹，我们能做什么呢？我们可以接受这些： 总有一些复杂性需要我们去把握；我们无法写出完美的软件——接受这个现实吧； 总有妥协和不完美； 杰作需要时间； 我们必须处理人的因素（偏好、政治、不同的思维方式，等等）； ……设计是最好慢慢地、小心为之的事情。—— AlanKay（译者注：Smalltalk的最初设计者、OOP和GUI的先驱。） 是什么造就”简单”？(软件的简单性)与从复杂的自然现象中概括出简单的物理定理需要同样的技能、专注、洞察力，甚至灵感。它还需要接受由物理、逻辑和技术的约束条件所限制的目标，同时当互相冲突的目标无法达成时接受必要的折衷。——Tony Hoare 造就”简单”的因素不容易确定。部分是因为”简单”有一定的主观性，部分是因为对简单的理解依赖于经验。对训练有素的数学家来说简单而明显的东西对生物学家来说就并非如此，——反之亦然。这个留给我们的充其量是对”简单”的模糊理解，如同Potter大法官对色情作品的著名定义：”当我看到的时候我就知道了。” 即便如此，还是有一些有助于写出简单的程序的方法： 一旦懂得了系统的基础原则，理解和解决问题就有了把握； 使用众所周知的文化符号的系统比较容易理解； 保持设计的一致性； 充分利用语义； 维持对灵活性的需求和保持系统的边界之间的平衡； 尽可能限定复杂性； 识别并消除不必要的复杂性； 抵御不必要的复杂性虽然有一些方式使个体开发者能够避免复杂性，但是在组织层面的努力有更大的影响。这里是一些组织能做的事情： 欲速则不达当项目接近尾声时，总会要仓促地加入一些新功能。这样的赶工简直是发疯，因为它总会将项目引入歧途。——Tony Hoare 力争使销售、业务部门和产品部门理解到软件开发——开发好的软件——需要时间。 留出时间来设计； 留出时间来实好的编码习惯； 留出时间来重构； 所有的牺牲都有代价。这些代价会随着时间的推移而累加。 避免最新技术的陷阱软件开发是”时尚产业”。当程序员努力学习方法论、编程语言和框架，以最终能正确行事时，一味追求最新、最强会导致混乱。深思熟虑，并且不盲目跟随随流，有助于在较长时间内保持代码的健康。 经受过考验比”酷”要好得多。 跟随标准流程程序员（优秀程度）不由他们的聪明和逻辑性来衡量，而由他们的案例分析的完整度来衡量。——Alan Perlis 有一些标准的、众所周知的、经过实践证明的措施有助于提升软件质量和简洁性： 代码复审——这是软件团队工具箱中最有力的工具。确保周密的计划、组织和执行你们的代码复审； 设计复审——不仅要复审代码、设计也要复审； 足够的顶层设计——不要坐下来就开始编码。仔细考虑系统该如何设计。遵循设计模式以确保设计始终前后一致； 对系统的运行有整体规划。对一些问题有概要的定义，例如：如何处理异步操作；如何处理容错性；如何处理数据一致性，等等； 确保需求是高质量的——不管采用什么方式； 总结简单性并不简单。同样重要的是记住这只是手段而不是目的。构建易于使用、易于维护的高质量的软件才是目的。 今天，保持系统简单是人们管理软件的最有效方式。简单性是过程和实践、是一系列原则、指导和哲学。它是整个组织应该提倡和追求的。 原文出处","link":"/thought/why-simple-so-complex.html"},{"title":"SpinalHDL(五):时钟和时钟域","text":"SpinalHDL的时钟和时钟域设计一开始就设计的相对比较完整，Chisel起初只能支持同步复位，这个在工程上带来了很多麻烦，最近chisel3好像可以支持异步复位。例化方式非常别扭，我更喜欢SpinalHDL的清晰直观。非常重要的一个区别写SpinalHDL你很清楚哪些是硬件哪些是软件，而chisel就特别模糊，充斥着大量的软件思维，去了解他们各自开发者的背景也就不难理解。所以一个合格的产品设计者，首先是一个合格的用户。 几个简单的示例 默认时钟 1234class Top extends Component{ val a = in Bits(8 bits) val b = RegNext(a) init 0} 默认会得到一个clk,reset时钟复位信号，并且SpinalHDL复位默认是上升沿 12345678910111213module Top ( input [7:0] a, input clk, input reset); reg [7:0] b; always @ (posedge clk or posedge reset) begin if (reset) begin b &lt;= (8'b00000000); end else begin b &lt;= a; end endendmodule 自定义时钟源 如果我们不喜欢默认是时钟复位名称，可以自己修改时钟信号名，通过ClockDomain来创建一个时钟域（其实spinal的Component里隐含了一个叫clockDomain变量的默认domain） 123456val myclk,myrst = in Bool()val myClockDomain = ClockDomain(myclk,myrst)new ClockingArea(myClockDomain){ val reg0 = RegNext(a) init 0 b := reg0} 如果让寄存器生效，需要用clockingArea（myClockDomain）把寄存器包裹起来便可得到如下verilog代码 123456789101112131415module Top ( input myclk, input myrst, input [7:0] a, output [7:0] b); reg [7:0] _zz_1_; assign b = _zz_1_; always @ (posedge myclk or posedge myrst) begin if (myrst) begin _zz_1_ &lt;= (8'b00000000); end else begin _zz_1_ &lt;= a; end endendmodule 可以看到复位信号是posedege，如改为negedge,只要在创建时钟域时按如下修改覆盖config即可 123456val myClockDomain = ClockDomain(myclk,myrst, config = ClockDomainConfig( clockEdge = RISING, resetKind = ASYNC, resetActiveLevel = LOW)) 覆盖子模块默认时钟 每次用clockArea来包裹代码块，非常啰嗦，我能不能在直接修改该模块的默认时钟域，目前呢需要在该模块的上一层用myclockdomain包裹模块例化即可 123456789class Sub extends Component{ val a = in Bits(8 bits) val b = out(RegNext(a) init 0)}class Top extends Component{ val myclk,myrst = in Bool() val mycd = ClockDomain(myclk,myrst) val u_sub0 = mycd(new Sub) //mycd时钟包裹Sub模块的例化} 生成的verilog可以看到，子模块的时钟复位信号都被修改过来了 12345678910111213141516module Sub ( input [7:0] a, output reg [7:0] b, input myclk, input myrst); always @ (posedge myclk or negedge myrst) begin if (!myrst) begin b &lt;= (8'b00000000); end else begin b &lt;= a; end endendmodulemodule Top (...endmodule ClockDomain详解SpinalHDL的ClockDomain概念为一组时钟复位方案，并不单指一个时钟信号完整的时钟域配置分两块 ClockDomain 12345678ClockDomain( clock: Bool [,reset: Bool] [,softReset: Bool] [,clockEnable: Bool] [,frequency: IClockDomainFrequency] [,config: ClockDomainConfig]) ClockDomainConfig 12345case class ClockDomainConfig(clockEdge: EdgeKind = RISING, resetKind: ResetKind = ASYNC, resetActiveLevel: Polarity = HIGH, softResetActiveLevel: Polarity = HIGH, clockEnableActiveLevel: Polarity = HIGH) 创建clockDomain有4种方法 默认clockDomain该时钟域又SpinalHDL默认创建，前面我们将如何替换默认时钟以外，我们还可以直接在SpinalConfig里面修改默认时钟域的配置 123456SpinalConfig(mode = Verilog, defaultConfigForClockDomains = ClockDomainConfig(resetKind = ASYNC, clockEdge = RISING, resetActiveLevel = LOW), targetDirectory=\"tmp/\").generate(new MyTop) 从端口信号创建 前面已经提到过这种方法，很简单 12val myclk,myrst = in Bool()val mycd = ClockDomain(myclk,myrst) external函数有时候我们在例化一个异步FIFO的时候可能一个时钟需要从顶层接进来，如果hierarchy很深，一级一级连进来相当麻烦，Spinal提供了一个external函数，可以非常方便的创建一个时钟，并且接到顶层 1val myClockDomain = ClockDomain.external(\"myClock\") 得到的Verilog： 123456module ExternalClockExample ( .... input myClockName_clk, input myClockName_reset); ....endmodule internal函数一般SOC系统的时钟往往来自于一个时钟管理单元，由PLL产生，那么这时候，我们需要internal函数从内部创建clockDomain 12345678910111213141516171819202122232425class InternalClockWithPllExample extends Component { val io = new Bundle { val clk100M = in Bool val aReset = in Bool val result = out UInt (4 bits) } // myClockDomain.clock will be named myClockName_clk // myClockDomain.reset will be named myClockName_reset val myClockDomain = ClockDomain.internal(\"myClockName\") // Instanciate a PLL (probably a BlackBox) val pll = new Pll() pll.io.clkIn := io.clk100M // Assign myClockDomain signals with something myClockDomain.clock := pll.io.clockOut myClockDomain.reset := io.aReset || !pll.io. // Do whatever you want with myClockDomain val myArea = new ClockingArea(myClockDomain){ val myReg = Reg(UInt(4 bits)) init(7) myReg := myReg + 1 io.result := myReg }} 时钟门控处理目前Spinal在处理门控的时候还是需要手动例化， 123456class Top extends Component { val u_cgCell0 = new CG val u_cgCell1 = new CG... val cgd0 = ClockDomain(u_cgCell0.ECK, clockDomain.readResetWire) val cgd1 = ClockDomain(u_cgCell1.ECK, clockDomain.readResetWire) 手动例化两个ClockDomain会存在一个问题，会将它们判定为两个异步时钟。目前Spinal提供一个函数setSyncWith，讲两个clockDomain的Family全部设置为同步，这样在异步检查的时候就不会报错 1234 cgd0.setSyncWith(cgd1) val u_sub0 = cgd0(new MySub) val u_sub1 = cgd1(new MySub)} 时钟工厂函数除了时钟门控，还有时钟分频也会涉及到这类问题.对于同源同相幂次分频我们也会认为是同一个时钟域来处理。所以一种更优雅的方式应该是，提供工厂函数，让Spinal自动处理 12345val cgd0 = ClockDomain.cgFrom(clockDomain, cg_en)val cgd1 = ClockDomain.cgFrom(clockDomain, cg_en)val cdiv2 = ClockDomain.divFrom(clockDomain, times=2) val cdiv3 = ClockDomain.divFrom(clockDomain, times=4) 注：该方案还没有合入Spinal最新分支，会在1.3.7以后版本实现","link":"/spinal/spinal5.html"},{"title":"Lisp之根","text":"The Root of List约翰麦卡锡于1960年发表了一篇非凡的论文,他在这篇论文中对编程的贡献有如 欧几里德对几何的贡献.1 他向我们展示了,在只给定几个简单的操作符和一个 表示函数的记号的基础上, 如何构造出一个完整的编程语言. 麦卡锡称这种语 言为Lisp, 意为List Processing, 因为他的主要思想之一是用一种简单的数据 结构表(list)来代表代码和数据. 值得注意的是,麦卡锡所作的发现,不仅是计算机史上划时代的大事, 而且是一种 在我们这个时代编程越来越趋向的模式.我认为目前为止只有两种真正干净利落, 始终如一的编程模式:C语言模式和Lisp语言模式.此二者就象两座高地, 在它们 中间是尤如沼泽的低地.随着计算机变得越来越强大,新开发的语言一直在坚定地 趋向于Lisp模式. 二十年来,开发新编程语言的一个流行的秘决是,取C语言的计 算模式,逐渐地往上加Lisp模式的特性,例如运行时类型和无用单元收集. 在这篇文章中我尽可能用最简单的术语来解释约翰麦卡锡所做的发现. 关键是我 们不仅要学习某个人四十年前得出的有趣理论结果, 而且展示编程语言的发展方 向. Lisp的不同寻常之处–也就是它优质的定义–是它能够自己来编写自己. 为了理解约翰麦卡锡所表述的这个特点,我们将追溯他的步伐,并将他的数学标记 转换成能够运行的Common Lisp代码. 七个原始操作符开始我们先定义表达式.表达式或是一个原子(atom),它是一个字母序列(如 foo),或是一个由零个或多个表达式组成的表(list), 表达式之间用空格分开, 放入一对括号中. 以下是一些表达式:12345foo()(foo)(foo bar)(a b (c) d) 最后一个表达式是由四个元素组成的表, 第三个元素本身是由一个元素组成的表.在算术中表达式 1 + 1 得出值2. 正确的Lisp表达式也有值. 如果表达式e得出 值v,我们说e返回v. 下一步我们将定义几种表达式以及它们的返回值. 如果一个表达式是表,我们称第一个元素为操作符,其余的元素为自变量.我们将 定义七个原始(从公理的意义上说)操作符: quote,atom,eq,car,cdr,cons,和 cond. (quote x) 返回x.为了可读性我们把(quote x)简记 为’x.123456&gt; (quote a)a&gt; 'aa&gt; (quote (a b c))(a b c) (atom x)返回原子t如果x的值是一个原子或是空表,否则返回(). 在Lisp中我们 按惯例用原子t表示真, 而用空表表示假.123456&gt; (atom 'a)t&gt; (atom '(a b c))()&gt; (atom '())t 既然有了一个自变量需要求值的操作符, 我们可以看一下quote的作用. 通过引 用(quote)一个表,我们避免它被求值. 一个未被引用的表作为自变量传给象 atom这样的操作符将被视为代码:12&gt; (atom (atom 'a))t 反之一个被引用的表仅被视为表, 在此例中就是有两个元素的表:12&gt; (atom '(atom 'a))() 这与我们在英语中使用引号的方式一致. Cambridge(剑桥)是一个位于麻萨诸塞 州有90000人口的城镇. 而Cambridge’’是一个由9个字母组成的单词. 引用看上去可能有点奇怪因为极少有其它语言有类似的概念. 它和Lisp最与众 不同的特征紧密联系:代码和数据由相同的数据结构构成, 而我们用quote操作符 来区分它们. (eq x y)返回t如果x和y的值是同一个原子或都是空表, 否则返回().123456&gt; (eq 'a 'a)t&gt; (eq 'a 'b)()&gt; (eq '() '())t (car x)期望x的值是一个表并且返回x的第一个元素.12&gt; (car '(a b c))a (cdr x)期望x的值是一个表并且返回x的第一个元素之后的所有元素.12&gt; (cdr '(a b c))(b c) (cons x y)期望y的值是一个表并且返回一个新表,它的第一个元素是x的值, 后 面跟着y的值的各个元素.12345678&gt; (cons 'a '(b c))(a b c)&gt; (cons 'a (cons 'b (cons 'c '())))(a b c)&gt; (car (cons 'a '(b c)))a&gt; (cdr (cons 'a '(b c)))(b c) (cond ($p_{1}$…$e_{1}$) …($p_{n}$…$e_{n}$)) 的求值规则如下. p表达式依次求值直到有一个 返回t. 如果能找到这样的p表达式,相应的e表达式的值作为整个cond表达式的 返回值.123&gt; (cond ((eq 'a 'b) 'first) ((atom 'a) 'second))second 当表达式以七个原始操作符中的五个开头时,它的自变量总是要求值的.2 我们称这样 的操作符为函数. 函数的表示接着我们定义一个记号来描述函数.函数表示为(lambda ($p_{1}$…$p_{n}$) e),其中 $p_{1}$…$p_{n}$是原子(叫做参数),e是表达式. 如果表达式的第一个元素形式如 上1((lambda ($p_{1}$...$p_{n}$) e) $a_{1}$...$a_{n}$) 则称为函数调用.它的值计算如下.每一个表达式$a_{i}$先求值,然后e再求值.在e的 求值过程中,每个出现在e中的$p_{i}$的值是相应的$a_{i}$在最近一 次的函数调用中的值.123456&gt; ((lambda (x) (cons x '(b))) 'a)(a b)&gt; ((lambda (x y) (cons x (cdr y))) 'z '(a b c))(z b c) 如果一个表达式的第一个元素f是原子且f不是原始操作符1(f $a_{1}$...$a_{n}$) 并且f的值是一个函数(lambda ($p_{1}$…$p_{n}$)),则以上表达式的值就是1((lambda ($p_{1}$...$p_{n}$) e) $a_{1}$...$a_{n}$) 的值. 换句话说,参数在表达式中不但可以作为自变量也可以作为操作符使用:123&gt; ((lambda (f) (f '(b c))) '(lambda (x) (cons 'a x)))(a b c) 有另外一个函数记号使得函数能提及它本身,这样我们就能方便地定义递归函 数.3 记号1(label f (lambda ($p_{1}$...$p_{n}$) e)) 表示一个象(lambda ($p_{1}$…$p_{n}$) e)那样的函数,加上这样的特性: 任何出现在e中的f将求值为此label表达式, 就好象f是此函数的参数. 假设我们要定义函数(subst x y z), 它取表达式x,原子y和表z做参数,返回一个 象z那样的表, 不过z中出现的y(在任何嵌套层次上)被x代替.12&gt; (subst 'm 'b '(a b (a b c) d))(a m (a m c) d) 我们可以这样表示此函数123456(label subst (lambda (x y z) (cond ((atom z) (cond ((eq z y) x) ('t z))) ('t (cons (subst x y (car z)) (subst x y (cdr z))))))) 我们简记f=(label f (lambda ($p_{1}$…$p_{n}$) e))为1(defun f ($p_{1}$...$p_{n}$) e) 于是123456(defun subst (x y z) (cond ((atom z) (cond ((eq z y) x) ('t z))) ('t (cons (subst x y (car z)) (subst x y (cdr z)))))) 偶然地我们在这儿看到如何写cond表达式的缺省子句. 第一个元素是’t的子句总 是会成功的. 于是1(cond (x y) ('t z)) 等同于我们在某些语言中写的1if x then y else z ####123```#### ```lisp ####","link":"/sicp/20191025_the-root-of-lisp.html"},{"title":"SpinalHDL(四) 一窥总线四两拨千斤","text":"Spinal的lib.bus除了AMBA总线，并且还支持AvalonMM，当然你也很容易扩展自定义的总线。 Apb3总线例化一个简单的Apb3总线接口例化示例 1234567import spinal.lib.bus.amba3.apb._class T2 extends Component{ val busin = slave(Apb3(Apb3Config(12,32))) val busout = master(Apb3(Apb3Config(12,32))) busout &lt;&gt; busin}SpinalVerilog(new T2) 总线的例化也非方便简单，`Apb3`传入Apb3Config(addrWidth=12,dataWidth=32)即可生成一个总线，关键字slave，master设计非常漂亮，可以瞬间指定总线内部的接口方向，除此之外，`\\&lt;>`操作符为SpinalHDL定义的总线自动互联函数，不用你手动一个一个连。像这类操作符SpinalHDL有很多，像\\”>>\\”\\”>-/->\\”, \\”\\&lt;/\\&lt;\\”等等，不用害怕，这些只不过是定义的一个恰巧叫这个符号的函数而已，本质上跟你定义的autoConnect名字的函数并无二致，但是它要比文字函数要形象的多，并且假装操作符也是那么的自然。除了spinalHDL定义的操作符以外，你自己也可以定义各种各样简便的符号帮助你完成复杂琐碎的事情。41可以看到生成的Verilog总线已经完全连上了。 Apb3总线译码Apb3Decoder是一个工厂函数，它支持多种参数的传入 一：传入总线配置，和地址Mapping 1234Apb3Decoder(Apb3Config(16,32), List((0x0000,2 KiB), (0x1000,1 KiB), (0x5000,3 KiB)))) 可以得到42 二：传入master实例，和slave映射实例 123456789101112class Top extends Component{ val m0 = slave(Apb3(Apb3Config(16,32))) val s1 = master(Apb3(Apb3Config( 8,32))) val s2 = master(Apb3(Apb3Config(12,32))) val s3 = master(Apb3(Apb3Config(12,32))) val s4 = master(Apb3(Apb3Config( 2,32)))val mux = Apb3Decoder(master = m0, slaves = List(s1 -&gt; (0x0000, 64 ), s2 -&gt; (0x1000,1 KiB), s3 -&gt; (0x2000,3 KiB), s4 -&gt; (0x3000, 32 ))) 得到： 43 Axi-crossbarSpinal pinsec的总线拓扑结构44 源码：45 这么复杂一个链接关系，在SpinalHDL上不到50行代码，相信一般的伪代码都做不到这么简洁。因此阅读Spinal的源码简直就是一种享受，有时候我在恍惚这是文档还是代码。 想想一下，如果这个工作让你用Verilog实现，那是多么的操蛋。当然目前cross-bar都是由脚本或者ARM的工具来自动生成。但是对于外挂，互联，顶层的例化还得要手动做，这同样是一件极其繁琐容易出错的工作。但是现在放在Scala上是一个极其简单的伪代码式的描述即可完成。除此之外还可以做一些高级的检查，参数的协商，DAG(有向无环图)的检查都很容易办到。 总线转换AHB总线到APB总线的转换示例 12345678910import spinal.lib.bus.amba3.apb._import spinal.lib.bus.amba3.ahblite._class Top(ahbConfig:AhbLite3Config, apbConfig:Apb3Config) extends Component{ val ahb = slave(AhbLite3(ahbConfig)) val apb = master(Apb3(apbConfig)) val bridge = AhbLite3ToApb3Bridge(ahbConfig,apbConfig) ahb &lt;&gt; bridge.io.ahb apb &lt;&gt; bridge.io.apb} AXI到APB3总线转换示例 12345678910import spinal.lib.bus.amba3.apb._import spinal.lib.bus.amba4.axi._class Top(aw: Int,dw: Int,iw: Int) extends Component{ val axi = slave(Axi4Shared(Axi4Config(aw,dw,iw))) val apb = master(Apb3(Apb3Config(aw,dw,iw))) val bridge = Axi4SharedToApb3Bridge(aw,dw,iw) axi &lt;&gt; bridge.io.axi apb &lt;&gt; bridge.io.apb} 以下是pinsec中的源码，创建一个AXI到APB3的桥，然后从桥可以互联到其他外围。 12345678910val apbDecoder = Apb3Decoder( master = apbBridge.io.apb, slaves = List( gpioACtrl.io.apb -&gt; (0x00000, 4 KiB), gpioBCtrl.io.apb -&gt; (0x01000, 4 KiB), uartCtrl.io.apb -&gt; (0x10000, 4 KiB), timerCtrl.io.apb -&gt; (0x20000, 4 KiB), vgaCtrl.io.apb -&gt; (0x30000, 4 KiB), core.io.debugBus -&gt; (0xF0000, 4 KiB))) 可以非常方便的将这些外围连起来：46以上的代码绝大多数都能直接运行起来，能用如此简单寥寥几行就将原来复杂繁琐的工作安全可靠的完成，还有什么理由不使用它。","link":"/spinal/spinal4.html"},{"title":"SpinalHDL(三) 一行代码生成Soc系统","text":"如何生成一个Soc系统(注：Soc系统本身是一个比较笼统的概念，有各种各样不同复杂程度的SOC系统，我们这里指的Soc是一个最小系统，带处理器，片上Mem，一些基本外设以及总线拓扑的基础框架) 在Spinal生成一个最小Soc系统只需要一行代码 12import spinal.lib.soc.pinsec._SpinalVerilog(new Pinsec(500 MHz)) 即可生成一个完整的SOC系统，其中一个RISCV的处理器VexRiscv, 和AXI总线路由以及APB桥。pinsec-soc 没了，就这么屌 trump-no-more 如果需要定制，那么继续往下 如何定制Soc系统定制CPU 1234567891011121314val myCpuConfig = RiscvCoreConfig( pcWidth = 32, addrWidth = 32, startAddress = 0x00000000, regFileReadyKind = sync, branchPrediction = dynamic, bypassExecute0 = true, bypassExecute1 = true, bypassWriteBack = true, bypassWriteBackBuffer = true, collapseBubble = false, fastFetchCmdPcCalculation = true, dynamicBranchPredictorCacheSizeLog2 = 7 ) 插件式扩展CPU, 除了已有的扩展，你可以添加自己的扩展, 比如浮点，矢量处理 12345myCpuConfig.add(new MulExtension)myCpuConfig.add(new DivExtension)myCpuConfig.add(new BarrelShifterFullExtension)myCpuConfig.add(new MyFloatExtension)myCpuConfig.add(new MyVectorExtension) iCache 配置 123456789val myiCacheConfig = InstructionCacheConfig( cacheSize = 4096, bytePerLine = 32, wayCount = 1, wrappedMemAccess = true, addressWidth = 32, cpuDataWidth = 32, memDataWidth = 32 ) 更新PinsecSOC配置 123456789101112val mySocConfig = PinsecConfig( axiFrequency = 100 MHz, onChipRamSize = 4 KiB, sdramLayout = IS42x320D.layout, sdramTimings = IS42x320D.timingGrade7, cpu = myCpuConfig, iCache = myiCacheConfig) wrappedMemAccess = true, addressWidth = 32, cpuDataWidth = 32, memDataWidth = 32 ) resoc重新生成, 得到全新定制的SOC系统 1SpinalVerilog(new Pinsec(mySocConfig)) 这个一个完整的例子，可以看得出SpinalHDL的参数设计非常合理，层层设计，每一个功能模块有自己的参数伴侣，所有的配置，模块的扩展，全部放在参数里。 RocketChip隐式参数p恐怕要把你绕晕，这也是Chisel常备被吐槽的问题之一。Spinal完全不存在这样的问题，即便是你第一次接触，也基本上不存在什么阅读障碍，完整的Pinsec源码只有300行，能够完整的描述Soc顶层的互联信息，表达能力实属强大，源码参见Pinsec.scala 当然实际工程上的Soc系统不会这么简单，但是这个框架也不失一般性，即便是一个复杂的Soc系统完全可以以这种方式去管理。往往一个公司会有多个系列的芯片，一个系列的基本架构是有延续性，一个系列可以维护一个Soc-Top，利用参数化来管理。不同系列之间也有共性，比如像总线路由这种基础框架SpinalHDL都有现漂亮的实现。相比原来的Verilog代码，集成工作量几乎忽略不计，而且可以设置各种检查规则，更不容易犯错。","link":"/spinal/spinal3.html"},{"title":"SpinalHDL(一):此CHISEL非彼Chisel","text":"这里有两个概念 CHISEL泛指 基于Scala的硬件构筑语言(Constructing Hardware In Scala EmbeddedLanguage) 包括chisel和SpinalHDL, 所以标题中为什么需要CHISEL是指为什么需要一个基于Scala的HDL语言，实际上chisel和SpinalHDL称为HDL框架更为合适，因为除了一些电路语法外，绝大多数都是在运用Scala的语言功能，一切强大都源于Scala语法。 Chisel特指 伯克利大学发布的Chisel硬件开发语言 我们文章中大CHISEL为泛指， 小Chisel为特指。 Verilog不够用吗?需要一门新的语言吗? VHDL诞生于1982年 ,Verilog诞生于1981年, 起初是用来电路存档描述,都是硬件描述语言, 是用来描述数字电路的结构,行为,功能和接口的语言。 虽然Verilog/VHDL简单易用，在一定的历史时期确实是一个效率的巨大提升,但是目前来看，槽点依然很多,已经有点落伍时代。即便是SystermVerilog一定程度上改善了它 存在的问题,并没有完全解决Verilog的问题，况且EDA工具对SV的支持并不是很积极，所以依然是尴尬的存在。 例化不方便 有人会说，有辅助插件帮你完成 (确实有很多好的插件，emacs verilog-mode, vim 的autoinst) 即便这样，但是对带参数的模块例化,一对多例化同样需要手动处理，非常不方便 大量的重复声明 无休止的变量声明，无休止的位宽声明，容易出错,作为一门上古时期的语言，对编译器不能要求太高 函数不能带参数 verilog中函数的使用只能是零零星星，哪怕是一个位宽的变化都要重写函数,作为一门语言函数不能广泛使用，实为鸡肋 参数化实在是笨拙 虽然支持参数化，parameter 也只能做一些简单的加减左移操作,没有基本math包。 利用宏做参数化，对于变量比较多的设计，非常复杂，并且也不好维护目前我也看到 错误检测很弱 编译工具对错误的处理比较保守,这种保守可能也源于语言本身，以及编译器的能力不及。 位宽不匹配， input/output端口写反 饱和截位弄错， 跨时钟域问题 锁存器检查 组合逻辑环自己查 …. 基于前仿的编译，还会遗漏大量的错误，必须要Lint, 综合检查,费时费力又费钱。 重构、增减信号,Bist/DFT逻辑插入麻烦 需要手动插入, 编写脚本, 即便是脚本也不通用 等等… 所以现在写Verilog纯粹就是体力活，verilog工程师大概就是这个样子： 笔者本人写过一个手机芯片小区搜索的IP，python算法代码不到500行，Verilog整整写了2W多行绝大多数时间不是在处理功能逻辑问题，而是消耗在一些位宽错误,模块集成，端口连接，信号声明，重复基础cell等低级问题的处理上。 反而编译器倒落了个清闲，编译器的状况大概就是这个样子： 五连任性追问？ 能不能愉悦的开发？ 不想干重复的脏活 能不能参数化设计？ 想一劳永逸 能不能方便的复用？ 我懒 能不能检查错误？ 我粗心 能不能扩展它？ emm。。这个，老板肯定会问 为什么是Scala?软件领域的技术革新变化很快，而IC开发领域几乎被verilog/VHDL包办了40年，不管是语言还是Flow都事实标准化了。在IC领域想要技术方法大的更新，需要EDA工具厂家的支持，IC公司的认可(流程庞大变化迟钝)，工程师技能更多的是面向IC领域，缺乏软件工具造血能力。所以让变革发生在行业内部可能性极低。 虽然抽象能力参数化能力更好的SystemVerilog, E,SystemC等语言相继的诞生，但并没有根本上解决这些问题，主要原因是EDA工具厂家对这些特性支持不积极,更多的是用在验证建模领域。 同时IC设计也出现了另外一个方向HLS(High Level Synthsis),HDL语言是需要明确的电路信息的注入。而HLS是描述算法，对电路没有明确的描述，所以一般就会导致生成的电路资源冗余，时序冗余,HLS每年每家EDA都拿出来炒，真正使用HLS开发IP的公司还是非常少见。 除了传统的这些对verilog的扩展语言外或者另辟蹊径走HLS的语言之外，基于不同语言平台的DSL多如牛毛->HDL语言列表,其中也不乏有超强的参数化能力以及面向对象的特性, 但是都没能流行起来。 他们的问题除了完全不会有EDA工具的主动支持以外，主要有两个原因: 缺乏杀手级的特性(类型推导，函数式特性) 缺乏杀手级的项目(像Chisel的rocket, Spinal的Pinsec,Vexriscv ) 能担当此任的HDL一定是基于像Rust、Scala这类现代编程语言上的DSL, 虽然lisp,haskell本身也具备这样的能力，但是基于圆括号的代码风格不太容易被主流接受,另外纯函数式有点不点不见人间烟火，虽然Scala经常被吐槽函数式编程不纯粹，但是混合面向对象的特性，在管理数据构建程序结构而言面向对象还是相当方便. 我认为不太太可能出现在python，ruby，java这类语言,参数化能力很容易办到，但是缺乏函数式特性，类型推导惰性求值特性。一言以蔽之，这些不适合做DSL。 Scala能为我们做什么?目前较为流行的ScalaHDL框架有两个Chisel和SpinalHDL，Chisel出生伯克利自带流量，借着RISCV这两年算是出尽风头.反观SpinalHDL那可低调的 多，导致很多人都没有认真去了解过它,不清楚作者CharlesPapon是不会宣传还是不屑宣传，github上的头像都是默认的图标。 我本人起初对这种新的开发方法也持怀疑态度，是骂骂咧咧着上了Chisel的贼船，也在公司的项目上用过Chisel,尝到了甜头也隐隐觉的有些别扭，直到一次偶然的机会我重新阅读SpinalHDL的源码，我才意识到问题出在哪儿,别扭源于哪里。后面章节我会讲到我为什么坚定的从Chisel切换到SpinalHDL，在比较两者的区别之前我来罗列一下他们的共同点，也是所谓的泛CHISEL特性 泛Chisel特性 非常好用的位宽推断（甚至跨模块边界） 错误检查能力（Lint, CDC, timing评估， more） 彻底的参数化能力 大量的基础组件以及可重用IP 至少一个完整的Soc框架(Chisel的RokectChip, SpinalHDL的PineSec) 继承Scala平台所有强大的语言特性 在这里引入一个插曲，有些人会说rocket和Chisel不同一个项目，不能拿Rocket来当chisel做比较，不过我觉的脱离SOC和lib来讲CHISEL实在没什么可讲的，当年入学时煞有架势抱一本书在啃Verilog，我们的导师问的一句让我记忆犹新”Verilog只需要两个小时就学会的语言，为什么要抱一本书？你现在需要的编写代码”。所以不管是Chisel还是Spinal电路级的语法我也认为只需要2个小时就够了，更多的时间要花在编写代码更学习如何构建SOC或者lib上。现在网上看似有很多Chisel的资料，结果发现翻来覆去都在讲电路语法，而真正介绍RocketChiP，总线，时钟域，构建Lib的资料少之又少。所以学习Chisel或者Spinal最快的方法就是尽快上手去写代码。最好是实际的项目。 期望效果 解放工程师，避免重复琐碎，避免低级错误 加快开发周期，开发周期和模块大小不再是线性，有望指数 目前用Scala编写HDL代码，状况大有改观,工程师完全可以从些低级重复的工作中解放出来,把那些重复容易犯错的事情交给编译器，他会做的比人更好。 现在的你： 为什么不让编译器多干点呢？","link":"/spinal/spinal1.html"},{"title":"slides(revealjs 导出PDF)","text":"1. export HTML to slides $: unzip reveal.js.master.zip $: cd reveal.js.master 2. Edit index.html Export to reveal.js from https://slides.com/yourname/yourslide/edit Presentation made with Slides are powered by the reveal.js open source presentation framework. This export lets you migrate your slide content to a fresh reveal.js install. a. Download a copy of the reveal.js framework and make the following edits to its index.html. b. In the , replace the theme CSS with: c. In the , replace the node with: d. In the Reveal.initialize call towards the bottom of your index.html, append these config values: 3. Edit index pdf config a. edit index.html add. Reveal.Configure before Reveal.initialize 123Reveal.configure({ pdfSeparateFragments: false, pdfMaxPagesPerSlide: 1 });Reveal.initialize({ ... 4. Export pdf open index.html by Chrome like http://xxxx.index.html?print-pdf Ctrl-P(windows) or COMMAND-P(Mac-OS) Save FAQ Save Fail(Preview Failure)print range - fullI found Chrome export pdf raise Error when pages number bigger than 56So you should export it twice 1-56, 57~64","link":"/others/revealjs2pdf.html"},{"title":"分型与混沌","text":"中文字体abcdABCD 参考资料 费根鲍姆常数,种群数量分型混沌 SCALA Jullia/Mandelbrot绘制 惊叹的一维二维分形混沌联系(不动点函数, 二叉图， 曼德博集合之联系绘与一图)","link":"/sicp/20190505_fractal.html"},{"title":"CPS变换","text":"为什么函数调用需要保存状态？add(1,2) mul(3,4) 这种调用明显不需要保存状态而add(1,mul(1,2)) 这种计算是需要保存1级函数add的变量,再计算2级函数mul返回值和保存相加最终返回 得出一个结论：函数处在参数位置上，调用后需要返回的函数调用才需要保存状态而什么是尾调用？无需返回的函数调用一个简单的判定原则 即函数不在参数位置上 如何避免函数调用时保存状态？ Inline函数 编译器将函数就地展开，本质上是没有函数，只是代码片段的重复 尾调用 在函数返回的时候调用，这样主函数该做的都做完了,无需返回,只是将指针跳转,计算结果就是子函数的入参,无需额外变量的保存,函数调用过程可以参考文章 函数调用 尾递归实例12345678// fact_iter(n-1, mcc * n) 不处在任何函数的参数位置上@annotaion.tailrec //确保是尾递归否则编译器会报错def fact_iter(n: Int, mcc: Int): Int = { if (n==0) mcc else fact_iter(n-1, mcc * n) } 非尾递归实例而下面的例子不是尾递归，因为他处在函数”*“的第二个参数位置上, + - * / 实际上都是函数12345678// fact_rec(n-1) 在函数乘\"\\*\"的第二个参数位置上fact_rec = x =&gt; x==1 ? 1 : x * fact_rec(x-1) def fact_rec(n: Int): Int = { if (n==0) 1 else n * fact_rec(n - 1) } 循环实现因为尾递归无需返回，结果只跟出入的参数有关，因此只需要少量变量记录入参的变化，就能轻易改写成循环形式，因此尾递归和循环是等价的。改写循环： 12345function fact_loop(x) { var r = 1 while (x &gt;= 1) { r *= x; x--; } return r } CPS变换实现我们把CPS(Continuation Passing Style)的continuation函数按发音简称kont函数 kont函数在后面讲到扮演的是个随从角色，我们也叫kont随从函数 1234567@annotation.tailrecdef fact_ite(n: Int, kont: Int =&gt; Int): Int = { if (n==0) kont(1) else fact_ite(n - 1, x =&gt; kont(x * n)) } x =&gt; kont(x * n)是一个新函数，把保存的脏活交给了这个函数,主函数只负责进入，并不返回所以无需压栈保存，kont函数像个随从，主函数丢一个n给他，他负责保管保管的方式就是n*(n-1)*(n-2)... 直到最终返回他自己 n*fact_iter(n-1)n*(n-1) *fact_iter(n-2)n*(n-1)*(n-2) *fact_iter(n-2)n*(n-1)*(n-2)*(n-3) *fact_iter(n-2)...........................*fact_iter(0)n*(n-1)*(n-2)*(n-3)* ......*1 为什么不用循环实现，要搞这么复杂CPS变换实现的目的是什么? 我们知道函数式编程里面实际上不用循环，循环是有副作用的, 仰仗于函数式编程强大的计算力，循环归类到低等公民 函数式编程的重要思想是描述问题，而不是如何执行求解问题的过程。求解的问题依赖于程序或者编译器，会大量的用到递归，而不加处理的递归会有栈开销的问题，为了避免递归的栈开销甚至爆栈缺点，CPS变换可以使得递归能被良好的使用 Fibonacci CPS变化实例对于斐波那契函数常规的递归实现123456def fib0(n: Int): Int = { n match { case 0 =&gt; 1 case 2 =&gt; 1 case _ =&gt; fib0(n-1) + fib0(n-2)} 一般的尾递归优化实现12345678@annotation.tailrecdef fibtail(n:Int, nxt: Int, res: Int): Int = {n match { case 0 =&gt; res case _ =&gt; fibtail(n - 1, nxt + res, nxt )}}val a3 = fibtail(9, 1, 0) 对于有两个递归进入的函数怎么构造CPS的kont随从函数？2个函数进入，这就要求kont函数接纳2个结果入参，而kont函数要求只能接纳1个参数,请问怎么办？2个参数怎么变成1个参数的函数？如果你还有印象，那就是闭包123456789@annotation.tailrecdef fib2(n: Int, kont: (Int) =&gt; Int): Int = { n match{ case 0 =&gt; kont(1) case 1 =&gt; kont(1) case _ =&gt; fib2(n-1, x =&gt; fib2(n-2 , y=&gt; kont(x + y))) //第二个kont参数本质是携带第一个参数的闭包 }} 但是编译发现，会报错，SCALA编译器并不能将其优化成尾递归函数，不加检查时能正常执行。为什么没有尾递归优化？实际上scala只做了一些简单的tailrec优化，这种复杂的嵌套优化需要一写技巧，那就是：Trampoline技法需要手动的强制弹出下一层调用函数，禁止解释器压栈的行为 举一反三构造一个这样的序列f(n) = f(n-3)*f(n-2)*f(n-1), 看看如何使用CPS变换其中初始值f(0)=1,f(1)=1,f(2)=2 123456def inter(n: Int): Int = { if (n == 0) 1 else if( n== 1 ) 1 else if( n== 2 ) 2 else inter(n-3) * inter(n-2) * inter(n-1)} CPS变化123456@annotation.tailrecdef inter(n: Int, kont:(Int)=&gt;Int): Int = { if (n == 0) kont(1) else if( n== 1 ) kont(1) else if( n== 2 ) kont(2) else inter(n-3, x=&gt;inter(n-2,y=&gt;inter(n-1, z=&gt;kont(x*y*z)))) 通过3级闭包函数实现，将3个参数携带进去 CPS变化 参考文献：基于CPS变换的尾递归转换算法","link":"/sicp/20190429_cps.html"},{"title":"C函数调用和汇编代码分析","text":"risc-v C函数调用反汇编示例首先有一段C程序，其中main函数调用子函数add1234567//main.c int add(int a, int b){ return a + b ;}int main(void){ return add(2, 3);} 终端敲入rvgcc main.c -g 加-g是为了反汇编时将C和汇编交差显示，方便阅读rvobjdum -dS a.out &gt; main.S 反汇编看到 1234567891011121314151617181920212223242526272829303132333435363738000000000001019c &lt;add&gt;:int add(int a, int b){ 1019c: 1101 addi sp,sp,-32 //从原来的栈顶再向下再开辟32Byte栈空间 1019e: ec22 sd s0,24(sp) //保存 保存寄存器， 101a0: 1000 addi s0,sp,32 //栈底保存到fp/s0 101a2: 87aa mv a5,a0 //a5=a0=2 ------ 101a4: 872e mv a4,a1 //a4=a1=3 | 101a6: fef42623 sw a5,-20(s0) //a5=a0=2 | 101aa: 87ba mv a5,a4 | 101ac: fef42423 sw a5,-24(s0) //a5=a4=a1=3 |-- 可以优化掉 return a + b ; | 101b0: fec42703 lw a4,-20(s0) //a4=2 | 101b4: fe842783 lw a5,-24(s0) //a5=3 ------- 101b8: 9fb9 addw a5,a5,a4 //相加赋值给a5 101ba: 2781 sext.w a5,a5 //有符号扩展} 101bc: 853e mv a0,a5 //a5赋给返回寄存器a0 101be: 6462 ld s0,24(sp) 101c0: 6105 addi sp,sp,32 //释放子函数开辟的栈空间 101c2: 8082 ret //返回到ra内容地址00000000000101c4 &lt;main&gt;:int main(void){ 101c4: 1141 addi sp,sp,-16 //向下开辟16Byte栈空间 101c6: e406 sd ra,8(sp) //调用子函数前需要将ra压栈，否则子函数会覆盖ra 101c8: e022 sd s0,0(sp) 101ca: 0800 addi s0,sp,16 //栈底保存到fp/s0 return add(2, 3); 101cc: 458d li a1,3 //参数寄存器赋值 101ce: 4509 li a0,2 //参数寄存器赋值 101d0: fcdff0ef jal ra,1019c &lt;add&gt; //跳进函数add的地址1019c，并将返回地址(pc+4)存入ra 101d4: 87aa mv a5,a0 //计算结果a0 赋给a5} 101d6: 853e mv a0,a5 //赋给a0，作为main函数的返回值 101d8: 60a2 ld ra,8(sp) //main函数的ra出栈 101da: 6402 ld s0,0(sp) //main函数的sp出栈 101dc: 0141 addi sp,sp,16 //栈指针指向栈底,释放栈 101de: 8082 ret //从main函数的ra返回 将上面的代码用伪代码概况精简如下：123456789101112131415161718192021222324子函数：malloc stack //申请栈空间push ra //如果内部还有子函数，ra入栈，否则省略该步骤push s0/s... //保存子函数用到的保存寄存器ld sp s0 //若是栈传参，将参数堆栈地址赋给sp，将参数出栈 ，否则省略该步骤pop a1pop a2ld sp crt //将当前子函数的栈指针恢复process //执行子函数运算ld a0 res //讲计算结果保存到返回寄存器rapop s0/s... //恢复保存寄存器free stack //释放栈ret //从ra地址返回母函数：malloc stack //申请栈空间push ra //母函数ra入栈，否则会被子程序覆盖push s0/s... //保存子函数用到的保存寄存器passParameter //3种传参方法call subFunc //pc跳转到子函数地址ld a5 a0 //获取返回值pop s0/s... //恢复保存寄存器pop ra //恢复rafree stack //释放栈空间栈底在最上面，示意如下 汇编语言参数传递的3种方法 寄存器传参, 效率高，适合少量参数 地址传参, 参数打包到一个结构体，讲结构体的地址传入，然后解包 堆栈传参，调用前先压栈，再调用，返回从堆栈返回，也可以从寄存器返回 三种传参方法可以单独使用，也可以联合使用 不同的编译器处理方式也是不一样，堆栈传参最为常见，有些编译器也会支持fast call会将其编译成寄存器传参(条件是参数要小于可供传参的寄存器个数，一般6个左右)C语言返回一般都是通过返回寄存器返回，如果一下返回多个参数，那么一般将多个参数放到一个结构体将结构体的地址返回。 一些高级语言返回一次可以返回多个参数，实际上只不过编译器帮你做了包装的事情，计算机本身只能返回一个寄存器","link":"/riscv/20190428_function_call.html"},{"title":"C语言指针注解","text":"C语言指针实例指针的类型可以是int，double，float，struct …. 决定指针内部存放的数据大小，如果定义的是一个数组，类型可以让编译器 在p++是跳多少个大小的地址12345678910111213#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; void main(){ double array[5] = {1,2,3,4,5} ; int i ; // double *p = &amp;array[0] ;//跟下面等价 double *p = array ; //表示一个double的指针, 初始化指向array的首地址 for (i=0;i&lt;5;i++){ printf(\"@%p array[%d]=%f,%p\\n\",&amp;array[i],i,*p,p) ; //取值 *p p++; //p++ 会按照double 8个字节来增加，编译器会帮你自动搞定 }} 结构体指针12345678910111213141516171819202122struct Books { //总共占256个字节，16进制就是0x100个字节 char title[50]; char author[50]; char subject[152]; int book_id;};void main(){ struct Books booklist[5] ; int i ; struct Books *p = booklist ; //表示一个占Books struct的指针 for (i=0;i&lt;5;i++){ printf(&quot;@%p booklist[%d] @%p\\n&quot;,&amp;booklist[i],i,p) ; // p++; //p++ 会按照0x100(256字节)来增加 }} 执行`gcc main.c; ./a.exe`：@0x28c768 booklist[0] @0x28c768@0x28c868 booklist[1] @0x28c868@0x28c968 booklist[2] @0x28c968@0x28ca68 booklist[3] @0x28ca68@0x28cb68 booklist[4] @0x28cb68 结构体指针元素访问可以用结构体来定义指针类型 123456789101112131415161718192021222324252627282930313233#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;struct Books { //总共占256个字节，16进制就是0x100个字节 char title[50]; char author[50]; char subject[152]; int book_id;};void main(){ struct Books booklist[5] ; int i ; struct Books *p = booklist ; //表示一个占Books struct的指针 for (i=0;i&lt;5;i++){ //对于结构体指针，访问元素时用 p-&gt;title 访问 ，一般结构体直接用book.title 访问 strcpy( p-&gt;title, \"C Programming\"); strcpy( p-&gt;author, \"Nuha Ali\"); strcpy( p-&gt;subject, \"C Programming Tutorial\"); p-&gt;book_id = 100+i; printf(\"@%p booklist[%d] @%p\\n\",&amp;booklist[i],i,p) ; // p++; //p++ 会按照0x100(256字节)来增加 } p = booklist ; for (i=0;i&lt;5;i++){ printf(\"BookID:%d\\nTitle:%s\\nAuthor:%s\\nSubject:%s\\n\",\\ booklist[i].book_id,booklist[i].title,booklist[i].author,booklist[i].subject); // printf(\"BookID:%d\\nTitle:%s\\nAuthor:%s\\nSubject:%s\\n\",p-&gt;book_id,p-&gt;title,p-&gt;author,p-&gt;subject);//也是可以的 printf(\"--------------------------------------------\\n\"); p++; }} 结构体指针访问元素用 ‘-&gt;’ ,即 ‘p-&gt;tilte’一般结构体访问元素就用‘.’ ,即 ‘book.title’ union 共用体union共用体可以方便复用资源，有点像高级程序里面的泛型 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data{ int i; float f; char str[20];}; int main(){ union Data data; union Data *p; p = &amp;data ; printf( \"Memory size occupied by data : %d\\n\", sizeof(data)); data.i = 32 ; printf( \"data.i : %d\\n\", data.i); data.f = 32.12 ; printf( \"data.f : %f\\n\", data.i); strcpy(data.str,\"hello world\") ; printf( \"data.str : %s\\n\", data.str); printf( \"data.str : %s\\n\", p-&gt;i); printf( \"data.str : %s\\n\", p-&gt;f); printf( \"data.str : %s\\n\", p-&gt;str); return 0;}","link":"/riscv/20190418_c_point.html"},{"title":"","text":"函数式程序设计为什么至关重要Why Functional Programming Matters函数式程序设计为什么至关重要 作者： John Hughes翻译： CloudiDust ［http://blog.csdn.net/ddwn/］［在网上也可以找到其他同学的翻译哦，我翻译完了才看到的，呵呵。］ 原文地址：http://www.md.chalmers.se/~rjmh/Papers/whyfp.html －－－－－－－－－－－－－－－－－－－－ Why Functional Programming MattersJohn Hughes,Institutionen för Datavetenskap,Chalmers Tekniska Högskola,41296 G&amp;oumlteborg, SWEDEN.rjmh@cs.chalmers.se －－－－－－－－－－－－－－－－－－－－ 此 论文作于1984年，作为查麦兹大学的备忘录流传了多年，经过小幅度修订的版本出现于1989年与1990年，即［Hug89］与［Hug90］。此版本 基于原查麦兹大学备忘录的nroff源码，为LaTeX做了改动,使其更接近于印刷版本并纠正了少许错误。请原谅这多少有那么一点点过时的排版吧，文中的 例子也不是Haskell的！ ［me: 照理这段原文和内容没多大关系，不过实在手痒啊…… :)］ －－－－－－－－－－－－－－－－－－－－ 摘要 软 件正在变得越来越复杂，因此良好的软件构架也越来越重要。结构良好的软件易于编写，易于除错，同时提供可复用组件库以降低未来开发的成本。传统型语言在程 序模块化方面具有理念上的局限性，而函数式语言超越了局限。在本文中我们指出，函数式语言的两大特性，高阶函数与惰性求值，能够极大地促进模块化。作为例 证，我们处理了列表和树，编写了一些数值算法，并实现了alpha-beta启发式搜索（一个人工智能算法，用于游戏系统中）。既然模块化是程序设计成功 的关键，那么函数式语言对现实世界而言便极其重要了。 －－－－－－－－－－－－－－－－－－－－ 1 引言 本论文试图证明，对“现实世界”而言，函数式程序设计是极其重要的。同时，本文也试图明确指出函数式语言的长处，以帮助使用函数式语言的程序员们将这些长处发挥到极致。 函 数式语言之所以被如此称呼，是因为程序完全是由函数组成的。主程序本身也是一个函数，以程序的输入为参数，并返回其输出。典型地，主函数通过其他函数定 义，而这些函数又同样以更多的其他函数来定义，直到最低层的语言原生函数为止。这些函数与数学中的函数很相像，因此在本文中将以普通等式来定义它们。本文 使用了Turner的程序语言Miranda中的表示方法，但对于之前没有函数式语言相关知识的读者，本文仍然是可读的。（Miranda是 Research Software Ltd.的商标。） 函数式程序设计的特性与优点通常总结为类似这样：函数式程序不包含任何赋值语 句，因此变量一旦被赋予一个值，就不再改变。更一般地说，函数式程序不包含任何副作用：一个函数除了计算它本身的值以外，不产生任何作用。这一特性消灭了 “Bug”的一个主要来源，同时也使执行顺序不再重要——没有副作用能够改变一个表达式的值，故它可以在任何时刻被求值。这一特性将程序员从决定控制流的 重担之下拯救出来。由于表达式可以在任何时刻被求值，程序员便可以随心所欲地使用变量的值来代替变量，反之亦然——也就是说，程序是“引用透明”的。这一 自由使得函数式程序与它们传统的对应物相比，更容易数学化地控制。 这样的“优点”列表很不错，但如果说外行人不把它当回事，这也并不会令 人惊讶。它列出了很多内容关于函数式程序设计“没有”什么（它没有赋值，没有副作用，没有控制流）但却没多说它“有”什么。函数式程序员听起来很像是中世 纪的僧侣似的，他们禁绝了尘世中的种种乐趣并且期望这能使自己变得高洁。对于那些更关心物质利益的人而言，这些“优点”并没有多大的说服力。 函 数式程序员们争辩说，函数式程序设计确实有巨大的物质利益——一个函数式程序员拥有比他传统型的同行高得多的生产力，因为函数式程序短得多。但这有什么道 理吗？在这些“优点”的基础之上，唯一的很靠不住的借口就是，传统的程序中有90％是赋值语句，而在函数式程序中这些全都可以省略！这真是太荒唐了，如果 省略赋值语句可以带来如此巨大的好处，那么FORTRAN程序员们早该这样干了二十年了。［me：貌似是说FORTRAN的赋值多得一塌糊涂……］通过省 略特性来使语言更加强大在逻辑上是不可能的，不论这种特性是多么糟糕。 甚至函数式程序员都应该对这些所谓的“优点”表示不满意，因为它们 对于发掘函数式语言的威力毫无帮助。不可能写出一个特别地（particularly）缺少了赋值语句或者特别地引用透明的程序。这些不是什么衡量程序质 量的尺度，因此盯紧了它们（以此证明函数式语言的强大）也不理想。 ［me：关于那两个particularly的翻译，还是抓不准……］ 很明显，对函数式程序设计的特性的描述是不完备的。我们必须找出一些东西来填补——它们不但要解释函数式程序设计的威力，更要给函数式程序员们一个明确的追求目标。 －－－－－－－－－－－－－－－－－－－－ 2 与结构化程序设计的相似性 指 出函数式与结构化程序设计之间的相似性是很有帮助的。过去，结构化程序设计的特性与优点被总结为类似这样：结构化程序不包含goto语句；结构化程序中的 语句块没有多入口与多出口；结构化程序与它们传统的对应物相比，更容易数学化地控制。这些结构化程序设计的“优点”与我们之前所谈到的函数式程序设计的 “优点”在本质上很相似。这些叙述本质上都是否定式的，从而导致了诸如“不可或缺的goto”之类一大堆徒劳的争论。 事后诸葛亮式地说， 很明显地，结构化程序设计的这些特性，尽管很有用，但没有触及问题的核心。结构化程序与非结构化程序之间最重要的区别就是，结构化程序是用模块化的方法设 计的。模块化设计带来了生产力的巨大提升：首先，小模块可以很快很容易地编写；其次，通用模块可以被重用，使以后的程序可以更快地开发；再次，程序的模块 可以被独立测试，减少了除错的时间。 “不使用goto”等等这一类特性，对于这一提升没什么作用。这些特性促进了“程序设计的小改良”，然而模块化设计却促进了“程序设计的大进化”。因此，程序员在FORTRAN或汇编语言中都可以享受结构化程序设计带来的好处，哪怕那需要一点额外的工作。 模 块化设计是成功的程序设计的关键，这一观点现在已经被普遍地接受了，而诸如Modula-II[Wir82]，Ada[oD80]以及Standard ML[MTH90]之类的程序语言都内置了语言特性以促进模块化。然而，有一点非常重要，却常常被忽略。当编写一个模块化程序以解决问题的时候，程序员首 先把这个问题分解为子问题，而后解决这些子问题并把解决方案合并。程序员能够以什么方式分解问题，直接取决于他能以什么方式把解决方案粘起来。因此，为了 能在观念上提升程序员将问题模块化的能力，必须在程序语言提供中提供各种新的黏合剂。复杂的作用域规则与对分块编译的支持只对文本层面的细节有帮助，它们 没有提供能表达新观念的工具以分解问题。 通过与木匠行业的类比可以认识到黏合剂的重要性。先制作椅子的各部分——坐垫，椅子腿，靠背，等 等——而后用正确的方法钉起来，那么制作一把椅子是很容易的。但这取决于将木板与插接口结合起来的能力。如果缺乏这种能力，那么制作椅子的唯一方式，就是 将它从一大块木头里整个地切割出来，这是一项艰巨得多的任务。这个例子同时表明了模块化的非凡威力与拥有合适的黏合剂的重要性。 现在让我 们回到函数式程序设计上来。在这篇论文余下的部分里，我们将指出，函数式语言提供了两种新的、非常重要的黏合剂。我们将给出许多可以使用新方法模块化的示 例程序，它们因此变得很简洁。这就是函数式程序设计威力的关键——它允许了大幅改进的模块化设计。这也正是函数式程序员必须追求的目标——更小、更简洁、 更通用的模块，用我们将要描述的新黏合剂黏合起来。 －－－－－－－－－－－－－－－－－－－－ 3 把函数粘起来 两种黏合剂中的第一种，使简单的函数可以聚合起来形成复杂的函数。以一个简单的处理问题来说明：将列表中的元素累加起来。我们用下面的语句定义列表： listof X :: = nil | cons X (listof X) 这 说明，一个元素类型为X的列表（不论X是什么），或是nil，代表一个没有元素的空列表，或是一个X与另一个X的列表的cons。cons代表一个列表， 其首元素为X，而第二个以及后续元素即是另一个X的列表的元素。此处的X可以代表任何类型——例如，如果X是一个“Integer”（整数类型），那么这 个定义就是说，一个整数列表，或者是空的，或者是一个整数与另一个整数列表的cons。依照通常的实践，我们写列表时，只是简单地将其元素包含在方括号 里，而不是将cons和nil显式地写出来。方便起见，这是一个简单的速记法。例如： [] 表示 nil[1] 表示 cons 1 nil[1 2 3] 表示 cons 1 ( cons 2 ( cons 3 nil )) 列表中的元素可以通过一个递归函数sum进行累加。sum必须为两类参数进行定义：一个空列表（nil），以及一个cons。由于没有数字存在时，累加结果是0，因此我们定义： sum nil = 0 又因为cons的累加和可以通过将列表的第一个元素加到其余元素的累加和上的方式进行计算，所以可以定义： sum (cons num list) = num + sum list 检查定义可以发现，计算sum时，只有下面用*标出的部分是特化的：［me：原文用的是方框，在这里小偷一下懒…… :)］ sum nil = 0 sum (cons num list) = num + sum list 这说明sum的计算可以通过一个通用的递归模式和特化的部分来模块化。这个递归模式习惯上被称为“递减”（reduce），因此sum可以表达为： sum = reduce add 0 方便起见，reduce传递了一个二元函数add而不是一个运算符。add是这样定义的： add x y = x + y 只要将sum的定义参数化，我们便可以得到reduce的定义，即： (reduce f x) nil = x(reduce f x)(cons a l) = f a ((reduce f x) l) ［me：注意到了吗？这就是Haskell中的foldr啊……］ 这 里我们写出了(reduce f x)两边的括号以强调它代替了sum。习惯上括号是省略的，因此 ((reduce f x) l)写作(reduce f x l)。一个三元函数如reduce，当只提供两个参数时，将成为关于那个余下参数的一元函数。一般地，对一个n元函数，提供了m(&lt; n)个参数后，该函数便成为了关于余下的n-m个参数的函数。我们在下文中将遵守这一约定。 用这种方式将sum模块化之后，我们就可以通过对这部分的重用来收获福利了。最有趣的部分就是，reduce可以（直接）用于编写一个函数来计算列表中元素的累乘积，而不需要更多的编程步骤： product = reduce multiply 1 它也可以用来测试一个布尔值的列表中是否至少有一个元素为真： anytrue = reduce or false 或者它们是否都为真： alltrue = reduce and true 理解(reduce f a)的一种方式是，将其看作一个将列表中的所有cons替换为f，将所有nil替换为a的函数。以列表[1,2,3]为例，既然它表示： cons 1 (cons 2 (cons 3 nil)) 那么(reduce add 0)将其转换为： add 1 (add 2 (add 3 0)) = 6 而(reduce multiply 1)将其转换为： multiply 1 (mulitiply 2 (mulitiply 3 1)) = 6 于是，很明显地，(reduce cons nil)将复制列表本身。既然将一个列表追加到另一个列表上的方式是将前一个列表的元素cons到后一个列表前部，我们便得到： append a b = reduce cons b a 例如： append [1,2] [3,4] = reduce cons [3,4] [1,2] = (reduce cons [3,4]) (cons 1 ( cons 2 nil )) = cons 1 ( cons 2 [3,4])) （将cons替换为cons，将nil替换为[3,4]） ＝ [1,2,3,4] 一个用于将列表中全部元素翻倍的函数可以写作： doubleall = reduce doubleandcons nil其中 doubleandcons num list = cons ( 2*num ) list doubleandcons可以进一步模块化，首先分解为： doubleandcons = fandcons double其中 double n = 2*n fandcons f el list = cons (f el) list 继续分解： fandcons f = cons . f 其中“.”（函数复合，一个标准运算符）定义为： (f . g) h = f(g h) ［me：注意这是函数的左复合，可能与你在离散数学课上学到的“右复合”相反。］ 为证明fandcons的定义是正确的，我们代入一些参数： fandcons f el = (cons . f) el = cons (f el)因此 fandcons f el list = cons (f el) list 最终得到的版本是： doubleall = reduce (cons . double) nil 继续模块化，我们得到： doubleall = map doublemap f = reduce (cons . f) nil 其中map使任意的函数作用于列表的全部元素之上。map是另一个很通用的函数。 我们甚至可以写出一个函数累加矩阵中的所有元素，该矩阵用列表的列表表示。这个函数是： summatrix = sum . map sum map sum使用函数sum分别计算所有行的元素之和，而后最左边的sum将每一行的元素之和累加起来，从而得到整个矩阵的累加和。 这 些例子应该已经足以使读者确信，一点模块化的努力可以产生很大的效果。通过将一个简单的函数（sum）模块化为一个“高阶函数”与一些简单参数的聚合，我 们得到了一个部件（reduce），它可以用于编写与列表有关的许多函数，而又不再需要（更多的）编程努力。不止是对有关列表的函数可以这么干，举另外一 个例子，考虑数据类型“有序标记树”，其定义是： treeof X ::= node X (listof (treeof X)) 这个定义表明，一棵X的树，由一个标记类型为X的结点（node），以及一个子树列表组成，而这些子树也是X的树。例如，树： 1 o /\\ / \\ / \\ 2 o o 3 | | | o 4 可以被表示成： node 1 (cons (node 2 nil) (cons (node 3 (cons (node 4 nil) nil)) nil)) 我 们不再给出一个函数例子并将它抽象为高阶函数，取而代之的是，直接给出一个类似于reduce的函数redtree。回忆一下，reduce有两个参数， 一个用于取代cons，另一个用于取代nil。既然树由node，cons和nil组成，那么redtree必须有三个参数——用于分别取代上述三者。由 于树和列表不是同一种类型，我们得定义两个函数分别处理它们。因此我们定义： redtree f g a (node label subtrees) = f label (redtree’ f g a subtrees )redtree’ f g a (cons subtree rest) = g (redtree f g a subtree) (redtree’ f g a rest)redtree’ f g a nil = a ［me：这相当于f取代node，g取代cons，a取代nil。:)］ 很多有趣的函数都可以通过把redtree和其他函数粘起来的方法来定义。例如，要把一棵数字树上的所有标记累加起来，可以使用： sumtree = redtree add add 0 以我们刚才表述的那棵树为例，sumtree展开成： add 1 (add (add 2 0) (add (add 3 (add (add 4 0) 0)) 0))= 10 要生成一个包含树中全部标记的列表，可以用： labels = redtree cons append nil 仍然是那个例子，得到： cons 1 (append (cons 2 nil) (append (cons 3 (append (cons 4 nil) nil)) nil))= [1,2,3,4] 最后，可以定义一个类似于map的函数，此函数使函数f作用于树中的全部标记上： maptree f = redtree (node . f) cons nil 以 上这些操作之所以可行，是因为函数式语言允许将传统型语言中不可分解的函数表达为一些部件的聚合——也就是一个泛化的高阶函数与一些特化函数的聚合。这样 的高阶函数一旦定义，便使得很多操作都可以很容易地编写出来。不论何时，只要一个新的数据类型被定义，就应当同时定义用于处理这种数据的高阶函数。这样就 简化了对数据类型的处理，同时也将与它的表示细节相关的知识局部化了。［me：个人感觉这相当于OO里的封装。］与（函数式语言）最相像的传统程序语言是 可扩展语言——只要有需求，这种程序语言就好像随时都可以扩展出新的控制结构一样。［me：原文是The best analogy with conventional programming is with extensible languages - it is as though the programming language can be extended with new control structures whenever desired.不太有把握……］ －－－－－－－－－－－－－－－－－－－－ 4 把程序粘起来 函数式语言提供的另一种黏合剂使得所有程序都可以粘在一起。回忆一下，一个完整的函数式程序只不过是一个从输入映射到输出的函数。如果f和g是这样的程序，那么对程序(g.f)当提供了输入参数input之后，得到： g (f input) 程 序f计算自身的输出，此输出被用作程序g的输入。传统上，这是通过将f的输出储存在临时文件中实现的。这种方法的毛病是，临时文件可能会占用太大的空间， 以至于将程序黏合起来变得很不现实。［me：但也不要忘了神奇的Unix管道……也许管道就是下面说的这种方法的另一个实现？:)］函数式语言提供了一种 解决方案。程序f和g严格地同步运行，只有当g试图读取输入时，f才启动，并且只运行足够的时间，恰好可以提供g需要读取的输出数据。而后f将被挂起，g 将继续执行，直到它试图读取另一个输入。一个额外的好处是，如果g没有读取完f的全部输出就终止了，那么f也将被终止。f甚至可以是一个不会（自行）终止 的程序，它可以产生无穷多的输出（而不会出现问题），因为当g运行结束时，f也将被强行终止。这就使得终止条件可以与循环体分离——一种强大的模块化形式。 这 种求值方式使得f尽可能地少运行，因此被称为“惰性求值”。它使得将程序模块化为一个产生大量可能解的生成器与一个选取恰当解的选择器的方案变得可行。有 些其他的系统也允许程序以这种方式运行，［me：看来就是说的管道啦！］但只有函数式语言对每一个函数调用都一律使用惰性求值，使得程序的每个部分都可以 用这种方式模块化。惰性求值也许是函数式程序员的拿手利器中威力最大的模块化工具。 4.1 牛顿－拉夫森求根法 我们将编写一些数值算法以展现惰性求值的威力。首先，考虑用于求解平方根的牛顿－拉夫森算法。该算法从一个初始的近似值a0开始计算数N的平方根，为了求得更好的解，它使用下述规则： a(n+1) = (a(n) + N/a(n)) / 2 如果近似值序列趋近于某一个极限a，那么 a = (a + N/a) / 2 故 2a = a + N/a a = N/a a*a = N a = squareroot(N) 事实上，这个近似值序列确实迅速地趋近于一个极限。平方根算法取一个允许误差（eps）为参数，当两个相邻的近似值之差（的绝对值）小于eps时，算法便终止了。 这个算法通常被编写为类似下面这样： C N IS CALLED ZN HERE SO THAT IT HAS THE RIGHT TYPE X = A0 Y = A0 + 2.*EPSC THE VALUE OF Y DOES NOT MATTER SO LONG AS ABS(X-Y).GT.EPS100 IF (ABS(X-Y).LE.EPS) GOTO 200 Y = X X = (X + ZN/X) / 2200 CONTINUEC THE SQUARE ROOT OF ZN IS NOW IN X ［me：这是一段FORTRAN的程序，C代表注释行，保留不翻译。.LE.是“Less than or Equal to”（小于或等于）的缩写，同理.GT.是“大于”的意思。] 在传统型语言中，这个程序是不可分解的。我们将利用惰性求值将其化为更加模块化的形式，而后演示所生成部件的一些其他用途。 由于牛顿－拉夫森算法计算的是一个近似值的序列，故将它写作一个使用近似值列表的程序就再自然不过了。每个近似值都可以通过下面的函数从前一个值计算得到： next N x = (x + N/x) / 2 因此(next N)是从一个近似值映射到下一个值的函数。调用函数f，得到近似值序列： [a0, f a0, f(f a0), f(f(f a0)), …] 我们可以定义一个函数来计算：［me：这是通用的迭代计算。］ repeat f a = cons a (repeat f (f a)) 因此 近似值序列可以这样计算： repeat (next N) a0 repeat是一个具有“无穷”输出的函数的例子——但这没关系，因为超出程序其余部分需求的近似值并不会被计算。无穷性只是潜在的：它只说明，只要有需求，就可以计算出任意数量的近似值，repeat本身不会强加任何限制。 求根函数的剩余部分是函数within，它取一个允许误差与一个近似值列表作为参数，并在列表中查找差值不超过允许误差的一对相邻的近似值。这个函数可以定义为： within eps (cons a (cons b rest)) = = b, if abs(a-b) &lt;= eps = within eps (cons b rest), otherwise 将这两个部件结合起来， sqrt a0 eps N = within eps (repeat (next N) a0) 现 在我们得到了求根函数的两大部件，便可以尝试用不同的方式组合它们。将要进行的修改之一，是将判断条件改为“相邻近似值的比趋近1”而不是“差趋近0”。 这对于非常小的数字而言更加合适（当初始的相邻近似值之间的差值很小时），对非常大的数字也是如此（当舍尾产生的误差比允许误差大很多时）。我们只需要定 义一个函数来替换within： relative eps (cons a (cons b rest)) = = b, if abs(a-b) &lt;= eps*abs b = relative eps (cons b rest), otherwise ［me：注意：relative里的eps与within里的eps定义是不同的！前者是绝对误差后者是相对误差！］ 而并不需要改写生成近似值的部件。 4.2 数值微分 我们已经重用了平方根近似值序列，当然，对函数within和relative的重用也是可能的，它们能够与任何一个生成近似值序列的数值算法配合。我们将这样来编写数值微分算法。 函数在某一点的微分，便是其图象在该点的斜率。通过分别计算函数在该点与一个临近点处的取值，而后计算两点连线斜率的方法，可以很容易地估计出微分的值。这基于一个假定：如果这两点靠得足够近，那么函数图象在两点之间不会弯曲得很厉害。于是有下述定义： easydiff f x h = (f(x+h)-f x) / h 为 了得到良好的近似值，h应该很小。不幸的是，如果h太小，那么f(x+h)与f(x)会相当接近，因此在相减过程中产生的舍尾误差可能会掩盖了计算结果。 如何为h选取恰当的值呢？解决这个矛盾一种方案是从一个合理的较大取值开始，不断减小h的值，并求出一个（微分的）近似值序列。这个序列将趋近于该点的导 数，但最终会由于舍尾误差的存在而不可救药地变得不精确。如果我们用(within eps)来选取第一个足够精确的近似值，那么舍尾误差影响结果的风险将会大大降低。我们需要一个函数来计算这个序列： differentiate h0 f x = map (easydiff f x) (repeat halve h0)halve x = x/2 此处h0是h的初值，而后继取值是通过不断减半得到的。通过这个函数，任意点处的导数可以这样计算： within eps (differentiate h0 f x) 但是，甚至这个方案也不是那么令人满意的，因为近似值序列收敛得相当慢。解决这个问题需要一点数学知识，序列中的元素可以记为： （微分的）精确值 ＋ 一个关于h的误差项 理论表明，该误差项与h的某一次幂大致成正比，因此当h减小时，误差也会减小。设精确值为A，而误差项为B*hn [me：是求幂运算符］。由于计算每个近似值时所用的h取值是下一个的两倍，故任意两个连续的近似值可以表示成： a(i) = A + B(2**n)(hn)a(i+1) = A + B*(hn) 现在就可以消去误差项了，我们得到： a(i+1)*(2n) - a(i)A=———————- 2n - 1 当然，误差项只不过“大致”与h的某一次幂（成正比），因此这个结论也是近似的。但这是一个好得多的近似。这一改进可以通过下述函数作用于所有相邻的近似值对之上： elimerror n (cons a (cons b rest)) = = cons ((b*(2n)-a)/(2n-1)) (elimerror n (cons b rest)) 从一个近似值序列中消除误差项的操作产生了另一个收敛速度快得多的序列。 使用elimerror之前还有一个问题需要解决——我们必须知道n的正确值。通常这个值很难预测，但却很容易衡量。不难验证，下述函数能够正确地消除误差项，但在此我们并不给出证明。 order (cons a (cons b (cons c rest))) = = round(log2( (a-c)/(b-c) - 1 ))round x = 最接近x的整数log2 x = x以2为底的对数 现在，一个通用的近似值序列优化函数可以定义为： improve s = elimerror (order s) s 使用improve能够更加高效地计算函数f的导数，如下： within eps (improve (differentiate h0 f x)) improve只对利用一个不断减半的参数h计算得到的近似值序列适用。但是，如果improve作用于这样的序列，那么其结果也是一个这样的序列！这意味着一个近似值序列可以优化不止一次。每一次优化的过程中，都有一个不同的误差项被消除，因此优化产生的序列收敛得越来越快。因此，可以非常高效地计算导数： within eps (improve (improve (improve (differentiate h0 f x)) 从数值分析的角度讲，这似乎是一个“第四阶方法”［me：fourth order method，我还没有学数值分析，不会翻译……］，可以迅速地给出准确的结果。甚至可以定义： super s = map second (repeat improve s)second (cons a (cons b rest)) = b super 函数使用repeat improve来生成一个不断被优化的近似值的序列的序列。［me：就是说，生成一个序列，其中每一个元素是一个近似值序列，而这个元素是用前一个元素优 化得到的。］同时，super提取出每个近似值序列中的第二个元素，构造出一个新的序列（已经确认，第二元素是最佳选择——它比首元更精确，而且不需要额 外的计算）。这个算法的确非常复杂——更多的近似值被计算的同时，它使用了不断优化的数值方法。可以用下面的程序非常非常高效地计算导数： within eps (super (differentiate h0 f x)) 这个案例可能就像是用大锤敲碎坚果一样（大材小用），但关键是，甚至一个像super一样复杂的函数，当被惰性求值的方法模块化时，也会变得很容易表达。 4.3 数值积分 在 这一部分我们将讨论的最后一个例子是数值积分。问题的描述很简单：给出一个返回实数，并有一元实数参数的函数，以及两个端点a和b，估算两点之间曲线f下 方的面积。［me：感觉不够准确……可能我对under和area的理解错了？］估算面积的最简单方法是假定f趋近于直线，此时面积就是： easyintegrate f a b = (f a + f b)*(b-a)/2 不 幸的是，除非a与b足够接近，否则这个估算似乎非常不精确。更好的估算方法是，将a与b之间的区间分为两段，分别估算子区间上的面积，再将结果加起来。我 们可以定义一个不断趋近于准确值的积分近似值序列，首先使用上述方程进行第一次近似，而后将分别趋近于两个子区间上的子积分准确值的（两个）近似值累加起 来以得到新的（积分总体的）近似值。［me：翻译有点乱，简单说，二分法。］计算这个序列可以使用函数： intergrate f a b = cons (easyintergrate f a b) (map addpair (zip (intergrate f a mid) (intergrate f mid b))) 式中 mid = (a+b)/2 zip是另一个标准的表处理函数。它读取两个列表，并返回一个有序对的列表，每个有序对由两个输入列表中对应的元素组成。从而第一对由列表一和列表二的首元组成，第二对由列表一和列表二的第二个元素组成，以此类推。zip可以定义为： zip (cons a s) (cons b t) = cons (pair a b) (zip s t) 在函数intergrate中，zip用于生成由两个子区间上相对应的积分近似值对组成的列表，而map addpair用于将有序对中的元素相加，从而生成一个原积分的近似值列表。 实 际上，这个版本的intergrate函数相当低效，因为它持续不断地重复计算f的值。就像所写的一样，easyintergrate计算了f在a和b两 处的值，而对intergrate的递归调用将重复计算它们。同样的，(f mid)也在递归调用中重复计算了。因此，更可取的是下述从不重复计算f的版本： intergrate f a b = interg f a b (f a) (f b)integ f a b fa fb = cons ((fa+fb)*(b-a)/2) (map addpair (zip (interg f a m fa fm) (interg f m b fm fb))) 式中 m = (a+b)/2 fm = f m integrate给出了一个不断趋近准确值的积分近似值列表，正如differentiate在上一小节中所做的一样。因此可以写出计算式以求出所需任意精度的积分值，如下： within eps (intergrate f a b)relative eps (integrate f a b) 这 个积分算法与上一小节中的第一个微分算法有着同样的缺点——它收敛得相当慢。序列中的第一个近似值仅仅用了两个相距(a-b)的点来计算（通过 easyintergrate）。第二个近似值也（除了a、b之外）用到了中点，因此相邻两点之间的间距仅为(b-a)/2。第三个近似值在两个子区间上 作同样的处理，因此间距仅为(b-a)/4。很清楚，每个近似值对应的相邻两点之间的间距在计算下一个值时被减半了。将这一间距看作“h”，那么这个序列 就可以成为上一小节中定义的“improve”函数的优化对象了。因此我们可以写出（函数来计算）快速收敛的积分近似值序列，例如： super (intergrate sin 0 4) improve (intergrate f 0 1)式中 f x = 1/(1+x*x) （后一个序列是用于计算pi/4的“第八阶方法”［me：……］。其中的第二个近似值只需要计算5次f的取值，但却具有5位准确数字。） 在 本节中我们选取了一些数值算法并将它们函数化地编写出来，把惰性求值当做了黏合部件的黏合剂。由于惰性求值的存在，使得我们可以用很多新的方式来模块化这 些算法，从而产生用途广泛的函数，例如within，relative和improve。通过这些部件的不同组合，我们简单而明了地编写出了一些相当不错 的数值算法。 －－－－－－－－－－－－－－－－－－－－ 5 人工智能中的例子 我们已经指出，函数式语言威力强大主要是因为它们提供了两种新的黏合剂：高阶函数和惰性求值。在本节中，我们将讨论人工智能中一个大一点的实例，并演示如何使用这两种黏合剂来十分简单地编写它。 我们选取的实例是alpha-beta“启发式搜索”，一个用于估计游戏者所处形势好坏的算法。该算法预测游戏局势的可能发展，但会避免对无意义局势的进一步探究。 令游戏局势使用“position”类型的对象来表示。这个类型依据游戏的不同而不同，我们不对此作任何假定。必然有一种方法可以知晓对某一个局势能够采取的行动：假定有一个函数： moves: position -&gt; listof position 该函数以一个游戏局势为参数，并返回一个可以由自变量出发，通过一步行动而形成的position的列表。以noughts and crosses游戏（tic-tac-toe）为例： | | x| | |x| | | -+-+- -+-+- -+-+- -+-+- moves | | = [ | | , | | , |x| ] -+-+- -+-+- -+-+- -+-+- | | | | | | | | | | o| | |o| -+-+- -+-+- -+-+- moves |x| = [ |x| , |x| ] -+-+- -+-+- -+-+- | | | | | | 这个函数假定通过当前局势总是可以判定现在是哪位游戏者的回合。在noughts and crosses中，可以通过数出“0”与“X”的数目来做到这一点。在类似于象棋的游戏中，可能必须在“position”类型中显式包含这一信息。 利 用函数moves，第一步是构造一棵博弈树。这棵树的结点都用局势来标记，而一个结点的子结点用从该结点一步便可到达的局势标记。也就是说，如果一个结点 标记为局势p，那么它的子结点将使用(moves p)中的局势来标记。一棵博弈树完全有可能是无穷的，如果这个游戏可以在双方都不胜的情形下永远进行下去的话。博弈树与第2节中讨论的树完全类似——每个 结点都有一个标记（它所代表的局势）与一个子结点列表。因此我们可以使用相同的数据类型来表示它们。 博弈树是通过反复运用moves而构造出来的。构造从根局势开始，moves用于生成根结点处子树的标记，而后moves被用于生成子树的子树，依此类推。这一递归模式可以用一个高阶函数表示： reptree f a = node a (map (reptree f) (f a)) 使用这个函数可以定义另一个函数，该函数从一个特定的局势开始生成博弈树： gametree p = reptree moves p 例如图1所示。此处使用的高阶函数(reptree）与上一节中用于构造无穷列表的函数repeat是类似的。 | | -+-+- gametree | | -+-+- | | | | -+-+-= | | -+-+- | | / | \\ / | \\ / | \\ / | \\ / | \\ / | \\ X| | |X| | | -+-+- -+-+- -+-+- | | | | |X| -+-+- -+-+- -+-+- | | | | | | /|\\ /|\\ /\\ … … / \\ / \\ / \\ O| | |O| -+-+- -+-+- |X| |X| -+-+- -+-+- | | | | /|\\ /|\\ … … 图1： 一棵博弈树的实例 alpha- beta算法从一个给定的局势出发，就游戏的发展将会是有利还是不利作出判断。然而，要做到这一点，它必须能够在不考虑下一步的情况下粗略地估计某一个局 势的“价值”。在后继局势不可预测时必须使用这一函数，它也可以用来对算法进行先期引导。静态估价的结果是从计算机的角度考虑的，是对该局势的前途的度量 （假设在游戏中计算机与人对抗）。结果越大，局势对计算机而言越好。结果越小，局势越糟。最简单的此类函数将会，比如说，对计算机确定胜利的局势返 回+1，对计算机确定失败的局势返回-1，而对其它的局势返回0。在现实中，静态估价函数会衡量各种使局势“看上去不错”的因素。例如，具体的好处，以及 象棋中对中心的控制。假定有这样一个函数： static: position -&gt; number 既然一棵博弈树是一个(treeof position)，那么它就可以被函数(maptree static)转换为一个(treeof number)，该函数对树中所有的（也许是无穷多个）局势进行静态估价。此处使用了第2节中定义的函数maptree。 给 出一棵静态估价树之后，其中各个局势的真值究竟是多大？特别地，对根局势应该赋予什么值？不是它的静态值，因为那只是一个粗略的猜测。一个结点被赋予的 值，必须由其子结点的真值决定。这一过程的完成，基于每个游戏者都会选择对自己最有利的行动的假定。回忆一下，高值意味着计算机的有利形势。很明显，当计 算机从任意的局势开始下一步行动时，它将选择通往真值最高的子结点的行动。类似地，对手将会选择通往真值最低的子结点的行动。假定计算机与其对手轮流行 动，那么当轮到计算机行动时，节点的真值用函数maximise计算，反之用minimise计算。 ［me：所谓“真值”（true value），可能是我翻译得不好，此处理解为类似“真正的价值”的意思吧，是一个量度，不是逻辑学里的0和1哦。］ maximise (node n sub) = max (map minimise sub)minimise (node n sub) = min (map maximise sub) 此 处max和min是关于列表的函数，分别返回列表中元素的最大值与最小值。上述定义是不完整的，因为它们将永远递归下去——没有给出边界情形。我们必须定 义没有后继的结点的值（其标记）。因此静态估价用于任一游戏者胜利或者后继局势不可预测的情况下。maximise与minimise的完整定义是： maximise (node n nil) = nmaximise (node n sub) = max (map minimise sub)maximise (node n nil) = nmaximise (node n sub) = min (map minimise sub) 在这个阶段，几乎已经可以写出一个取一个局势作为参数并返回其真值的函数了。可能是： evaluate = maximise . maptree static . gametree 这 个定义有两个问题。首先，它不适用于无穷树。maximise不断地递归直到找到一个没有子树的结点——树的端点。［me：还是叫叶结点习惯啊……］如果 没有端点那么maximise就不会返回结果。第二个问题与第一个有关——甚至有穷的博弈树（如noughts and crosses里的那棵）事实上也可能相当大。估价整棵博弈树是不现实的——搜索必须被限定在接下去的几步之内。为此可以将树剪至一个固定的深度： prune 0 (node a x) = node a nilprune n (node a x) = node a (map (prune (n-1)) x) (prune n)取一棵树作为参数并“剪去”与根结点的距离超过n的所有结点。如果一棵博弈树被剪枝，那么将强制maximise对深度为n的结点执行静态估价而不是进一步递归。因此evaluate可以被定义为： evaluate = maximise . maptree static . prune 5 . gametree 这将考虑其后（比如说）5步的形势。 在 此开发过程中我们已经使用了高阶函数与惰性求值。高阶函数reptree和maptree使得我们能够很容易地构造与处理博弈树。更重要的是，惰性求值确 保了我们可以使用这种方式模块化evaluate。由于博弈树具有潜在的无穷结果，在没有惰性求值的情况下，程序将永远不会终止。我们将不能写： prune 5 . gametree 而不得不将这两个函数整合成一个只构造树的前五层的函数。更糟糕的是，甚至那前五层都可能已经太大以至于无法在同一时间内存储于内存中。而在我们所写的程序中，函数 maptree static . prune 5 . gametree 只 是构造出了树中maximise所需的部分。由于每一部分都可以在被maximise处理完之后丢弃（被垃圾收集器回收），故完整的树从来没有存储于内存 中。只有树的一小部分在某一段时间内被储存着。因此这个惰性程序很有效率。这一效率取决于maximise（组合链上的最后一个函数）与 gametree（第一个函数）的相互作用，因此在没有惰性求值的情况下，要完成任务，只能将组合链上的所有函数整合成一个大函数。这是对模块化的强烈破 坏，但也是通常的做法。通过单独修补每个部件，我们就可以优化估价算法——这相对简单。而一个传统型程序员必须把整个程序作为一个单元来修改，这就困难多 了。 到目前为止，我们只是描述了简单的对最大最小值的处理（minimaxing）。但alpha-beta算法的核心是“计算maximise与minimise的值时常常不需要考虑整棵树”这一观察结果。考虑树： max / \\ / \\ / \\ / \\ min min / \\ / \\ / \\ / \\ 1 2 0 ? 相当奇怪地，为了估价这棵树，并不需要知道问号处的值。左子树的最小值是1，但右子树的最小值显然是一个小于或等于0的值。因此这两个最小值的最大值必然是1。这一观察结果可以被泛化并内建到maximise和minimise之中。 第一步是将maximise拆分成max对一个数字列表的作用。也就是，将maximise分解为： maximise = max . maximise’ （minimise 可以用类似的方法分解。由于maximise和minimise是完全对称的，故我们将只讨论maximise，而假定minimise也照此处理。）一 旦这样分解之后，maximise可以使用minimise’来发现minimise将对哪些数字求最小值，并且不再使用minimise本身。而后便可 以在不查看某些数字的情况下便将它们丢弃。由于惰性求值的存在，如果maxmise并不会查看所有的数字列表，那么一部分列表将不会被计算，这是对计算机 时间的潜在节约。 将max从maximise中“约分出来”是很简单的，得到： maximise’ (node n nil) = cons n nilmaximise’ (node n l) = map minimise l = map (min . minimise’) l = map min (map minimise’ l) = mapmin (map minimise’ l)式中 mapmin = map min 由 于minimise’ 返回一个数字列表，而这个列表的最小值是minimise的结果，故(map minimise’ l)返回一个数字列表的列表。Maximise’应该返回这些列表中每个列表的最小值组成的列表，但只有其中［Maximise的返回值中］的最大值才有 用。我们应该定义一个mapmin的新版本以忽略那些最小值不重要的列表［在(map minimise’ l)的返回值中］的最小值。 mapmin (cons nums rest) = = cons (min nums) (omit (min nums) rest) 函数omit传递一个“潜在的最大值”——当前所发现的最小值中最大的一个——并忽略任何比该值小的最小值。 omit pot nil = nilomit pot (cons nums rest) = = omit pot rest, if minleq nums pot = cons (min nums) (omit (min nums) rest), otherwise minleq 以一个数字列表和一个潜在最大值为参数，如果列表的最小值小于或等于潜在最大值就返回真。要完成这一工作，它并不需要扫描整个列表！如果列表中有任意一个 元素小于或等于潜在最大值，那么列表的最小值肯定也是如此。该特别元素之后的所有元素都是无关紧要的——它们就像是上面例子中的问号一样。因此 minleq可以被定义为： minleq nil pot = falseminleq (cons num rest) port = true, if num&lt;=pot = minleq rest pot, otherwise 如是定义了maximise’和minimise’之后，要写出一个新的估价函数就很简单了： evaluate = max . maximise’ . maptree static . prune 8 . gametree 由于惰性求值的存在，使得maximise’只查看树的更小部分，这意味着整个程序会更加高效，正如prune只查看无穷树的一部分使得程序可以终止一样。对maxmise’的优化，尽管相当简单，却能对运算的速度产生戏剧性的效果。因此也使得估价函数可以看得更远。 ［me： 刚看完的时候想，maximise’干嘛还要返回一个包含了那个最大值的列表呢，这既然很显然会是一个升序表，那么只要保留pot遍历完了直接当最大值返 回不就结了……然后发现那样的话在返回值上和maximise就一样了啊……而且参数也一样，那不就是maximise了嘛……那我们还在这里搞什么 呢？:)］ 对估价函数还可以进行其它优化。例如，alpha-beta算法在最佳行动被最先考虑时，能够将工作描述得（进行得？）最好， 因为如果有一方发现了一着妙棋，那就没必要再考虑较差的行动了，除非他证明对手至少能有一种很好的回应方式。因此可能会希望对每一个结点的子树进行排序， 当计算机行动时将最高值放在第一，而人行动时则相反。这可以使用函数： highfirst (node n sub) = node n (sort higher (map lowfirst sub))lowfirst (node n sub) = node n (sort (not.higher) (map highfirst sub))higher (node n1 sub1)(node n2 sub2) = n1&gt;n2 此处sort是多用途排序函数。现在估价函数定义为： evaluate = max . maximise’ . highfirst . maptree static . prune 8 . gametree ［me：我一开始没想明白为什么highfirst是对静态估价产生的树排序，而不是根据真值树排序呢？后来才想起来根本就不存在返回真值树的函数啊……:)］ 也可能认为，为了限制搜索，只要考虑计算机或者对手的前三个最佳行动也已经足够了。要编写这样的程序，只需要把highfirst换成(taketree 3 . highfirst)，其中： taketree n = redtree (nodett n) cons nilnodett n label sub = node label (take n sub) taketree 将树上所有的结点替换为最多有n个子结点的结点，它使用了函数(take n)，而该函数返回列表的前n个元素（如果列表比n短，那么返回的元素就少一些）。 另 一种优化是对剪枝的改良。上述程序甚至在局势非常dynamic［me：晕……“动态”？实在不知道怎么翻译了……难道是“明朗”？］的情形下也会向前搜 索固定的深度——（但是，）例如在国际象棋中，一旦皇后被威胁，也许就可以决定不再搜索了。通常可以定义某些“dynamic”的形势，并在遇到这样的结 点之一时，不再继续搜索而停止。假定有函数“dyramic”用以确定这样的形势，那么只需要为prune追加一个定义等式： prune 0 (node pos sub) = node pos (map (prune 0) sub), if dynamic pos [me：原文如此，但大伙儿不觉得那开头的prune 0应该是prune n吗？］ 在 像这个程序一样模块化的程序里，作出这样的改动是很简单的。如前所述，这个程序的效率，关键是由链中的最后一个函数maximise与第一个函数 gametree的相互作用决定的，因此若没有惰性求值，就只能写成一个单一的程序。这样的程序难于编写，难于修改，而且，非常难于理解。 －－－－－－－－－－－－－－－－－－－－ 6 结论 在 本论文中，我们指出，模块化是成功的程序设计的关键。以提高生产力为目标的程序语言，必须良好地支持模块化程序设计。但是，新的作用域规则和分块编译的技 巧是不够的——“模块化”不仅仅意味着“模块”。我们分解程序的能力直接取决于将解决方案粘在一起的能力。为了协助模块化程序设计，程序语言必须提供优良 的黏合剂。函数式程序语言提供了两种新的黏合剂——高阶函数与惰性求值。利用这些黏合剂可以将程序用新的、令人激动的方式模块化，对此我们举出了很多实 例。越小、越通用的模块越可能被广泛地重用，使后续的程序设计工作变得简单。这解释了为什么函数式程序与传统型程序比较，要小得多，也容易编写得多。它也 为函数式程序员提供了一个追求目标。如果程序的任何部分是杂乱或者复杂的，那么程序员就应当尝试将其模块化并泛化其部件。他应当期望把高阶函数和惰性求值 用作他做此事的工具。 当然，我们并不是指出高阶函数与惰性求值的力与美的第一人。例如，Turner展示了这两者如何在一个生成化学结构 的程序里大显身手［Tur81］。Abelson和Sussman强调“流”（惰性列表）是构架程序的强大工具［AS86］。Henderson使用了流 来构架函数式操作系统［P.H82］。本论文的主要贡献是，断言了模块化自身，便是函数式语言强大威力的关键。 这与当前有关惰性求值的论 战也有关联。有些人认为函数式语言应当是惰性的，而其他人认为不是这样。有些人走折衷路线，只提供惰性列表以及用于构造它们的特殊语法（例如，在 SCHEME中［AS86］）。本论文提供了更进一步的证据，证明惰性求值非常重要以至于不能被降为二等公民。这也许是函数式程序员所拥有的最强大的黏合 剂。人们不应当阻碍对这样一个极为重要的工具的使用。 －－－－－－－－－－－－－－－－－－－－ 致谢 在 牛津程序设计研究组与Phil Wadler和Richard Bird的多次交谈对本论文的写作帮助甚大。约特堡查麦兹大学的Magnus Bondesson指出了一个数值算法的早期版本中的严重错误，同时也协助了很多其他算法的开发。本论文在英国科学与工程研究评议会提供的研究基金赞助下 发表。 －－－－－－－－－－－－－－－－－－－－ 参考文献 [AS86] H.Abelson,G.J.Sussman. 计算机程序的构造与解释. 麻省理工学院出版社,波士顿,1986 [Hug89] J.Hughes. 函数式程序设计为什么至关重要. 计算机月刊,32(2),1989 [Hug90] John Hughes. 函数式程序设计为什么至关重要. D.Turner主编,函数式编程的研究主题. Addison Wesley,1990 [MTH90] R.Milner,M.Tofte,R.Harper. Standard ML的定义. 麻省理工学院出版社,1990 [oD80] 美利坚合众国国防部. 程序语言Ada参考手册. Springer-Verlag,1980 [P.H82] P.Henderson. 纯函数式操作系统. 1982 [Tur81] D.A.Turner. 应用语言在语义上的优雅性. 1981年度函数式语言与计算机架构会议会报,海边温特渥,普茨茅斯,新汉普夏郡,1981 [Tur85] D.A.Turner. Miranda: 拥有多态类型的非严格语言. 1985年度函数式语言与计算机架构会议会报,1-16页,南锡,法国,1985 [Wir82] N.Wirth. Modula-II程序设计. Springer-Verlag,1982","link":"/sicp/20190421_whyfp.html"},{"title":"为什么函数式编程至关重要","text":"函数式程序的特点 函数式编程不包含任何赋值语句（也就是没有变量），所有的值从一开始就确定了 函数式编程不包含副作用，除了计数它本身的值以外不产生任何副作用，这一特性消灭了bug的一个主要来源 函数式编程值是一定的，那么执行顺序就不在重要，所以它可以在任何时候被执行，这一过程将程序员从控制流中解放 由于在任意时候求值，程序员可以随性所欲的用变量值来代替变量表达式，反之也可以用变量表达式代替变量的值。程序是引用透明，可以更容易的数学化控制 函数是一等公民，函数式编程中努力用函数来表达所有的概念，完成所有的操作 变量的不变性，赋值操作低人一等。简单将在scala函数是编程中只用val，不用var 函数式编程比传统编程代码更简洁，很大程度上是由于传统是编程90%的事情都是在干赋值的事，函数式编程这些都可以忽略。这仅仅是它的一个好处，不是说它就是函数式编程语言强大的原因 假如有两个函数g,f, 对于输入参数x假设是一个很长的序列, 要计算 g(f(x))传统的解决方法是先计算f(x)储存到临时文件中，这种方法临时文件可能占用很大的空间。函数式语言的解决方案是，程序g,f严格同步执行，只有当g需要数的时候它才会触发f，f从x取一个数计算返回给g，直到g试图获取下一个值。f的启动和终止取决于g，f甚至不会自行终止程序，因为当g运行结束时，f也会强制终止，这是的终止条件和循环体分离。这种求值方式按需求值，无需不求值 ，尽可能的减少运行，因此被称之为惰性求值。它使得将程序模块化为一个能产生大量可能解的生成器以及一个恰当的选择器变的可行。 惰性求值跟函数式编程的关系惰性求值有什么好处？ 优化，有显著的优化潜力，函数可以消消乐而不必都要求值运算 抽象控制结构，普通的判断语句有了宏的能力 if(condition)function_code ; condition是个待求的值，惰性求值中，如果condition最后的值为false时 function_code根本不会被求值 ，而在迫切求值过程中，condition的值依赖于当前的实时值 那么function_code就有可能被计算 无穷的数据结构 g(f(x)), f(x), x 都可以是个无穷序列，他的终止仅仅依赖于g函数的终止条件，具备这种能力的 原因就是惰性求值，每当计算一个g(f(x))时，g会访问f，f访问x 用多少取多少，不用不取，不必 讲所有的f(x) 都求好缓存，然后再计算g 无穷长数据的列表有什么好处？为什么要用无穷长列表？待补充， 惰性求值有什么缺点： 不能保证执行顺序12system.out.println(&quot;Please enter file name:&quot;)system.in.readfile(fileinput) 现实中很多问题是需要严格的执行顺序(也就是有状态)， 比如IO输入输出操作, 也就是所谓的副作用如果为了允许特定执行顺序，又将失去诸多函数式数学推理的诸多好处 幸运的是，结果并没那么坏，数学家为此开发除了许多技巧来保证在一定函数式设置下代码能特定顺序执行。这样就赢得了两个世界，既可以利用无副作用函数式编程的好处，同样可以和外部环境打交道。这些技术包括continuation, monad uniqueness typing . 理解CPS函数式编程与Continuation/CPS探索c#之递归APS和CPSCPS是一种书写方式 我们对函数的了解是：函数只能将结果返回到他的调用端, 实际上函数不必返回到其调用端而是可以返回到程序的任何地方。只要我们把CPS作为参数传给一个函数，那么他就决定了这个函数返回的位置 。举例：1234static int Times3(int x) { return x * 3;}Console.WriteLine(Times3(5)); CPS实现, Times3 不再显示的返回了，它的结果被传递给了一个叫k的函数，返回类型由这个函数决定1234static void Times3(int x, action&lt;int&gt; k) { k(x * 3)}Times3(5,(n) =&gt; Console.WriteLine(n)) k 是一个匿名函数(n) =&gt; Console.WriteLine(n) 例2，假如有3个函数Main, F, G, Main函数调用F, F调用G1234567Console.WriteLine(F(1) + 1);static int F(int n) { return G(n + 1) + 1;}static int G(int n) { return n + 1;} 转换成CPS风格1234567F(1, (x)=&gt; Console.WriteLine(x + 1))static void F(int n, action&lt;int&gt; k){ G(n + 1, (x) =&gt; k(x + 1)) //G(n+1) + 1 G外面的1 要在传参的时候+ , 否则没法实现}static void G(int n, action&lt;int&gt; k){ k(n + 1)} 例3， CPS尾递归123456static int Factorial(int n){ if(n==0) return 1; else return n * Factorial(n-1) ;} CPS风格 C# 实现12345678static int Factorial(int n, action&lt;int&gt; k){ if(n==0) k(1) else Factorial(n - 1, x =&gt; k(x*n))}Factorial(10, (x) =&gt; x ) python 实现1234567def Factorial(n, func): if(n==0): func(1) else : Factorial(n - 1, lambda x:func(n*x))a = Factorial(0, lambda x:x) python的实现这种写法执行的时候会返回None，好像CPS并没有发生，原因是什么？可能跟python的实现有关 scala 实现12345678object testMain extends App{ def Factorial(n: Int, f: Int =&gt; Int): Int = { if(n==0) f(1) else Factorial(n-1, x =&gt; f(x * n)) } val a = Factorial(5, x =&gt; x) println(a)} Factorial函数本身不会返回，它把返回的事交给top定义的 x =&gt; x 匿名函数来返回对于这种尾递归的函数，天然的不需要保存栈，因为中间结果就是下一次调用的入口参数放到汇编指令上看，直接将PC指针跳转，参数根本就不需要传递，因为上一次跟下一次用的现场是一样的，所以也不存在入栈出栈保存恢复现场的问题。就像把参数连续的传递一样，也就是CPS(continuation passing style)的出处。所以我们不用考虑压栈的问题,天然的就被编译成了循环迭代执行的样子，不需要空间上的开销 什么是尾递归尾递归的外在表现，返回值是他本身例如，Factotrial(n-1, balabala.. )Factorial(n-1, balabal..) * n或Iterfunc(n-1,balabala..) + somthing就不是尾递归，有些值必须得缓存而尾递归不许要考虑压栈，仅仅是携带一个新的确定的参数继续执行罢了 为什么要CPS我认为CPS变换最大的用途就在于它可以把任意的递归函数改写成尾递归本身递归的应用非常广泛，尤其是程序解析，树的解析都会用到递归为了避免递归爆栈的问题，CPS变换以continuation链的形式，避免栈空间的开辟下一次递归传递的仅仅是参数而已 (尾递归只能降低空间开销，但并不能降低时间开销)使得递归以尾递归的方式真正的被得以应用 基于CPS变换的尾递归转换算法 另外CPS最常见的用法就是回调函数，回调是显示传递的延续，回调是在函数结束时才调用UI框架使用CPS来保持UI的响应，同时允许非线性程序交互，等上一个动画结束再执行下一给，形成链式效果Web服务器使用CPS允许页面之间异步响应 模式匹配跟函数式编程的连系函数式语言中的模式匹配是什么stackoverflow模式匹配是编译器帮你处理了匹配判断分支的杂活。模式匹配的写法：1234f(0, 0) = NaN;f(x, 0) | x &gt; 0 = Infinity; | else = -Infinity;f(x, y) = (double)x / y; 一般的写法，或者编译器最后编译等价的代码：1234567891011double f(int x, int y) { if (y == 0) { if (x == 0) return NaN; else if (x &gt; 0) return Infinity; else return -Infinity; } else return (double)x / y;} 为什么函数式语言很容易实现模式匹配，而命令式编程大多做不到模式匹配 ？函数式编程里的模式匹配","link":"/sicp/whyfp.html"},{"title":"博文收藏","text":"博客收藏 道可叨http://zhuoqiang.me/ 函数式编程什么是函数式编程函数式代码是对“映射的描述”，输入x和输出y的映射关系 y=f(x)函数式编程在 描述是什么命令式编程在 应该怎样做 理解函数式编程 为什么我们需要（or不需要）科里化 什么是函数式编程思维？ / 知乎 Monad 最简介绍 符号: 抽象、语义(函数式表达最清晰的解释) 其他 程序如何定位自己","link":"/others/favo_blog.html"},{"title":"lambda演算python实现[二]之数字","text":"原文出处：lambda演算中的数字 python实现数字和加法的函数表示 数字的定义123456789101112131415161718192021222324def _0(s,z): return zdef _1(s,z): return s(z)def _2(s,z): return s(s(z))def _3(s,z): return s(s(s(z)))_4 = lambda s,z:s(s(s(s(z))))_5 = lambda s,z:s(s(s(s(s(z)))))_6 = lambda s,z:s(s(s(s(s(s(z))))))_7 = lambda s,z:s(s(s(s(s(s(s(z)))))))_8 = lambda s,z:s(s(s(s(s(s(s(s(z))))))))_9 = lambda s,z:s(s(s(s(s(s(s(s(s(z)))))))))#add = lambda x,y:lambda s,z:x(s,y(s,z))def add(x,y): def curry0(s,z): return x(s,y(s,z)) return curry0 检验运行以下函数1234print(_2)print(_2)print(_3)print(add(_1, _2)) 得到：1234&lt;function _2 at 0x00611660&gt;&lt;function _3 at 0x006113D8&gt;&lt;function _5 at 0x006115D0&gt;&lt;function add.&lt;locals&gt;.curry0 at 0x006114F8&gt; 你会发现add加法，根本看不出任何信息 ,为什么呢？原因是我们定义的这些值和add操作都是函数，没有赋值推导就不会发生作用 为了让函数确实能发生变化，我们就要依赖于python的编译器，只要给这些表示数字的函数赋值，编译器就工作了，递归也就发生了为了能够清晰示意，我们把z 赋值成0，s也有意义的实现为一个递增函数。实际上这里的z,s的实现不一定是0和inc递增函数，只是这么实现是为了方便示意 让递归发生123456z = 0s = lambda x:x+1print(\"_2 :\",_2(s,z))print(\"_3 :\",_3(s,z))print(\"_5 :\",_5(s,z))print(\"add(_2,_3):\",add(_2, _3)(s,z)) 得到：1234_2 : 2_3 : 3_5 : 5 add(_2,_3): 5 #瞧！发生作用了，add(_2,_3) 和_5的值一样 数字赋予新的意义我们也可以用字符”+”的个数来代替我们定义的数字的意义123456z=\"\" s= lambda x:x+\".\"print(\"_2 :\",_2(s,z))print(\"_3 :\",_3(s,z))print(\"_5 :\",_5(s,z))print(\"add(_2,_3):\",add(_2, _3)(s,z)) 得到：1234_2 : ++ #表示2个“+”号 _3 : +++ #表示3个“+”号 _5 : +++++ #表示5个“+”号add(_2,_3): +++++ #得到5个“+”号，加法操作确实发生了作用 所以z,s只要定义的有意义，我们可以做更多的事情","link":"/sicp/lambda_02_number.html"},{"title":"lambda演算python实现[三]之Bool值和分支","text":"原文出处：Lambda演算中的布尔值和选择 python实现用python定义Bool值和bool运算如下 123456789101112131415161718192021222324#用函数的方式定义Bool值TRUE#TRUE = lambda x,y:xdef TRUE(x,y): return x#用函数的方式定义Bool值FALSE#FALSE = lambda x,y:ydef FALSE(x,y): return y#用函数的方式定义Bool与#And = lambda x,y:x(y,FALSE)def And(x,y): return x(y,FALSE)#用函数的方式定义Bool或#Or = lambda x,y:x(TRUE,y)def Or(x,y): return x(TRUE,y)#用函数的方式定义Bool取反#Not = lambda x:x(FALSE,TRUE)def Not(x): return x(FALSE,TRUE) 验证一下，将Bool值带入一下运算1234567print(TRUE)print(\"and(True ,False):\",And(TRUE,FALSE))print(\"and(False,True ):\",And(FALSE,TRUE))print(\" or(True ,False):\", Or(TRUE,FALSE))print(\" or(False,True ):\", Or(FALSE,TRUE))print(\"not False :\",Not(FALSE))print(\"not True :\",Not(TRUE)) 得到1234567&lt;function TRUE at 0x00A88FA8&gt;and(True ,False): &lt;function FALSE at 0x00406810&gt;and(False,True ): &lt;function FALSE at 0x00406810&gt; or(True ,False): &lt;function TRUE at 0x00A88FA8&gt; or(False,True ): &lt;function TRUE at 0x00A88FA8&gt;not False : &lt;function TRUE at 0x00A88FA8&gt;not True : &lt;function FALSE at 0x00406810&gt; 看结果确实能够正确布尔计算。注：如果要用C语言实现，参数x,y的类型定义成指针类型即可。","link":"/sicp/lambda_03_bool_branch.html"},{"title":"Scala 避坑大法","text":"单引号双引号是有区别的 单引号表示：char字符 双引号表示：string字符 scala 为什么不建议用return return是命令时语句，Scala鼓励函数式编程，函数式在描述关系，而不是高速计算机怎么做 return会破坏Scala的类型推断，加上return 你得显式的声明返回类型 return在有些情况下使返回含义模糊 scala实际上并没有真正意义上的return语句，而是又抛出异常的语法糖包裹实现的 如何定义一个无限长的序列 Infinite Stream 无限长的序列有什么用 BugList1234object fix{ def on: Boolean = FixSwitch on def off: Boolean = FixSwitch off} 12fix onval a = 2 // is Ok 123fix onprintln(\"xxx\") // Compile errorval a = 2","link":"/scala/scala_FAQ.html"},{"title":"Chisel 常见问题","text":"Q1: Q1:","link":"/chisel/chisel_QA.html"},{"title":"函数是编程的闭包和迭代器理解","text":"什么是闭包？闭包是一类特殊的函数。如果一个函数定义在另一个函数的作用域中，并且函数中引用了外部函数的局部变量，那么这个函数就是一个闭包。123456789101112def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum$ lazy_sum(1,2,3,4,5)&lt;function sum at 0x10452f668&gt;$ lazy_sum(1,2,3,4,5)()15 在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，称为闭包 需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了 f() 才执行。我们来看一个例子 1234567891011121314def count(): fs = [] for i in range(1,4): def f(): return i * 4 fs.append(f) return fs $ f1, f2, f3 = count()$ f1()9$ f2()9$ f3()9 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为她封装的是这个变量，最后求值的时候才会去取这个变量，上面i最后的值是3.所以三个函数得到的都是9如果非要在引用变量，可以这么做123456789def count(): fs = [] for i in range(1,4): def wrap(i): #i参数传递进去是确定的值 def f(): return i * 4 return f fs.append(wrap(i)) #已将i作为固定值传递进去 return fs 闭包有什么用处？本质上，闭包是将函数内部和函数外部连接起来的桥梁。1234567891011121314151617&gt;&gt;&gt; def ExFunc(n): sum=n def InsFunc(): return sum+1 return InsFunc&gt;&gt;&gt; myFunc=ExFunc(10)&gt;&gt;&gt; myFunc()11&gt;&gt;&gt; myAnotherFunc=ExFunc(20)&gt;&gt;&gt; myAnotherFunc()21&gt;&gt;&gt; myFunc()11&gt;&gt;&gt; myAnotherFunc()21&gt;&gt;&gt; 由于闭包把函数和运行时的引用环境打包成为一个新的整体，所以就解决了函数编程中的嵌套所引发的问题。如上述代码段中，当每次调用ExFunc函数时都将返回一个新的闭包实例，这些实例之间是隔离的，分别包含调用时不同的引用环境现场。不同于函数，闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例 他最根本的用途是提供了更深的代码复用 怎么理解函数是一等公民？变量是一等公民，变量怎么用，函数就能怎么用变量出现的地方，函数都可以出现 怎么理解函数式编程的惰性求值？函数式编程的主题之一是关注分离(separation of concerns)。希望将计算的描述与实际运行分离一般而言，惰性化对一个表达式分离了它的描述和求值。 12345678910scala&gt; def maybeTwice(b: Boolean, i: =&gt; int) = if(b) i+i else 0scala&gt; val x = maybeTwice(true, { println(&quot;hi&quot;); 42}) #{,x}的传参方法可以用于debughihix: Int = 84scala&gt; val x = maybeTwice(false, { println(&quot;hi&quot;); 42}) x: Int = 0 # 可以表达式{println(&quot;hi&quot;),2} 根本就没有被执行，它也不需要被执行，# 但是如果是传值调用，那么b不管真否，表达式都必须求值# 所以只有当用到时才求值，用不到不求值，也是传名调用的一种用途吧 反过来，如果这个参数被用到多次，那么传名参数要被求值多次，反而效率不如传值参数。 1234567scala&gt; def maybeTwice(b: Boolean, i: =&gt; int) = { | lazy val j = i | if(b) j+j else 0 | }scala&gt; val x = maybeTwice(true, { println(&quot;hi&quot;); 42})hix: Int = 84 惰性求值参考 如何理解lazy12345678910scala&gt; val x = { println(&quot;i&apos;m positive&quot;); &quot;Howdy&quot;} //赋值时就积极执行expr求值 赋值给变量i&apos;m positivex: String = Howdyscala&gt; println(x)Howdyscala&gt; lazy val y = { println(&quot;i&apos;m lazy&quot;); &quot;Vigilance&quot;} //等用到y的时候在执行expry: String = &lt;lazy&gt;scala&gt; println(y)i&apos;m lazyVigilance scala 的传名调用，传值调用() =&gt; Unit 是函数=&gt; Unit 是执行结果为Unit的表达式12345678910111213object Add { def addByName(a: Int, b: =&gt; Int) = a + b + b def addByValue(a: Int, b: Int) = a + b + b }scala&gt; Add.addByValue(2, {println(&quot;callByValue&quot;);3})callByValue # b 的求值只被执行了一次，传值调用res15: Int = 8scala&gt; Add.addByName(2, {println(&quot;callByName&quot;);3})callByName # b 被执行了2次，传名调用callByNameres17: Int = 8 到现在 你可以发现传名参数本质就是将参数的lazy化，类似于 def addByName(a: Int, lazy b: Expr)，只不过没有定义成这种语法而已 Chisel里的lazy module有什么用？官方解释The LazyModule construct was created as a way to delay calling the constructor until after there’s been a chance to calculate the parameters to give it. LazyModule decouples the point in the code where a circuit element is instantiated, from the point in the code where the constructor is called and that instance is actually built. In Rocket, one main driver of this lazy approach is Diplomacy), which creates the TileLink2 and AXI connections on the chip. Diplomacy, in turn, is built on top of the Cake pattern 怎么理解函数式编程无副作用？","link":"/sicp/20190414-fp-closure-iterator.html"},{"title":"Hexo 技巧收录","text":"草稿功能草稿相当于很多博客都有的“私密文章”功能。1$ hexo new draft \"new draft\" 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。如果你希望强行预览草稿，更改配置文件： 1render_drafts: true 或者，如下方式启动server：1$ hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面：1$ hexo publish [layout] &lt;filename&gt;","link":"/others/hexo_utlis.html"},{"title":"Python lambda实现Y组合子","text":"也许你我都难以理解，为什么有人对她痴迷疯狂，铭记在心中不说，还要刻在身上： 她让人绞尽脑汁，也琢磨不定！她让人心力憔悴，又百般回味！ 她，看似平淡，却深藏玄机！她，貌不惊人，却天下无敌！ 她是谁？ 她就是 Y 组合子：Y = λf.(λx.f (x x)) (λx.f (x x)) ，不动点组合子中最著名的一个。 原文出处 python 利用Y算子实现递归阶乘函数 1((lambda S : (lambda x: (S(lambda y: x(x)(y))))(lambda x: (S(lambda y: x(x)(y)))))(lambda f:lambda n: 1 if(n==0) else (n*f(n-1))))(10) 复制此段代码到python shell可以看到阶乘10的正确结果","link":"/sicp/python-fp.html"},{"title":"Chisel BugList","text":"[ ] BitPat length bugs BitPat.pare(&quot;b1100_0000&quot;) = (192,255,9) 实际8bit，返回9bit BitPat.pare(&quot;b11000000&quot;) = (192,255,8) 12335: (bits, mask, x.length - 1) fix 剔除字符&apos;_&apos; 后统计长度35: (bits, mask, x.filter(_!=&apos;_&apos;).length - 1) [ ] bug2","link":"/chisel/chisel_bugs.html"},{"title":"Chisel版本","text":"如何查看当前使用的chisel版本一般情况下chisel的版本会在build.sbt里显式定义，但有时候像jupter-notebook里并不能看到版本号这种情况下有一个方法可以得到版本号即生成的firrtl文件头会打印版本信息 12;buildInfoPackage: chisel3, version: 3.1.2, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2018-07-25 16:52:17.431, builtAtMillis: 1532537537431circuit T1 : 修改chisel 版本 12libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.1.2\"libraryDependencies += \"edu.berkeley.cs\" %% \"chisel-iotesters\" % \"1.2.2\" 如何知道最新release的chisel 版本号 ，可以访问 https://index.scala-lang.org/ 搜索chisel3 查看当前release版本比如当前最新版本为3.1.7 , 修改build.sbt 重新sbt run时会自动下载最新版本库到~/.ivy2 libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.1.7\" chisel Scala 版本对应关系 scala sbt chisel firrtl 状态 2.11.x x.x.x 3.1.x x.x.x 正常 2.12.x x.x.x 3.1.x x.x.x Fail, IO Bundle Error chisel 3.1.x firrtl版本策略","link":"/chisel/20190411_chisel_version.html"},{"title":"Chiel Keep变量名","text":"how to keep chisel variable name when generate verilogThere are several reasons why a name may be disappearing. Constant PropagationFor many reasons, including interoperability with existing CAD tools, performance, and Verilog debug-ability, Chisel (actually the FIRRTL compiler underneath Chisel) will propagate constants and direct wire connections. For example: 123456789class MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val wire = Wire(UInt(8.W)) wire := io.in io.out := wire} In the above code, wire will be removed because it is simply connected to io.in, the Verilog will just show: assign io_out = io_in;Inability to nameChisel Modules are implemented as Scala Classes. Due to implementation reasons, by default Chisel can only name “top-level” vals in the body of the Module, for example: 12345678910111213141516class MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val in2 = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val sum = io.in + io.in2 // this is a top-level val, will be named // A method, we can call to help generate code: def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented } io.out := inc(sum)} suggestNameYou can manually name any signal by calling .suggestName(“name”) on it, eg. 1234def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented.suggestName(&quot;incremented&quot;) // Now it is named!} Enter @chiselNameWe can fix the above issue with an experimental feature called @chiselName like so: 12345678910111213141516171819import chisel3.experimental.chiselName@chiselNameclass MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val in2 = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val sum = io.in + io.in2 // this is a top-level val, will be named // A method, we can call to help generate code: def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented } io.out := inc(sum)} @chiselName is an annotation that can be used on any class or object definition and will ensure vals like incremented can get named. @chiselName effectively rewrites your code to put .suggestName all over the place. I hope this helps! EDIT more info:Disabling OptimizationsI don’t think it’s in a release yet (most recent being 3.1.7, this will be in 3.2.0), but we do have an option to disable all optimizations. You can change the “compiler” used from verilog to mverilog (for “minimum” Verilog, ie. no optimizations). This can be done with the command-line argument -X mverilog either in Chisel or FIRRTL. Don’t TouchYou can also use chisel3.experimental.dontTouch to mark a signal as something that shouldn’t be deleted. This will prevent optimizations from removing the signal. For example: 123456789import chisel3.experimental.dontTouchclass MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val wire = dontTouch(Wire(UInt(8.W))) wire := io.in io.out := wire I’ve edited my response to talk about how to disable optimizations (not in the current release, you can wait for 3.2 which should be out in a couple of weeks or build Chisel manually from master and use that). I should caution that running formal equivalence tools tend to struggle comparing large designs with and without optimizations, but you can try it. For specific signals, dontTouch can help with what you want. o 原文链接","link":"/chisel/20190401_chisel_keep_name.html"},{"title":"Verilog 模块重名问题","text":"Chisel 不同开发生产的Verilog 模块名冲突同学A 负责开发AP同学B 负责开发CP其中都会用到Queue，生产的AP_system_top.v CP_system_top.v中可能都会包含一个module Queue (集成到SOC_top.v时会面临模块名冲突的问题，目前Chisel 本身没有提供解决该问题的方法。只能依赖于原始verilog 的解决方法 Verilog 模块名冲突解决方法仿真命令如下 1vcs -top $top_cfg_name_in_libmap -libmap $libmap_file 1234567891011121314library default_lib $project;library cp_rocket_lib $project/cp/rocket_chip/*.v;library top_rocket_lib $project/top/rocket_chip/*.v;library i2c_ahb_lib $project/top_peri/i2c_ahb/*.v;config chip_cfg; design tb_top ; default liblist default_lib; instance tb_top.U_chip.U_system_top.U_cp_top.U_cp_rocket liblist cp_rocket_lib ; instance tb_top.U_chip.U_system_top.U_top_rocket liblist top_rocket_lib; instance tb_top.U_chip.U_system_top.U_top_peri_sys.U_i2c_ahb liblist i2c_ahb_lib ;endconfig 综合应该也差不多","link":"/chisel/20190322_chisel_module_confilict.html"},{"title":"Chisel组合逻辑时序逻辑","text":"时序逻辑的声明和写法123456789101112131415161718192021实例1 val tiRomStartAddr = RegInit(0.U(6.W)) //显示的声明Reg when (io.swif.K&lt;40.U ){tiRomStartAddr := 25.U } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := 21.U } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := 35.U } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := 15.U } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := 10.U } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := 5.U } .otherwise {tiRomStartAddr := 25.U }实例2 val RRomRdata = RegInit(0.U(log2Up(pm.MaxR).W)) //显示的声明Reg并初始化（switch语句不带default) switch (io.RRomAddr) { is (0.U) {RRomRdata := intraRowTi.RRomVal(0).U} is (1.U) {RRomRdata := intraRowTi.RRomVal(1).U} is (2.U) {RRomRdata := intraRowTi.RRomVal(2).U} is (3.U) {RRomRdata := intraRowTi.RRomVal(3).U} is (4.U) {RRomRdata := intraRowTi.RRomVal(4).U} is (5.U) {RRomRdata := intraRowTi.RRomVal(5).U} is (6.U) {RRomRdata := intraRowTi.RRomVal(6).U} is (7.U) {RRomRdata := intraRowTi.RRomVal(7).U} } 组合逻辑的声明与写法123456789101112131415161718192021222324252627实例1 val tiRomStartAddr = Wire(UInt()) //显示的声明Wire when (io.swif.K&lt;40.U ){tiRomStartAddr := 25.U } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := 21.U } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := 35.U } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := 15.U } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := 10.U } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := 5.U } .otherwise {tiRomStartAddr := 25.U }实例2 val RRomRdata = Wire(UInt()) //显示的声明Wire RRomRdata := 0.U //一定要设默认值，否则组合逻辑条件不全chisel编译不过（verilog组合逻辑条件不全会产生锁存器） switch (io.RRomAddr) { is (0.U) {RRomRdata := intraRowTi.RRomVal(0).U} is (1.U) {RRomRdata := intraRowTi.RRomVal(1).U} is (2.U) {RRomRdata := intraRowTi.RRomVal(2).U} is (3.U) {RRomRdata := intraRowTi.RRomVal(3).U} is (4.U) {RRomRdata := intraRowTi.RRomVal(4).U} is (5.U) {RRomRdata := intraRowTi.RRomVal(5).U} is (6.U) {RRomRdata := intraRowTi.RRomVal(6).U} is (7.U) {RRomRdata := intraRowTi.RRomVal(7).U} } 实例3 val PrimeRom = Vec(PrimeAndRoot.map(_.U)) //ROM默认生成的是组合逻辑，寄存器输出自己加一级 io.out3 := PrimeRom(io.i)","link":"/chisel/20190321_chisel_comb_reg.html"},{"title":"Scala 初探.四(sbt组织scala代码2)","text":"package and import1234567├── build.sbt└── src └── main └── scala ├── Interleave.scala ├── utils.scala └── config.scala 对于同一目录下的两个文件，可以不用import，默认在一个package内 12345//Interleave.scalaclass A { val a = new ClassInUtils} 12345//utils.scala class ClassInUtils{ } Interleave.scala 不需要import ClassInUtils ,直接使用就可以，sbt 会帮你搞定编译 sbt import 错误解决12345scalaDSL&gt; tree src ~/lab/scalaDSLsrc├── main └── scala └── parser.scala 12345678910import scala.util.parsing.combinator._class Arith extends JavaTokenParsers {}object XXtest { def main(args: Array[String]) { println(\"Hello scala ***\") }} sbt run 总是会显示123.....object parsing is not a member of pacakge util[error] import scala.util.parsing.combinator._[error] ^ scala src/main/scala/parser.scala 可以正常打印Hello scala *** 命令行的scala版本2.12.6， build.sbt 还是scala 2.12.6 ，所以怀疑是不是sbt的版本有问题查看project/build.property版本号为1.2.8 ，改为1.1.1， 1.1.2都是同样的问题后来在网上搜到，build.sbt需要添加librarydependence 。如下12345name := \"scalaDSL\"version := \"0.1\"//添加下面一行libraryDependencies += \"org.scala-lang.modules\" %% \"scala-parser-combinators\" % \"1.0.2\"scalaVersion := \"2.11.12\" 重新sbt run编译正常备注：由于在网上搜到的scala-parser-combinators版本为1.0.2，对应的scala版本是2.11因此 scalaVersion := &quot;2.12.6&quot; 改成 scalaVersion := &quot;2.11.12&quot; 同理IDEA设置中有时候发现scala sbt版本都设置正确了，但是有些库还是找不到，显示红色，很可能就是 libraryDependencies 设置问题 其他问题在SCALA中import scala.swing._ 直接编译并不报错 但是以下程序编译会报错 [error] object swing is not a member of package scala12345678910111213141516//main.cimport scala.swing._class UI2 extends MainFrame { title = \"GUI Program #3\" contents = new BoxPanel(Orientation.Vertical){ contents += new Label(\"Look at me!\") }}object GuiProgramTwo { def main(args: Array[String]) { val ui = new UI2 ui.visible = true }} 原因: As of 2.11, the scala swing package is no longer listed among scala’s standard library api and in fact is described in its own README as “mostly unsupported”.因此需要安装最新的scala-swing版本,需要在build.sbt添加libraryDependencies += &quot;org.scala-lang&quot; % &quot;scala-swing&quot; % &quot;2.10.4&quot;scala-swing最新版本地址scala-swing编译成功运行Programming in Scala 3rd Edition上的示例并不能成功运行，这篇scala-swing GUI教程上的例子能正常运行 JAVA Swing教程","link":"/scala/20190308_scala_sbt2.html"},{"title":"Scala 初探.二(package组织方式)","text":"多个文件的package组织方式123456//a.scala package com.east import com.west._object objectMain extends App{ println(\"add Function from west used in east, 1+2=%d\".format(Add.add(1,2)))} 12345//b.scala package com.west object Add { def add(a:Int, b:Int) = a + b} 多个文件的package组织方式编译 scalac a.scala b.scala 生成com文件夹（JVM 编译完的.class文件）运行 scala com.east.main 正确打印信息 object main 方式 1234567891011121314151617181920212223//c.scala package com.north object NorthWolf { def main(args:Array[String]){ println(\"add Function from west used in north, 3+4=%d\".format(Add.add(3,4))) }} ``` 编译 `scalac a.scala b.scala c.scala` 更新com文件夹 运行 `scala com.north.NorthWolf` 正确打印信息 Makefile 如下```Makefileobjects = comsource = a.scala b.scala c.scala.PHONY: runrun:com scala com.east.objectMain scala com.north.NorthWolf $(objects) : $(source) scalac $(source) SCALA编译生成的com为package目录, *.class 为class字节码，可以被JVM执行(所以SCALA编译玩的.scala可以在任何JVM上执行，也就说scala的程序也可以在Android上运行)比如com/east/main.class ,可以直接scala com.east.main来执行 123456789101112$:tree com com├── east│ ├── main$.class│ ├── main$delayedInit$body.class│ └── main.class├── north│ ├── NorthWolf$.class│ └── NorthWolf.class└── west ├── Add$.class └── Add.class 关于*.scala 和 *$.scala 的区别可以在网上自行搜索 原则上只要把com文件夹打包就可以发布为一个SCALA/JAVA程序 jar打包和运行如何讲程序打包成jar 命令行运行jar cvf com.jar com 得到com.jar在任意地方 scala -classpath com.jar com.north.NorthWolf 可直接运行函数 实例参见目录/nutstore/2017pc/lab/scala/packageTest","link":"/scala/20190308_scala_package.html"},{"title":"Scala 初探.三(sbt组织scala代码1)","text":"上一节我们用Makefile来组织scala代码，这里有更好的选择sbt来管理项目sbt推荐将scala代码放在src路径，如下为标准的组织方式(代码还是原封使用第二节的样例代码)总共3个文件 1234567├── build.sbt└── src └── main └── scala ├── a.scala ├── b.scala └── c.scala 输入命令 sbt test 编译没报错输入命令 sbt run 提示找到了2个入口函数12345678Multiple main classes detected, select one to run: [1] com.east.objectMain [2] com.north.NorthWolf[info] Packaging E:\\nutstore\\2017pc\\lab\\scala\\sbtProj\\target\\scala-2.11\\sbtproj_2.11-0.1.0-SNAPSHOT.jar ...[info] Done packaging.Enter number: 跟我们的预期一致，确实a.scala中 和c.scala分别存在两个main入口 ,用不同的方式实现 12345678910111213141516//a.scalapackage com.east import com.west._object objectMain extends App{ println(\"add Function from west used in east, 1+2=%d\".format(Add.add(1,2))) } //c.scalapackage com.north import com.west._object NorthWolf { def main(args:Array[String]) { println(\"add Function from west used in north, 3+4=%d\".format(Add.add(3,4))) args.map(println) }} 也可以sbt &quot;runMain com.north.NorthWolf arg1 arg2&quot; 直接选定要执行的main入口 其他sbt 相关的命令可以自行在网上搜索 SBT打包jarsbt compile 后会在根目录下生成","link":"/scala/20190308_scala_sbt1.html"},{"title":"Scala 初探.一(main函数)","text":"SCALA 程序的几种运行方式方法1脚本式的使用，scala a.scala 可正常打印1234def main() = { println(\"Hello, Scala way1\")}main() 但这种写法不能被 scalac a.scala正确编译，可能JVM对象必须要有个main入口函数 方法2 object mainJava中一个类要独立运行，必须具有静态的main方法，如下123public static void main(String[] args) { ... } scala 种借鉴了这种方法，为了独立运行一个SCALA程序，必须定义一个scala object并且为其定义main方法命令行scala a.scala会直接运行main函数，其中args为命令行参数 123456object RunAppDemo { def main(args:Array[String]) { println(\"Hello, Scala within object main\") args.map(println) } } Scala中的Object相当于java中的静态类，在其上可以定义静态的方法。Scala允许一个类定义自己的“伴生对象”(Companion Object)，它们具有相同的名字，必须位于同一个文件中，并且可以互相引用各自的私有成员。Scala的Object也可以独立存在。如果一个Scala Object没有伴生对象，我们称之为“独立对象”（Standardalone Object），反之，对象和类互为友元。上述代码main方法中的参数args是从命令行中传入的参数列表，具体用法和java类似。 如果a.scala 定义两个main函数，会默认执行第一个出现的main函数123456789101112object RunAppDemo { def main(args:Array[String]) { println(\"Hello, Scala within object main\") args.map(println) } } object RunAppDemo2 { def main(args:Array[String]) { println(\"Hello, Scala within object main2\") } } 方法3 extends App为了使代码更简洁，Scala还提供了另外一种运行Scala程序的方式，那就是直接继承scala.App接口（Trait）。 123object RunAppWithoutMain extends App { println(\"runing scala app without main\") } 之所以这里无须定义main方法，那是因为在App这个接口中定义了一个main方法，main方法在执行时会初始化RunAppWithoutMain这个对象，并执行它的主构造方法，而所有直接写在对象中的代码都会被scala编译器收集到主构造方法中，于是就被运行了。 这种方法虽然省略了一些代码，但是也有一些副作用。 直接继承自Application导致的副作用: 无法接受命令行参数。因为args参数不会被传入 在Scala中，如果一个程序是多线程的，那么这个程序必须具有一个main方法。所以这种写法只能适用于单线程的程序 App这个接口在执行一个程序的代码之前，需要进行一些初始化。而某些JVM不会对这些初始化代码进行优化。 所以第二种方法只适用于一些非常简单的场合，大部分情况不推荐使用。","link":"/scala/20190308_scala_main.html"},{"title":"RISCV 矢量处理器","text":"RISC-V向量的工作过程 setp1 : 首先要确定向量的类型 比如你要做一个向量运算 Y = a*X + Y ,如果X, Y 都是双精度的浮点的向量，那么就需要申请两个F64类型的向量v0和v1, 如果是 Z = a*X + Y ,同样X,Y是双精度的浮点的向量，那么就需要至少申请3个F64类型的向量v0和v1,v2分别给X,Y,Z使用 RV32V 向量寄存器类型的编码如下 Type Floating Poing Signed Interger Unsigned Interger Width Name vetype Name vetype Name vetype 8bit — — X8 10100 X8U 11100 16bit F16 01101 X16 10101 X16U 11101 32bits F32 01110 X32 10110 X32U 11110 64bits F64 01111 X64 10111 X64U 11111 setp2 : 然后申请向量的个数 假如向量寄存器总共有1024Byte ，如果只给2个向量使用,那么对半分，每个向量可以分得512Byte的空间，F64=8Byte，所以 每个向量可以有512/8=64个F64类型的元素，也就是mvl(max_vecotr_length)=64， 一次可以计算的个数是64个元素。 如果我们的X,Y的长度假设是100，那么完成 Y = a*X + Y 需要2次向量操作， 第一次vl选64， 计算64个F64向量的运算 第二次vl选100-64= 36, 计算剩余的36个F64向量的运算 FAQ 何为mvl max_vector_ 何为ml","link":"/riscv/20181221_riscv_verctor.html"},{"title":"从Shell传递变量给verilog的两种方法","text":"通过define宏传递 首先在命令行中定义define 1234567vcs -sverilog -debug_all +define%s+CASENAME=\\\"%s\\\" -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log -f top.f 尤其要注意CASENAME=\\&quot;%s\\&quot;的转义“\\”的应用，比如命令行被包含在python脚本内部，需要两次转义, 而shell可能只要一次 123def run(case,defines=\"\"): os.system('vcs -sverilog -debug_all +define%s+CASENAME=\\\\\"%s\\\\\" -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log -f top.f'%(defines,case)) os.system('./simv -l sim.log +notimingcheck +nospecify +loopreport +memcbk +novopt') 否则verilog文件是无法获取CASENAM的意思 然后在verilog中通过宏取出 1fp_reg = $fopen({\"./case/\",`CASENAME,\"/source_dpp.txt\"},\"r\"); 这种方式比较繁琐，而且转义嵌套难以理解，另外一种方便的方法如下 通过option arg传递 首先在命令行的option里定义两个puls类型的args, +DUMPWAVE和TESTCASE 1234run: compile rm -rf ${TEST_RUNDIR} mkdir ${TEST_RUNDIR} cd ${TEST_RUNDIR}; ${SIM_EXEC} +DUMPWAVE=${DUMPWAVE} +TESTCASE=${TESTCASE} |&amp; tee ${TESTNAME}.log; cd ${RUN_DIR}; 然后在verilog文件中通过$val$plusargs()获取val 123456789101112131415reg [8*300:1] testcase;integer dumpwave;initial begin if($value$plusargs(\"TESTCASE=%s\",testcase))begin $display(\"TESTCASE=%s\",testcase);endinitial begin $value$plusargs(\"DUMPWAVE=%d\",dumpwave); if(dumpwave != 0)begin // To add your waveform generation function $fsdbDumpfile(\"./e203.fsdb\") ; $fsdbDumpvars(0,tb_top); $fsdbDumpflush; endend","link":"/eda/how_to_send_param2tb.html"},{"title":"Chisel-Verilog查找表优先级问题讨论","text":"Chisel 查找表电路优先级问题verilog ROM的两种写法及区别1234567891011121314151617181920212223方法1always @(posedge clk )begin case(addr0) 6'd0 : data0 &lt;= 8'd214; 6'd1 : data0 &lt;= 8'd213; 6'd2 : data0 &lt;= 8'd212; 6'd3 : data0 &lt;= 8'd211; 6'd4 : data0 &lt;= 8'd210; 6'd5 : data0 &lt;= 8'd209; 6'd6 : data0 &lt;= 8'd208; 6'd7 : data0 &lt;= 8'd207; 方法2always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; 方法2是不是带优先级？ 实际上是不带优先级逻辑上if取的条件都是addr1的值，一定是互斥的，综合工具也能自动识别出这种if else它有别于以下这种情况，这种情况下是真实带有优先级的电路，其中another_cond_A,another_cond_B是独立的两个输入条件，和addr1的取值可能同时发生，所以不能被综合器当做查找表来对待。 12345678910always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(another_cond_A ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(another_cond_B ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; chisel中查找表的写法以及对应电路1234567891011121314方法一switch (addr) { is( 0.U ) { rdata:= 8'd150 } is( 1.U ) { rdata:= 8'd149 } is( 2.U ) { rdata:= 8'd148 } is( 3.U ) { rdata:= 8'd147 } is( 4.U ) { rdata:= 8'd146 } is( 5.U ) { rdata:= 8'd145 } is( 6.U ) { rdata:= 8'd144 } is( 7.U ) { rdata:= 8'd143 }}方法二val ROM = Vec(Array(150.U,149.U,148.U, 143.U))val rdata = ROM(addr) 两种方法都会生成以下类似电路，等效CASE语句写法。所以不用担心优先级的问题。 12345678910always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; 综合工具对上面电路的处理也是没有优先级的。 综合对比Verilog DEMO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104module caseifelse_top ( clk,in_en0,in_addr0,out_data0,in_en1,in_addr1,out_data1);input clk ;input in_en0 ;input in_en1 ;input [5:0] in_addr0 ;input [5:0] in_addr1 ;output [7:0] out_data0 ;output [7:0] out_data1 ;reg [7:0] out_data0 ;reg [7:0] out_data1 ;reg [5:0] addr0 ;reg [5:0] addr1 ;reg en0 ;reg en1 ;wire [7:0] data0 ;wire [7:0] data1 ;always @(posedge clk )begin en0 &lt;= in_en0 ; en1 &lt;= in_en1 ; addr0 &lt;= in_addr0 ; addr1 &lt;= in_addr1 ; out_data0 &lt;= data0 ; out_data1 &lt;= data1 ;end rom u_rom_table(.clk (clk ),.en0 (en0 ),.addr0 (addr0 ),.data0 (data0 ) );ifelse u_ifelse_table(.clk (clk ),.en1 (en1 ),.addr1 (addr1 ),.data1 (data1 ) );endmodule module rom(clk,rstn,en0,addr0,data0);input clk ;input rstn ;input en0 ;input [5:0] addr0 ;output [7:0] data0 ;reg [7:0] data0 ;always @(posedge clk )begin case(addr0) 6'd0 : data0 &lt;= 8'd214; 6'd1 : data0 &lt;= 8'd213; 6'd2 : data0 &lt;= 8'd212; 6'd3 : data0 &lt;= 8'd211; 6'd4 : data0 &lt;= 8'd210; 6'd5 : data0 &lt;= 8'd209; 6'd6 : data0 &lt;= 8'd208; 6'd7 : data0 &lt;= 8'd207;。。。 6'd63: data0 &lt;= 8'd151; default : data0 &lt;= 8'd0; endcase end endmodule module ifelse(clk,en1,addr1,data1);input clk ;input en1 ;input [5:0] addr1 ;output [7:0] data1 ;reg [7:0] data1 ;always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143;。。。 else if(addr1 == 6'd63) data1 &lt;= 8'd87; else data1 &lt;= 8'd1 ;end endmodule 综合后的网表 看到两种方法都是基本相同，没有优先级区别 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465module caseifelse_top_ifelse_1 ( clk, en1, addr1, data1 ); input [5:0] addr1; output [7:0] data1; input clk, en1; wire N67, N69, n8, n9, n10, n17, n18, n19, n1, n2, n3, n4, n5; SDFKCNQD1BWP7T40P140UHVT data1_reg_7_ ( .D(n8), .CN(n10), .SI(n9), .SE(n9), .CP(clk), .Q(data1[7]) ); SDFKSNQD1BWP7T40P140UHVT data1_reg_6_ ( .SN(n10), .D(addr1[5]), .SI(n9), .SE(n9), .CP(clk), .Q(data1[6]) ); MB2SRLSDFQD1BWP7T40P140LVT data1_reg_1_0_ ( .D1(n19), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[1]), .D2(addr1[0]), .Q2(data1[0]) ); MB2SRLSDFQD1BWP7T40P140UHVT data1_reg_5_4_ ( .D1(N69), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[5]), .D2(n17), .Q2(data1[4]) ); OA21D1BWP7T35P140UHVT U3 ( .A1(n4), .A2(n2), .B(n1), .Z(N67) ); ND2D1BWP7T30P140UHVT U4 ( .A1(addr1[4]), .A2(n1), .ZN(n10) ); ND2D1BWP7T30P140UHVT U5 ( .A1(n2), .A2(n4), .ZN(n1) ); ND3D1BWP7T30P140UHVT U6 ( .A1(addr1[0]), .A2(addr1[1]), .A3(addr1[2]), .ZN( n4) ); ND2D1BWP7T35P140UHVT U7 ( .A1(addr1[0]), .A2(addr1[1]), .ZN(n3) ); INVD1BWP7T35P140UHVT U8 ( .I(addr1[3]), .ZN(n2) ); INVD1BWP7T35P140UHVT U9 ( .I(addr1[5]), .ZN(n8) ); OAI21D1BWP7T35P140UHVT U10 ( .A1(addr1[0]), .A2(addr1[1]), .B(n3), .ZN(n19) ); OAI21D1BWP7T35P140UHVT U11 ( .A1(n5), .A2(addr1[2]), .B(n4), .ZN(n18) ); MAOI22D1BWP7T40P140UHVT U14 ( .A1(n10), .A2(n8), .B1(n8), .B2(n10), .ZN(N69) ); MB2SRLSDFQD1BWP7T40P140UHVT data1_reg_3_2_ ( .D1(N67), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[3]), .D2(n18), .Q2(data1[2]) ); TIELBWP7T40P140LVT U12 ( .ZN(n9) ); INVD1BWP7T40P140UHVT U13 ( .I(n3), .ZN(n5) ); OAI21D1BWP7T40P140UHVT U15 ( .A1(addr1[4]), .A2(n1), .B(n10), .ZN(n17) );endmodulemodule caseifelse_top_rom_1 ( clk, rstn, en0, addr0, data0 ); input [5:0] addr0; output [7:0] data0; input clk, rstn, en0; wire N235, N237, N238, n7, n14, n15, n16, n1, n2, n3, n4, n5, n6; SDFQOPPSAD1BWP7T40P140UHVT data0_reg_0_ ( .D(addr0[0]), .SI(n7), .SE(n7), .CP(clk), .Q(data0[0]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_2_1_ ( .D1(n15), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[2]), .D2(n16), .Q2(data0[1]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_4_3_ ( .D1(n14), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[4]), .D2(N235), .Q2(data0[3]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_6_5_ ( .D1(N238), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[6]), .D2(N237), .Q2(data0[5]) ); AO21D1BWP7T35P140UHVT U3 ( .A1(n6), .A2(n5), .B(n4), .Z(n14) ); AO21D1BWP7T35P140UHVT U4 ( .A1(n3), .A2(n2), .B(n1), .Z(n15) ); INVD1BWP7T35P140UHVT U5 ( .I(addr0[2]), .ZN(n2) ); ND2D1BWP7T35P140UHVT U6 ( .A1(addr0[0]), .A2(addr0[1]), .ZN(n3) ); NR2D1BWP7T35P140UHVT U7 ( .A1(n2), .A2(n3), .ZN(n1) ); INVD1BWP7T35P140UHVT U8 ( .I(addr0[4]), .ZN(n5) ); NR2D1BWP7T35P140UHVT U9 ( .A1(addr0[3]), .A2(n1), .ZN(n6) ); NR2D1BWP7T35P140UHVT U10 ( .A1(n5), .A2(n6), .ZN(n4) ); OAI21D1BWP7T35P140UHVT U11 ( .A1(addr0[0]), .A2(addr0[1]), .B(n3), .ZN(n16) ); AOI21D1BWP7T35P140UHVT U12 ( .A1(n1), .A2(addr0[3]), .B(n6), .ZN(N235) ); AOI21D1BWP7T35P140UHVT U13 ( .A1(addr0[5]), .A2(n4), .B(N238), .ZN(N237) ); NR2D1BWP7T35P140UHVT U14 ( .A1(n4), .A2(addr0[5]), .ZN(N238) ); TIELBWP7T40P140LVT U15 ( .ZN(n7) );endmodule 代码目录：/nutstore/2017pc/lab/turbo/scala/work 结论chisel 虽然生成的电路没有CASE语句，也完全没有问题，if else的写法也能满足查找表的实现，并不会有优先级的问题 扩展同样一下两种chisel和verilog的写法对于综合器来说其实都是没有优先级的，综合器可以根据时序情况将其打平，并不影响电路的功能（本质上每个条件都不重叠，所以没有真实的优先级物理意义）因此可以大胆的采用这种写法而不用考虑优先级进位链太长而产生的时序问题。 1234567891011121314151617181920212223 when (io.swif.K&lt;40.U ){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := baseR5 } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := baseR10 } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := baseR10 } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;2480.U){tiRomStartAddr := baseR20 } .elsewhen (io.swif.K&lt;3160.U){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;3210.U){tiRomStartAddr := baseR20 } .otherwise {tiRomStartAddr := baseRAny } ``` ```verilog if (K&lt;40 ){addr := 5&apos;d0 } else if (K&lt;159 ){addr := 5&apos;d1 } else if (K&lt;200 ){addr := 5&apos;d2 } else if (K&lt;481 ){addr := 5&apos;d4 } else if (K&lt;530 ){addr := 5&apos;d6 } else if (K&lt;2881){addr := 5&apos;d0 } else if (K&lt;2480){addr := 5&apos;d9 } else if (K&lt;3160){addr := 5&apos;d0 } else if (K&lt;3210){addr := 5&apos;d8 } else {addr := 5&apos;d0 }","link":"/chisel/20190320_verilog_case_ifelse.html"},{"title":"Chisel 实例问题汇总","text":"chisel-example \\ chisel-tutorial 同样代码，生成器输出不一致问题同样的一份代码src/main/scala/GCD.scalasrc/test/scala/GCDTester.scala 其中生成vcd波形的代码12345object GCDTester extends App { iotesters.Driver.execute(Array(\"--target-dir\", \"generated\", \"--fint-write-vcd\"), () =&gt; new GCD){ c =&gt; new GCDTests(c) }} 在chisel-example 目录下 sbt &quot;test:runMain simple.GCDTester&quot; 可以生成GCD波形1234&gt;&gt; l generated/examples.GCDTester1802184992-rwxr-xr-x+ 1 Administrator None 6 Dec 5 14:53 GCD.anno.json-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.fir-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.lo.fir 在chisel-tutorial 目录下 sbt &quot;test:runMain simple.GCDTester&quot; 不能生成GCD波形 1234&gt;&gt; l generated/examples.GCDTester1802184992-rwxr-xr-x+ 1 Administrator None 6 Dec 5 14:53 GCD.anno.json-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.fir-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.lo.fir 导致的原因是，build.sbt 不一样 , 可能是引入的库的版本不一致导致，123456789//chisel-tutorial/build.sbtval defaultVersions = Map( // \"chisel3\" -&gt; \"3.1.+\", // \"chisel-iotesters\" -&gt; \"1.2.+\" //将上面两行注释掉，改为3.1.2， 1.2.2 //否则可能会默认使用.ivy2/cache/edu.berkeley.cs/chisel3_2.11/jars/chisel3_2.11-3.1.3.jar \"chisel3\" -&gt; \"3.1.2\", \"chisel-iotesters\" -&gt; \"1.2.2\" ) iotesters.Driver.execute(Array(&quot;--target-dir&quot;, &quot;generated&quot;, &quot;--fint-write-vcd&quot;), () =&gt; new GCD){ chisel-example下的build.sbt chisel-tutorial下的build.sbt 结论：保险起见，使用一下两个版本号：12libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chisel3&quot; % &quot;3.1.2&quot;libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chisel-iotesters&quot; % &quot;1.2.2&quot;","link":"/chisel/20181205_chisel_learning.html"},{"title":"IDEA Scala开发环境配置","text":"IDEA 下载社区版本是免费的，scala开发够用，专业版面向web部分是收费的 启动idea ，import project 按钮倒入 .sbt 文件 setting java JDK, File&gt;&gt;Project Structure&gt;&gt;Project&gt;&gt;Project SDK, 按new ,选择JAVA jdk. 默认会自动识别，否则手动下载指定xxx/1.8.0-openjdk-amd64)(一般要求1.8版本) ![01](http://source.jijing.site/IDEA/01.png) setting scala JDK, 下载scala 太慢，可以直接brows选择 你的ivy2目录，如果是mac隐藏目录，可以按shift + command + .切换是否显示隐藏目录 如果你的ivy2目录下有不同版本的scala，默认会全部倒入，只选择你要安装的版本号，其他版本list按delete删除。 restart IDEA build.sbt 设置正确的版本依赖 set root directory Rigth click on project root dir “rocket-chip” ,右键选择Mark Directory as &gt;&gt; Sources Root IDE主要用来写代码，但是不推荐在IDED 内部Build，在terminal 利用Makefile来维护和build 会更可靠。","link":"/riscv/20181130_idea_scala_config.html"},{"title":"Makefile 笔记","text":"规则伪目标变量变量定义的3种方式 1 foo = bar (递归展开式变量) 会在引用$(foo)地方原地替换，直到不能再替换，这种方式称之为递归展开式变量 1234foo = $(bar)bar = $(ugh)ugh = Huh?all @echo $(foo) 以上例子会在@echo $(foo) 地方递归展开 缺点一 ： 是当嵌套定义 foo = $(foo) bar 时讲进入死循环，导致Make失败 其他例子 x = $(y) y = $(x) $(z) 同样会陷入死循环，所以这种定义方法只推荐在不引用变量的时候应用 缺点二 这种定义中如果使用函数，只会在变量被引用时展开，而不是在定义时展开 会使得Make的效率降低，另外有可能会在变量函数的引用会出现非预期结果，特别当变量 定义引用到shell wildcard 函数的情况下，出现不可控的结果 123456x = fooy = $(x) bar //$(x) 不会被立即替换，只有在$(y)被用到的地方才用x的值替换x = later //将会覆盖 原来的 x , 等价于y = later barx = later 2 foo := bar (直接展开式变量) 123456x := fooy := $(x) bar ; 会立即替换成 foo barx := later 等价于y := foo barx := later bar 在复杂的Makefile中，推荐使用立即展开式变量，变量的定义会比较明确 ，也和大多数变成语言中的变量定义使用方法一致。 尽量避免和减少使用第一种递归式变量的使用 定义空格 dir := /foo/bar # directory to put the frobs in 变量“dir”的值是“/foo/bar ”（后面有 4 个空格），这可能并不是想要实现的。如果一个文件以它作为路径来表示“$(dir)/file”，那么大错特错了。 在书写 Makefile 时。推荐将注释书写在独立的行或者多行，防止出现上边例子中 的意外情况，而且将注释书写在独立的行也使得 Makefile 清晰，便于阅读。对于特殊 的定义，比如定义包含一个或者多个空格空格的变量时进行详细地说明和注释。 如果定义个空格变量 12nullstring :=space := $(nullstring) # end of the line 3 foo ?= bar 条件赋值操作符 只有变量之前没有赋值的情况下才会对这个变量赋值，如果之前已经定义了，就不改变原来的值 12345FOO ?= bar其等价于：ifeq ($(origin FOO), undefined) FOO = barendif 4 foo += jar 追加变量值 123456objects = main.o foo.o bar.o utils.oobjects += another.o上边的两个操作之后变量“objects”的值就为：“main.o foo.o bar.o utils.o another.o”。使用“+=”操作符，相当于：objects = main.o foo.o bar.o utils.oobjects := $(objects) another.o 5 define 定义多行变量 1234define two-linesecho fooecho $(bar)endef 6 override 变量 123456override foo = bar override foo := bar override define two-linesfoo$(bar)endef override定义变量是，防止变量的值被命令行指定 变量的高级用法变量的替换引用格式为“$(VAR:A=B)”（或者“${VAR:A=B}”），意思是，替换变量“VAR”中所有“A”字符结尾的字为“B”结尾的字。“结尾”的含义是空格之前（变量值多个字之间使用空格分开）。而对于变量其它部分的“A”字符不进行替换。例如：12foo := a.o b.o c.obar := $(foo:.o=.c) 变量的替换引用其实是函数“patsubst”（参考 8.2 文本处理函数 一节）的一个简化实现所实现功能相同。例如：12foo := a.o b.o c.obar := $(foo:%.o=%.c) 这个例子同样使变量“bar”的值为“a.c b.c c.c”。这种格式的替换引用方式比第一种方式更通用 变量的嵌套引用1234x = $(y)y = zz = Helloa := $($(x)) a的值最后为Hello，嵌套引用往往最后一个变量定义要用立即展开变量定义,有点像C语言的指针 函数","link":"/riscv/20181128_makefile_acc.html"},{"title":"RISCV 编译 Link探究","text":"问题： 如何将代码编译到指定的mem地址？在用$RISCV/bin/riscv64-unknown-elf-gcc hello.c时生成的目标文件默认的都是从0x0000_1000地址开始，如何自定义指定到从0x8000_0000地址开始？那么就得熟悉连接器的原理 默认链接脚本gcc在编译和链接的时候，如果不指定链接脚本，会指向默认的链接脚本默认的链接脚本可以用 $RISCV/bin/riscv64-unknown-elf-ld -verbose 来查看 如何更改链接脚本12345678SECTIONS{ . = 0x8000000; .text : { *(.text) } . = 0x9000000; .data : { *(.data) } .bss : { *(.bss) }} 在编译时指定$RISCV/bin/riscv64-unknown-elf-gcc -T link.lds hello.c -o hello.out默认会报错，没有指定_start 就没有办法分配堆和栈空间12345xxxx/bin/../lib/gcc/riscv64-unknown-elf/8.1.0/../../../../riscv64-unknown-elf/lib/rv64imafdc/lp64d/crt0.o: In function `_start':(.text+0x0): undefined reference to `__global_pointer$'(.text+0x8): undefined reference to `_edata'(.text+0x10): undefined reference to `_end'collect2.exe: error: ld returned 1 exit status 简单起见添加option -nostartfiles 忽略指定_start$RISCV/bin/riscv64-unknown-elf-gcc -T link.lds hello.c -o hello.out -nostartfiles然后$RISCV/bin/riscv64-unknown-elf-objdump -d hello.out &gt; hello.dump可以看到.text 从0x8000000地址开始123456789hello.out: file format elf64-littleriscvDisassembly of section .text:0000000008000000 &lt;main&gt;: 8000000: 1101 addi sp,sp,-32 8000002: ec06 sd ra,24(sp) 8000004: e822 sd s0,16(sp) 8000006: 1000 addi s0,sp,32 完整的参考实例参见hbird-e-sdk是RISCV开源E200系列开发板的sdk https://github.com/SI-RISCV/hbird-e-sdk ./generate_test4sim.csh 生成指定地址的out以及.verilog 二进制可读文件 编译新的case只需make dasm PROGRAM=hellowrold BOARD=hbird-e200 CORE=e203 DOWNLOAD=itcm即可展看来看，实际上执行的是123456789101112make -C software/hello_world \\ SIZE=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-size \\ CC=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-gcc \\ RISCV_ARCH=rv32imac \\ REPLACE_PRINTF=0 \\ NANO_PFLOAT=1 \\ USE_NANO=1 \\ DOWNLOAD=itcm \\ RISCV_ABI=ilp32 \\ AR=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-ar \\ BSP_BASE=/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp \\ BOARD=hbird-e200 \\ 具体执行的是hbird-e-sdk/Makefile下的makefile，具体过程如下：12345678910111213141516171819202122232425262728# cd /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/software/hello_world$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-gcc -O2 -g -march=rv32imac -mabi=ilp32 \\ -ffunction-sections -fdata-sections -fno-common \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/drivers \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/include \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/start.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/entry.o \\ hello_world.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/init.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/close.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/_exit.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/write_hex.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/fstat.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/isatty.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/lseek.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/read.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/sbrk.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/write.o \\ -o hello_world \\ -T /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/link_itcm.lds -nostartfiles \\ -Wl,--gc-sections -Wl,--check-sections --specs=nano.specs -u _printf_float \\ -L/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env \\$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-size hello_world# Leaving /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/software/hello_world 还可以在bsp/env/common.k 中添加一行查看C编译成的hello.s汇编程序文件 1234$(TARGET): $(LINK_OBJS) $(LINK_DEPS) $(CC) $(CFLAGS) $(INCLUDES) $@.c -S #添加该行，可以在对于目录下生成 .s汇编程序 $(CC) $(CFLAGS) $(INCLUDES) $(LINK_OBJS) -o $@ $(LDFLAGS) $(SIZE) $@ 具体link脚本先关细节可见：hbird-e-sdk/bsp/hbird-e200/env/common.mk 文件中 LDFLAGS +=的定义对应脚本 hbird-e-sdk/bsp/hbird-e200/env/link_itcm.lds 下载目标ITCM 链接细节的描述 hbird-e-sdk/bsp/hbird-e200/env/link_flash.lds 下载目标Flash 链接细节的描述 hbird-e-sdk/bsp/hbird-e200/env/link_flashxip.lds 编译好的二进制可读文件在e200的vsim目录下make run_test TESTCASE=$PWD/../riscv-tools/fpga_test4sim/hello4sim/hello_world 即可启动仿真环境 lds 链接脚本的原理介绍完整的文章 链接器把一个或多个输入文件合成一个输出文件.输入文件: 目标文件或链接脚本文件.输出文件: 目标文件或可执行文件. 目标文件(包括可执行文件)具有固定的格式, 在UNIX或GNU/Linux平台下, 一般为ELF格式有时把输入文件内的section称为输入section(input section), 把输出文件内的section称为输出section(output sectin).目标文件的每个section至少包含两个信息: 名字和大小. 大部分section还包含与它相关联的一块数据, 称为section contents(section内容). 一个section可被标记为“loadable(可加载的)”或“allocatable(可分配的)”.loadable section: 在输出文件运行时, 相应的section内容将被载入进程地址空间中.allocatable section: 内容为空的section可被标记为“可分配的”. 在输出文件运行时, 在进程地址空间中空出大小同section指定大小的部分. 某些情况下, 这块内存必须被置零.如果一个section不是“可加载的”或“可分配的”, 那么该section通常包含了调试信息. 可用objdump -h命令查看相关信息.每个“可加载的”或“可分配的”输出section通常包含两个地址: VMA(virtual memory address虚拟内存地址或程序地址空间地址) LMA(load memory address加载内存地址或进程地址空间地址). 通常VMA和LMA是相同的. 在目标文件中, loadable或allocatable的输出section有两种地址: VMA(virtual Memory Address)和LMA(Load Memory Address). VMA是执行输出文件时section所在的地址, 而LMA是加载输出文件时section所在的地址. 一般而言, 某section的VMA == LMA. 但在嵌入式系统中, 经常存在加载地址和执行地址不同的情况: 比如将输出文件加载到开发板的flash中(由LMA指定), 而在运行时将位于flash中的输出文件复制到SDRAM中(由VMA指定).可这样来理解VMA和LMA, 假设: (1) .data section对应的VMA地址是0×08050000, 该section内包含了3个32位全局变量, i、j和k, 分别为1,2,3. (2) .text section内包含由”printf( “j=%d “, j );”程序片段产生的代码. 连接时指定.data section的VMA为0×08050000, 产生的printf指令是将地址为0×08050004处的4字节内容作为一个整数打印出来。如果.data section的LMA为0×08050000，显然结果是j=2如果.data section的LMA为0×08050004，显然结果是j=1还可这样理解LMA:.text section内容的开始处包含如下两条指令(intel i386指令是10字节，每行对应5字节):jmp 0×08048285movl $0×1,%eax如果.text section的LMA为0×08048280, 那么在进程地址空间内0×08048280处为“jmp 0×08048285”指令, 0×08048285处为movl $0×1,%eax指令. 假设某指令跳转到地址0×08048280, 显然它的执行将导致%eax寄存器被赋值为1.如果.text section的LMA为0×08048285, 那么在进程地址空间内0×08048285处为“jmp 0×08048285”指令, 0×0804828a处为movl $0×1,%eax指令. 假设某指令跳转到地址0×08048285, 显然它的执行又跳转到进程地址空间内0×08048285处, 造成死循环.符号(symbol): 每个目标文件都有符号表(SYMBOL TABLE), 包含已定义的符号(对应全局变量和static变量和定义的函数的名字)和未定义符号(未定义的函数的名字和引用但没定义的符号)信息.符号值: 每个符号对应一个地址, 即符号值(这与c程序内变量的值不一样, 某种情况下可以把它看成变量的地址). 可用nm命令查看它们. (nm的使用方法可参考本blog的GNU binutils笔记) 脚本格式链接脚本由一系列命令组成, 每个命令由一个关键字(一般在其后紧跟相关参数)或一条对符号的赋值语句组成. 命令由分号‘;’分隔开.文件名或格式名内如果包含分号’;’或其他分隔符, 则要用引号‘”’将名字全称引用起来. 无法处理含引号的文件名./ /之间的是注释。","link":"/riscv/20181127_riscv_link.html"},{"title":"RISCV GDB debug调试","text":"RISCV-GDB启动步骤 hello.c12345678#include &lt;stdio.h&gt;int main(){ long a = 0x876543210 ; float pi = 3.1415926 ; printf(\"Hello %s!\\n\",\"World\"); a = a*pi; return a ;} 如何生成汇编代码riscv64-unknown-elf-gcc -S hello.c 只会生成汇编代码hello.s 不会生成.out文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC2: .string &quot;World&quot; .align 3.LC3: .string &quot;Hello %s!\\n&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd ra,24(sp) sd s0,16(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) sd a5,-24(s0) lui a5,%hi(.LC1) flw fa5,%lo(.LC1)(a5) fsw fa5,-28(s0) lui a5,%hi(.LC2) addi a1,a5,%lo(.LC2) lui a5,%hi(.LC3) addi a0,a5,%lo(.LC3) call printf ld a5,-24(s0) fcvt.s.l fa4,a5 flw fa5,-28(s0) fmul.s fa5,fa4,fa5 fcvt.l.s a5,fa5,rtz sd a5,-24(s0) ld a5,-24(s0) sext.w a5,a5 mv a0,a5 ld ra,24(sp) ld s0,16(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 .align 2.LC1: .word 1078530010 .ident &quot;GCC: (GNU) 8.1.0&quot; 如何反汇编.out文件首先生成.out文件riscv64-unknown-elf-gcc -o hello.out hello.c 然后反汇编 riscv64-unknown-elf-objdump -d hello.out &gt; hello_disassemble.s 即可查看反汇编代码,搜索main函数如下，当然也包括其他内置函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748hello.out: file format elf64-littleriscvDisassembly of section .text:00000000000100b0 &lt;_start&gt;: 100b0: 0000d197 auipc gp,0xd 100b4: fd818193 addi gp,gp,-40 # 1d088 &lt;__global_pointer$&gt; 100b8: 84818513 addi a0,gp,-1976 # 1c8d0 &lt;_edata&gt; 100bc: 8d818613 addi a2,gp,-1832 # 1c960 &lt;_end&gt; ..... ...000000000001038c &lt;printf&gt;: 1038c: 711d addi sp,sp,-96 1038e: f832 sd a2,48(sp) 10390: fc36 sd a3,56(sp) .... ..0000000000010198 &lt;main&gt;: 10198: 1101 addi sp,sp,-32 1019a: ec06 sd ra,24(sp) 1019c: e822 sd s0,16(sp) 1019e: 1000 addi s0,sp,32 101a0: 67e9 lui a5,0x1a 101a2: a687b783 ld a5,-1432(a5) # 19a68 &lt;__clzdi2+0x54&gt; 101a6: fef43423 sd a5,-24(s0) 101aa: 67e9 lui a5,0x1a 101ac: a707a787 flw fa5,-1424(a5) # 19a70 &lt;__clzdi2+0x5c&gt; 101b0: fef42227 fsw fa5,-28(s0) 101b4: 67e9 lui a5,0x1a 101b6: a5078593 addi a1,a5,-1456 # 19a50 &lt;__clzdi2+0x3c&gt; 101ba: 67e9 lui a5,0x1a 101bc: a5878513 addi a0,a5,-1448 # 19a58 &lt;__clzdi2+0x44&gt; 101c0: 1cc000ef jal ra,1038c &lt;printf&gt; 101c4: fe843783 ld a5,-24(s0) 101c8: d027f753 fcvt.s.l fa4,a5 101cc: fe442787 flw fa5,-28(s0) 101d0: 10f777d3 fmul.s fa5,fa4,fa5 101d4: c02797d3 fcvt.l.s a5,fa5,rtz 101d8: fef43423 sd a5,-24(s0) 101dc: fe843783 ld a5,-24(s0) 101e0: 2781 sext.w a5,a5 101e2: 853e mv a0,a5 101e4: 60e2 ld ra,24(sp) 101e6: 6442 ld s0,16(sp) 101e8: 6105 addi sp,sp,32 101ea: 8082 ret .... ... gdb 查看CPU寄存器-print $x0-p $x0-p $pc-info reg-display $x0 ;每跑一步都会显示寄存器-ni ;next inst","link":"/riscv/20181125_gdb_debug.html"},{"title":"RISCV C开发调试笔记","text":"hello.c12345678#include &lt;stdio.h&gt;int main(){ long a = 0x876543210 ; float pi = 3.1415926 ; printf(\"Hello %s!\\n\",\"World\"); a = a*pi; return a ;} 如何指定target编译riscv64-unknown-elf-gcc -c hello.c mylib.c i2c.c 只会编译生成hello.o myprint.o i2c.o ,但不会生成.out可执行文件 12``````mylib.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162````riscv64-unknown-elf-gcc hello.c mylib i2c.c -o hello_exec.out ` 不仅会编译还会链接成最终的可执行文件hello.out链接后的地址从101b0开始### 如何生成汇编代码`riscv64-unknown-elf-gcc -S hello.c` 只会生成汇编代码hello.s 不会生成.out文件```s .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC2: .string &quot;World&quot; .align 3.LC3: .string &quot;Hello %s!\\n&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd ra,24(sp) sd s0,16(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) sd a5,-24(s0) lui a5,%hi(.LC1) flw fa5,%lo(.LC1)(a5) fsw fa5,-28(s0) lui a5,%hi(.LC2) addi a1,a5,%lo(.LC2) lui a5,%hi(.LC3) addi a0,a5,%lo(.LC3) call printf ld a5,-24(s0) fcvt.s.l fa4,a5 flw fa5,-28(s0) fmul.s fa5,fa4,fa5 fcvt.l.s a5,fa5,rtz sd a5,-24(s0) ld a5,-24(s0) sext.w a5,a5 mv a0,a5 ld ra,24(sp) ld s0,16(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 .align 2.LC1: .word 1078530010 .ident &quot;GCC: (GNU) 8.1.0&quot; 如何反汇编.out文件首先生成.out文件riscv64-unknown-elf-gcc -o hello.out hello.c 然后反汇编 riscv64-unknown-elf-objdump -d hello.out &gt; hello_disassemble.s 即可查看反汇编代码,搜索main函数如下，当然也包括其他内置函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748hello.out: file format elf64-littleriscvDisassembly of section .text:00000000000100b0 &lt;_start&gt;: 100b0: 0000d197 auipc gp,0xd 100b4: fd818193 addi gp,gp,-40 # 1d088 &lt;__global_pointer$&gt; 100b8: 84818513 addi a0,gp,-1976 # 1c8d0 &lt;_edata&gt; 100bc: 8d818613 addi a2,gp,-1832 # 1c960 &lt;_end&gt; ..... ...000000000001038c &lt;printf&gt;: 1038c: 711d addi sp,sp,-96 1038e: f832 sd a2,48(sp) 10390: fc36 sd a3,56(sp) .... ..0000000000010198 &lt;main&gt;: 10198: 1101 addi sp,sp,-32 1019a: ec06 sd ra,24(sp) 1019c: e822 sd s0,16(sp) 1019e: 1000 addi s0,sp,32 101a0: 67e9 lui a5,0x1a 101a2: a687b783 ld a5,-1432(a5) # 19a68 &lt;__clzdi2+0x54&gt; 101a6: fef43423 sd a5,-24(s0) 101aa: 67e9 lui a5,0x1a 101ac: a707a787 flw fa5,-1424(a5) # 19a70 &lt;__clzdi2+0x5c&gt; 101b0: fef42227 fsw fa5,-28(s0) 101b4: 67e9 lui a5,0x1a 101b6: a5078593 addi a1,a5,-1456 # 19a50 &lt;__clzdi2+0x3c&gt; 101ba: 67e9 lui a5,0x1a 101bc: a5878513 addi a0,a5,-1448 # 19a58 &lt;__clzdi2+0x44&gt; 101c0: 1cc000ef jal ra,1038c &lt;printf&gt; 101c4: fe843783 ld a5,-24(s0) 101c8: d027f753 fcvt.s.l fa4,a5 101cc: fe442787 flw fa5,-28(s0) 101d0: 10f777d3 fmul.s fa5,fa4,fa5 101d4: c02797d3 fcvt.l.s a5,fa5,rtz 101d8: fef43423 sd a5,-24(s0) 101dc: fe843783 ld a5,-24(s0) 101e0: 2781 sext.w a5,a5 101e2: 853e mv a0,a5 101e4: 60e2 ld ra,24(sp) 101e6: 6442 ld s0,16(sp) 101e8: 6105 addi sp,sp,32 101ea: 8082 ret .... ... 更多信息尝试riscv64-unknown-elf-objdump --help123456789101112131415161718192021Usage: objdump &lt;option(s)&gt; &lt;file(s)&gt; Display information from object &lt;file(s)&gt;. At least one of the following switches must be given: -a, --archive-headers Display archive header information -f, --file-headers Display the contents of the overall file header -h, --[section-]headers Display the contents of the section headers -x, --all-headers Display the contents of all headers -d, --disassemble Display assembler contents of executable sections -D, --disassemble-all Display assembler contents of all sections -s, --full-contents Display the full contents of all sections requested -G, --stabs Display (in raw form) any STABS info in the file.... Display DWARF info in the file -t, --syms Display the contents of the symbol table(s) -T, --dynamic-syms Display the contents of the dynamic symbol table.... The following switches are optional: -b, --target=BFDNAME Specify the target object format as BFDNAME -m, --architecture=MACHINE Specify the target architecture as MACHINE 如何指定target编译riscv64-unknown-elf-rvgcc --target-help显示更多指定目标编译 默认 riscv64-unknown-elf-rvgcc 会生成RV64IMADF，如果你指向生成RV32IM指令集的机器码，如下操作 rvgcc -march=rv32im -mabi=ilp32 -o b_rv32im.out b.c 注意如果用-march=rvxxxx必须要加-mbi=xxxx RISC-V 编译器支持多个 ABI，具体取决于 F 和 D 扩展是否存在。RV32 的 ABI 分别名为 ilp32，ilp32f 和 ilp32d。ilp32 表示 C 语言的整型（int），长整型（long）和指针（pointer）都是 32 位，可选后缀表示如何传递浮点参数。在 lip32 中，浮点参数在整数寄存器中传递；在 ilp32f 中，单精度浮点参数在浮点寄存器中传递；在 ilp32d 中，双精度浮点参数也在浮点寄存器中传递。 自然，如果想在浮点寄存中传递浮点参数，需要相应的浮点 ISA 添加 F 或 D 扩展（见第 5 章）。因此要编译 RV32I 的代码（GCC 选项-march=rv32i），必须使用 ilp32 ABI（GCC选项-mabi=lib32）。反过来，调用约定并不要求浮点指令一定要使用浮点寄存器，因此RV32IFD 与 ilp32，ilp32f 和 ilp32d 都兼容。 对于C代码1234void main(){ int val = 0xf; val++;} gcc 使用rv32im，和默认64位编译的区别如下可以看出32im的指令都是16bit， 而右边指令集有采纳C，有压缩到16bit gdb 查看CPU寄存器RISCV-GDB启动步骤 print $x0 p $x0 p $pc info reg display $x0 ;每跑一步都会显示寄存器 ni ;next inst","link":"/riscv/20181120_riscv_c_dev_setp.html"},{"title":"IPC进程通信、消息队列","text":"计算机进程通信原理、IPC、消息队列，常见的方法 共享内存模式 消息传递模式 共享文件模式 主要使用的是前两种方法 多处理器之间通信处理器之间不能通过消息传递模式通信，只能共享内存处理器本身是异步执行的，消息队列没办法实现（接受消息和消耗消息有可能会冲突）而共享内存的方法也有可能会导致冲突，可以为不同处理器划分不同地址空间来避免冲突 单处理器进程通信进程之间的通信最常见最安全的方法就是消息队列。每个进程会维护一个消息队列（常见的是FIFO队列，也有带优先级的队列本文不做讨论） 进程A给进程B发消息，首先获取进程B消息队列（链表）的地址，将消息插入到链表后面。当进程B执行是会去取消息队列最前面的消息然后执行。由于进程A进程B是在同一处理器上占不同的时间片（跟操作系统进程的调度算法有关），同一时刻消息队列不可能即recive 又 consume，所以不存在队列读写冲突的问题。 消息可以是简单的数据编码标志，也可以携带数据（数据起始地址以及长度），或者其他数据结构体格式 scala 的Actor的消息传递也是用此方式实现。","link":"/sicp/ipc_msg_communication.html"},{"title":"RISCV 汇编指令调试","text":"RISCV汇编指令调试，立即数使用分析新建文件 test.s 123456.global main.textmain: li a5, 0x12345678 ret riscv.....gcc test.s 编译成汇编代码riscv.....gdb test.s 用调试器运行 进入调试器12345(gdb) disassemble mainDump of assembler code for function _init:0x000000000001019c &lt;+182&gt;: lui a5,0x123450x00000000000101a0 &lt;+186&gt;: addiw a5,a5,16560x00000000000101a4 &lt;+190&gt;: ret 在windows 和Ubuntu上打印的汇编信息由所区别，Windows上会打印额外的很多信息，但是从0x0000000001019c开始的3行信息都是和Ubuntu上一致。一般情况下RISCV程序地址从0x10000开始其余信息可能是一些stdio程序，并不是很清楚 用Spike 调试12345678910111213141516171819202122$: $RISCV/bin/spike -d pk a.out: until pc 0 0x1019c: reg 0 a50x0000000000000002: reg 0 #查看core0 的所有32个寄存器zero: 0x0000000000000000 ra : 0x00000000000100e2 sp : 0x000000007f7e9b50 gp : 0x00000000000123d0 tp : 0x0000000000000000 t0 : 0x00000000000100c8 t1 : 0x0000000000000000 t2 : 0x0000000000000000 s0 : 0x0000000000000000 s1 : 0x0000000000000000 a0 : 0x0000000000000001 a1 : 0x000000007f7e9b58 a2 : 0x0000000000000000 a3 : 0x0000000000000001 a4 : 0x0000000000000010 a5 : 0x0000000000000002 a6 : 0x000000000000001f a7 : 0x0000000000000000 s2 : 0x0000000000000000 s3 : 0x0000000000000000 s4 : 0x0000000000000000 s5 : 0x0000000000000000 s6 : 0x0000000000000000 s7 : 0x0000000000000000 s8 : 0x0000000000000000 s9 : 0x0000000000000000 s10 : 0x0000000000000000 s11 : 0x0000000000000000 t3 : 0x0000000000000000 t4 : 0x0000000000000000 t5 : 0x0000000000000000 t6 : 0x0000000000000000 : help #查看调试命令: run 1 #单步执行core 0: 0x000000000001019c (0x123457b7) lui a5, 0x12345: reg 0 a50x0000000012345000 #可以看到将原来的 0x0000000000000002 覆盖成 0x12345000 ,低12bit覆盖为0: run 1 core 0: 0x00000000000101a0 (0x6787879b) addiw a5, a5, 1656: reg 0 a5 0x0000000012345678 #成功写入 试验12345main: li a5, 0x12345678 li a1, 0xabc li a2, 0x12345 ret 编译后的汇编指令12345678910(gdb) disassemble main Dump of assembler code for function main:0x000000000001019c &lt;+0&gt;: lui a5,0x123450x00000000000101a0 &lt;+4&gt;: addiw a5,a5,16560x00000000000101a4 &lt;+8&gt;: lui a1,0x1 # a1=0x00001000 , 低12bit=0 0x00000000000101a8 &lt;+12&gt;: addiw a1,a1,-1348 # hex(0x1000 - 1348) = 0xabc0x00000000000101ac &lt;+16&gt;: lui a2,0x120x00000000000101b0 &lt;+20&gt;: addiw a2,a2,8370x00000000000101b4 &lt;+24&gt;: retEnd of assembler dump. 即便是小于12bit 的立即数也不能被立即load到,因为LUI指令加载的最小数是0x1000(除了0), 所以所有小于12bit的数val还是要用两条指令完成12LUI rd, 0x1 #load rd 0x1000ADDIW rd, rs, (val-0x1000) C代码编译调试例子11234void main() { int val = 1 ; val+=3 ;} 123456789101112131415161718192021 .file &quot;a.c&quot; .option nopic .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 #sp指针默认从比较大的地址开始，反向增长开辟了32byte的空间 sd s0,24(sp) #将s0的8个字节(64bit)压入栈指针-32+24=-8 addi s0,sp,32 #然后将栈BASE地址放入s0 (s0 被用来当中间寄存器) li a5,1 #加载立即数1到a5 （小于32位的立即数会直接通过立即数指令加载） 否则就需要在内存开辟双字节整形，然后通过ld 加载 sw a5,-20(s0) #给val开辟栈空间，变量都会在栈里面，只有申请内存空间才会在dynamicdata(堆) lw a5,-20(s0) #再读回来 addiw a5,a5,3 #+3 sw a5,-20(s0) #再写回去,(不开优化，每一次操作都会存取) nop ld s0,24(sp) #恢复s0 寄存器 addi sp,sp,32 #恢复栈指针 jr ra #main函数返回 .size main, .-main .ident &quot;GCC: (GNU) 8.1.0&quot; 编译后进gdb调试 a.out123456789101112131415(gdb) disassemble main Dump of assembler code for function main:0x000000000001019c &lt;+0&gt;: addi sp,sp,-320x000000000001019e &lt;+2&gt;: sd s0,24(sp) #表示sp寄存器的内容+立即数偏移240x00000000000101a0 &lt;+4&gt;: addi s0,sp,320x00000000000101a2 &lt;+6&gt;: li a5,10x00000000000101a4 &lt;+8&gt;: sw a5,-20(s0)0x00000000000101a8 &lt;+12&gt;: lw a5,-20(s0)0x00000000000101ac &lt;+16&gt;: addiw a5,a5,10x00000000000101ae &lt;+18&gt;: sw a5,-20(s0)0x00000000000101b2 &lt;+22&gt;: nop0x00000000000101b4 &lt;+24&gt;: ld s0,24(sp)0x00000000000101b6 &lt;+26&gt;: addi sp,sp,320x00000000000101b8 &lt;+28&gt;: retEnd of assembler dump. 定义大于32bit的整数12345long main(){ long val = 0x876543210; //超过32位的长整数 val+=1; return val;} 不开启优化123456789101112131415161718192021222324252627 .file &quot;a.c&quot; .option nopic .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd s0,24(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) #load doubleworld from (.LC0)地址 sd a5,-24(s0) ld a5,-24(s0) addi a5,a5,1 sd a5,-24(s0) ld a5,-24(s0) mv a0,a5 ld s0,24(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 #开辟一块双字节的MEM空间， .ident &quot;GCC: (GNU) 8.1.0&quot; 发现超过32bit的整数，不能通过立即数加载到寄存器（立即数受限于指令的长度最大只能是32bit，而且需要两条指令完成), 只能在内存中开辟一块地址先存放0x876543210,然后ld a5,该地址 例子21234#include &lt;stdio.h&gt;void main(){ printf(\"hello world\");} hello.s 查看汇编代码1234567891011121314151617181920212223242526 .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC0: .string &quot;hello world&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-16 #sp 开辟16byte栈空间 sp=-16 sd ra,8(sp) #将ra的8Byte（64bit)内容从sp=-8处压栈 , 0 ~-8 存ra的值 sd s0,0(sp) #将s0的8Byte（64bit)内容从sp=-16处压栈,-8 ~-16存s0的值 addi s0,sp,16 #将sp=offset0的值存入s0 lui a5,%hi(.LC0) #计算string .LC0的地址，存入a0 addi a0,a5,%lo(.LC0) #这两条指令等价于 伪指令 li &amp;(.LC0) call printf #调用 printf 函数 ,printf 使用a0的内容作为参数 nop ld ra,8(sp) #恢复栈 0~-8 的内容到ra ld s0,0(sp) #恢复栈-8~-16的内容到s0 addi sp,sp,16 #栈指针恢复到0 jr ra #返回ra .size main, .-main .ident &quot;GCC: (GNU) 8.1.0&quot; gdb hell.out 查看汇编以后的机器码123456789101112131415(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: sd s0,0(sp) 0x000000000001019e &lt;+6&gt;: addi s0,sp,16 0x00000000000101a0 &lt;+8&gt;: lui a5,0x1a # (.LC0)的起始地址就是0x19a10 0x00000000000101a2 &lt;+10&gt;: addi a0,a5,-1520 # 0x19a10 0x00000000000101a6 &lt;+14&gt;: jal ra,0x10354 &lt;printf&gt; # pc+4 存入ra, 跳转到pc+0x10354*2的printf函数地址 0x00000000000101aa &lt;+18&gt;: nop 0x00000000000101ac &lt;+20&gt;: ld ra,8(sp) # 恢复ra 0x00000000000101ae &lt;+22&gt;: ld s0,0(sp) # 恢复s0 0x00000000000101b0 &lt;+24&gt;: addi sp,sp,16 # 释放栈 0x00000000000101b2 &lt;+26&gt;: retEnd of assembler dump. print内容稍加修改1234#include &lt;stdio.h&gt;void main(){ printf(\"Hello %s!\\n\",\"World\");} 查看效果1234567891011121314151617(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: sd s0,0(sp) 0x000000000001019e &lt;+6&gt;: addi s0,sp,16 0x00000000000101a0 &lt;+8&gt;: lui a5,0x1a 0x00000000000101a2 &lt;+10&gt;: addi a1,a5,-1504 # 0x19a20 #加载字符串&quot;Hello %s!\\n&quot; 的地址 0x00000000000101a6 &lt;+14&gt;: lui a5,0x1a 0x00000000000101a8 &lt;+16&gt;: addi a0,a5,-1496 # 0x19a28 #加载字符串&quot;Wrold&quot;的地址 0x00000000000101ac &lt;+20&gt;: jal ra,0x1035a &lt;printf&gt; #调用printf, printf会从a0,a1内获取参数 0x00000000000101b0 &lt;+24&gt;: nop 0x00000000000101b2 &lt;+26&gt;: ld ra,8(sp) 0x00000000000101b4 &lt;+28&gt;: ld s0,0(sp) 0x00000000000101b6 &lt;+30&gt;: addi sp,sp,16 0x00000000000101b8 &lt;+32&gt;: retEnd of assembler dump. 字符串的只需要知道起始地址即可，结束位由隐藏的固定格式构成 例31234567#include &lt;stdio.h&gt;int main(){ int a = 2 ; printf(\"Hello %s!\\n\",\"World\"); a++; return a ;} 查看机器码1234567891011121314151617181920212223(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-32 # 开辟32Byte栈空间 0x000000000001019a &lt;+2&gt;: sd ra,24(sp) # 0 ~-8 存ra 0x000000000001019c &lt;+4&gt;: sd s0,16(sp) #-9 ~-16存s0 0x000000000001019e &lt;+6&gt;: addi s0,sp,32 # 栈根给s0 0x00000000000101a0 &lt;+8&gt;: li a5,2 0x00000000000101a2 &lt;+10&gt;: sw a5,-20(s0) # 2存入a5 压栈到-16~-20 0x00000000000101a6 &lt;+14&gt;: lui a5,0x1a # a0 0x00000000000101a8 &lt;+16&gt;: addi a1,a5,-1488 # 0x19a30 #加载字符串&quot;Hello %s!\\n&quot; 的地址到a1 0x00000000000101ac &lt;+20&gt;: lui a5,0x1a 0x00000000000101ae &lt;+22&gt;: addi a0,a5,-1480 # 0x19a38 #加载字符串&quot;World&quot; 的地址到a0 0x00000000000101b2 &lt;+26&gt;: jal ra,0x1036e &lt;printf&gt; 0x00000000000101b6 &lt;+30&gt;: lw a5,-20(s0) #从栈-20 读出32bit=4Byte 出来 0x00000000000101ba &lt;+34&gt;: addiw a5,a5,1 0x00000000000101bc &lt;+36&gt;: sw a5,-20(s0) 0x00000000000101c0 &lt;+40&gt;: lw a5,-20(s0) 0x00000000000101c4 &lt;+44&gt;: mv a0,a5 #a++结果从栈中读出给a0 ,a0 a1 寄存器常用作返回值 0x00000000000101c6 &lt;+46&gt;: ld ra,24(sp) 0x00000000000101c8 &lt;+48&gt;: ld s0,16(sp) 0x00000000000101ca &lt;+50&gt;: addi sp,sp,32 0x00000000000101cc &lt;+52&gt;: ret #返回End of assembler dump. 开启优化选项 -O1234567891011121314(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: lui a1,0x1a 0x00000000000101a0 &lt;+8&gt;: addi a1,a1,-1520 # 0x19a10 0x00000000000101a4 &lt;+12&gt;: lui a0,0x1a 0x00000000000101a8 &lt;+16&gt;: addi a0,a0,-1512 # 0x19a18 0x00000000000101ac &lt;+20&gt;: jal ra,0x10358 &lt;printf&gt; 0x00000000000101b0 &lt;+24&gt;: li a0,3 # 2 + 1 =3 在编译阶段就计算完 0x00000000000101b2 &lt;+26&gt;: ld ra,8(sp) 0x00000000000101b4 &lt;+28&gt;: addi sp,sp,16 0x00000000000101b6 &lt;+30&gt;: retEnd of assembler dump. 总结LUI 指令会讲20比特的立即数放到 寄存器的31:12位置，并且将低12bit覆盖为0 ADDIW 指令会将 rs1 寄存器的值导入到rd 寄存器，并且用立即数[11:0] 覆盖 rd的低12比特 LU是伪指令，因为汇编指令的立即数肯定小于32bit，所以为了实现完整的32bit的立即数load 编译器使用了2条指令LUI,ADDIW 实现了LU的功能 对于一般变量比如int类型，会分配给栈来存放 如果比较大的常数变量，超过32bit或者64bit的数， 地址会分配堆内存给地址 对于数字串分配堆内存地址 参考-RISC-V Reference Card(指令绿卡片) -RISC-V 指令集编码","link":"/riscv/20181116_RISCV_inst_test.html"},{"title":"综合时序分析回顾","text":"时序分析静态时序分析工具STA，在分析时序的时候会统一从一个点出发开始计算分析（这样才有可行性），往往是从时钟PLL出来以后开始计算 一般情况下都会设一个clock network delay 表示从PLL 到寄存器段clk的群延迟 ，理想情况下，到每个寄存器的群延迟都是一样的（时钟balance） 看一个timing报告： 1234567891011121314151617181920212223242526272829303132333435363738394041**************************************** Startpoint: U_xx/_ram_sp1024x8/srsp_1024x8 (rising edge-triggered flip-flop clocked by clk) Endpoint: U_xx/nS_bit_reg_1_ (rising edge-triggered flip-flop clocked by clk) Path Group: clk Path Type: max Des/Clust/Port Wire Load Model Library ------------------------------------------------ xx_top ZeroWireload tef40ulp128x8hd_ph_ssg0p99v2p25vm40c Point Incr Path -------------------------------------------------------------------------- clock clk (rise edge) 0.0000 0.0000 clock network delay (ideal) 2.0000 2.0000 #时钟群延迟设为2ns xx/srsp_1024x8/CLK (sadr41p1024x8m4b1) 0.0000 2.0000 r #arrival + 2ns xx/srsp_1024x8/Q[0] (sadr41p1024x8m4b) 2.2361 4.2361 f xx/U37/X (SVN_ND2_T_2) 0.0290 4.2651 r xx/U47/X (SVN_ND2_2) 0.0323 4.2974 f .... .. xx/U188/X (SVN_EN2_F_1) 0.0956 4.8690 f xx/nS_bit_reg_1_/D (SVN_FSDPRBQ_D_4) 0.0000 4.8690 f data arrival time 4.8690 clock clk (rise edge) 3.3300 3.3300 #300Mhz = 3.33ns clock network delay (ideal) 2.0000 5.3300 #required + 2 =5.33ns clock uncertainty 0.3000 5.0300 #恶化抖动 xxx/nS_bit_reg_1_/CK (SVN_FSDPRBQ_D_4) 0.0000 5.0300 r library setup time 0.3303 4.6997 #- setup time data required time 4.6997 -------------------------------------------------------------------------- data required time 4.6997 # = clk_arvl_time - Setuptime - skew data arrival time -4.8690 # -------------------------------------------------------------------------- slack (VIOLATED) -0.1693**************************************** Clock Setup Slack = Data Required Time – Data Arrival Time Clock Arrival Time = Latch Edge + Clock Network Delay to Destination Register Data Required = Clock Arrival Time – μtSU – Setup Uncertainty Data Arrival Time = Launch Edge + Clock Network Delay Source Register + μtCO + Register-to-Register Delay","link":"/eda/timing_analysis.html"},{"title":"Terminal配置常见问题","text":"Teriminal 配置常见问题 ls后文件名包含引号,例如 'Program file' 在 ~/.zshrc 里面配置 MACOS ls 目录后没有颜色显示， 'alias ls =/bin/ls -G' , 一定要指到/bin/ls 其他","link":"/others/terminal_FAQ.html"},{"title":"SBT 版本问题","text":"QA sbt 指向 “java -Dsbt.ivy.home=/nishome/jijing/ivy2 -jar /DATA/jijing/rocket-chip/sbt-launch.jar” 现象ivy2 也是最新的，包含 org.scala-lang#scala-library;2.11.12 正确的版本号 依然会报错！！ 12345[warn] ::::::::::::::::::::::::::::::::::::::::::::::[warn] :: UNRESOLVED DEPENDENCIES ::[warn] ::::::::::::::::::::::::::::::::::::::::::::::[warn] :: org.scala-lang#scala-library;2.11.12: public: unable to get resource for org/scala-lang#scala-library;2.11.12: res=https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.pom: java.net.UnknownHostException: repo1.maven.org: Temporary failure in name resolution[warn] :::::::::::::::::::::::::::::::::::::::::::::: 原因 ~/.sbt 目录可能存在旧的版本，导致问题， 解决 删除 ~/.sbt 目录，如果联网，直接重新sbt run ，会自动下载更新，否则copy 别的机子上正确的 .sbt 到home 目录下。 IDEA，rochi-chip:sync failed ，但在terminal下正常编译 ，也是~/.sbt导致的 C 程序编译好的.out文件不能再 rocket-chip/emulator 目录下运行，而 run-asm-isa-test 则会没有问题 这是由于直接用rvgcc 编译的文件，并没有按照处理器的格式做link，因此想要正确的在处理器上运行，需要正确的link 可以参见 bootrom/link.lds 文件 ： 1234567891011 1 SECTIONS 2 { 3 ROM_BASE = 0x10000; /* ... but actually position independent */ 4 5 . = ROM_BASE; 6 .text.start : { *(.text.start) } 7 . = ROM_BASE + 0x40; 8 .text.hang : { *(.text.hang) } 9 . = ROM_BASE + 0x80;10 .rodata.dtb : { *(.rodata.dtb) }11 } rvgcc -T link.ld bootrom.S -nostdlib -static -wl,--no-gc-section -o bootrom.img 同理C代码编译的时候也需要使用正确的linkfile 文件 。 如何编译指定CPU的可执行文件必要信息： $(CC) 需要默认的target (例如intel x86, AMD64, MIPS 等等， 如果RISCV， 需要支持的指定指令集 (例如 rv32imc rv64g,rv32imdfc 等等) link 脚本，如果不指定，会有导入默认的脚本，否则需要显示指定，尤其是自己设计的处理器，需要显式的指定堆栈起始地址，程序默认存放地址，这些信息响应的也会体现在CPU硬件设计当中。需要正确match 12","link":"/eda/20181130_sy_QA.html"},{"title":"综合时序分析回顾","text":"关于计算机大小端一般计算机所讲的大小端指的是字节序的大小端，比特序一般默认都是小端无论字节序为大端还是小端 字节序大小端HSB(大端格式):按字节从大到小排布123byte0,byte1,byte2,byte3byte4,byte5,byte6,byte7... LSB(小端格式):按字节从小到大排布123byte3,byte2,byte1,byte0byte7,byte6,byte5,byte4... 比特序大小端bit大端 =[01234567]bit小端 =[76543210]一般常见的都是bit小端","link":"/others/lsb_hsb.html"},{"title":"VCS仿真option","text":"VCS、verdi的命令的配置该Makefile可作为仿真工作脚本，参考了开源处理器蜂鸟e200的仿真环境 https://github.com/SI-RISCV/e200_opensource/blob/master/vsim/bin/run.makefile 1234567891011121314151617181920212223242526272829303132333435363738394041424344RUN_DIR := ${PWD}TESTCASE := 00DUMPWAVE := 1VSRC_DIR := ${RUN_DIR}/../rtlVTB_DIR := ${RUN_DIR}/../tbINC_DIR := ${RUN_DIR}/../rtl/dir_inc_defines1INC_DIR += ${RUN_DIR}/../rtl/dir_inc_defines2# TESTNAME := $(notdir $(patsubst %.dump,%,${TESTCASE}.dump))TESTNAME := case${TESTNAME}TEST_RUNDIR := ${TESTNAME}RTL_V_FILES := $(wildcard ${VSRC_DIR}/*/*.v)TB_V_FILES := $(wildcard ${VTB_DIR}/*.v)# The following portion is depending on the EDA tools you are using, Please add them by yourself according to your EDA vendorsSIM_TOOL := vcs # this is a free solution here to use iverilog to compile the codeSIM_OPTIONS := -sverilog -debug_all +incdir+${INC_DIR} -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log SIM_EXEC := ${RUN_DIR}/simv -l sim.log +notimingcheck +nospecify +loopreport +memcbk +novoptWAV_TOOL := verdi #To-ADD: to add the waveform toolWAV_OPTIONS := -timescale=1ns/100ps +notimingcheck +nospecify #To-ADD: to add the waveform tool options WAV_PFIX := #To-ADD: to add the waveform file postfixall: runcompile.flg: ${RTL_V_FILES} ${TB_V_FILES} @-rm -rf compile.flg ${SIM_TOOL} ${SIM_OPTIONS} ${RTL_V_FILES} ${TB_V_FILES} ; touch compile.flgcompile: compile.flg wave: # gvim -p ${TESTCASE}.spike.log ${TESTCASE}.dump &amp; ${WAV_TOOL} ${WAV_OPTIONS} ${RTL_V_FILES} ${TB_V_FILES} &amp; run: compile rm -rf ${TEST_RUNDIR} mkdir ${TEST_RUNDIR} cd ${TEST_RUNDIR}; ${SIM_EXEC} +DUMPWAVE=${DUMPWAVE} +TESTCASE=${TESTCASE} |&amp; tee ${TESTNAME}.log; cd ${RUN_DIR}; .PHONY: run clean all","link":"/eda/eda_option.html"},{"title":"晶振，PLL, VCO介绍","text":"晶振，vco区别晶振分有源晶振和无源晶振，一般会产生1～200Mhz时钟频率vco亚控振荡器，可以产生比较高的频率比如2Ghz，但是不稳定 为什么既要晶振还要vco？就是为了能够产生稳定的高频时钟信号，就需要用到PLL, PLL内部会有一个VCO 产生高频时钟，通过分频器假设得到10分频的时钟2，再拿这个时钟2和晶振产生的100mhz基用鉴相器做比较，输出一个比较的波形后经过低通滤波，用输出电压控制VCO的输出, 那么就能是vco输出的高频时钟得到稳定的频率，达到了倍频的效果。 20Mhz一下的晶振基本上都是基频的器件，稳定度好，20mhz以上的晶振大多是谐波(如3次，5次谐波)稳定度差，因此强烈建议使用低频的器件，毕竟倍频器用的pll电路需要的周边配置主要是电容，电阻，电感，其稳定度和价格方面要远远浩宇晶体晶振器件。 如果只需要一个20mhz以内的时钟频率，完全可以不用pll，直接接晶振就够了 晶振一般有哪些参数晶振有几个重要参数： 1，晶体元件规格书中所指定的频率，也是工程师在电路设计和元件选购时首要关注的参数。晶振常用标称频率在1～200MHz之间，比如32768Hz、8MHz、12MHz、24MHz、125MHz等，更高的输出频率也常用PLL（锁相环）将低频进行倍频至1GHz以上。我们称之为标称频率。 2，输出信号的频率不可避免会有一定的偏差，我们用频率误差（Frequency Tolerance）或频率稳定度（Frequency Stability），用单位ppm来表示，即百万分之一（parts per million）（1/106），是相对标称频率的变化量，此值越小表示精度越高。比如，12MHz晶振偏差为±20ppm，表示它的频率偏差为12×20Hz=±240Hz，即频率范围是（11999760～12000240Hz） 3，还有一个温度频差（Frequency Stability vs Temp）表示在特定温度范围内，工作频率相对于基准温度时工作频率的允许偏离，它的单位也是ppm。 4，另外，负载电容CL（Load capacitance），它是电路中跨接晶体两端的总的有效电容（不是晶振外接的匹配电容），主要影响负载谐振频率和等效负载谐振电阻，与晶体一起决定振荡器电路的工作频率，通过调整负载电容，就可以将振荡器的工作频率微调到标称值。更准确而言，无源晶体的负载电容是一项非常重要的参数，因为无源晶体属于被动元器件，所谓的被动元器件即是自身不能工作，需要外部元器件协助工作，无源晶体即是！ 其中： CS为晶体两个管脚之间的寄生电容（又名晶振静态电容或Shunt Capacitance），在晶体的规格书上可以找到具体值，一般0.2pF~8pF不等。如图二是某32.768KHz的电气参数，其寄生电容典型值是0.85pF（在表格中采用的是Co）。 CG指的是晶体振荡电路输入管脚到GND的总电容，其容值为以下三个部分的和。 需加外晶振主芯片管脚芯到GND的寄生电容 Ci 晶体震荡电路PCB走线到到GND的寄生电容CPCB 电路上外增加的并联到GND的外匹配电容 CL1CD指的是晶体振荡电路输入管脚到GND的总电容。容值为以下三个部分的和。 需加外晶振主芯片管脚芯到GND的寄生电容, Co 晶体震荡电路PCB走线到到gnd的寄生电容，CPCB 电路上外增加的并联到GND的外匹配电容, CL2 既然晶振的负载电容是一个非常重要的参数，如果此项参数与外部电容匹配不正确会导致什么样的现象？晶振两端的等效电容与晶振标称的负载电容匹配不正确，晶振输出的谐振频率将与标称工作的工作频率会产生一定偏差（又称之为频偏），负载电容（load capacitance）主要影响负载谐振频率和等效负载谐振电阻，它与石英谐振器一起决定振荡器的工作频率，通过调整负载电容，一般可以将振荡器的工作频率调到标称值。应用时我们一般外接电容，便是为了使晶振两端的等效电容等于或接近负载电容，对于要求高的场合还要考虑ic输入端的对地电容，这样便可以使得晶振工作的频率达到标称频率。所以合理匹配合适的外加电容使晶振两端的等效电容等于或接近负载电容显得十分重要。 负载电容常用的标准值有12.5 pF，16 pF，20 pF，30pF,负载电容和谐振频率之间的关系不是线性的，负载电容变小时，频率偏差量变大；负载电容提高时，频率偏差减小。图3是一个晶体的负载电容和频率的误差的关系图。 例外情况： 现在有很多芯片内部已经增加了补偿电容（internal capacitance），所以在设计的时候，只需要选按照芯片datasheet推荐的负载电容值的选择晶体即可，不需要额外再加电容。但是因为实际设计的寄生电路的不确定性，最好还是预留CL1/CL2的位置。","link":"/others/crystals-pll-vco.html"},{"title":"Verilog仿真不打拍分析","text":"现象例如：出现： 原因这是由于采样的时钟tx_gen_symbol_clk 和数据信号subframe_start之间存在竞争关系导致的。我们的设计意图是时钟tx_gen_symbol_clk应该采到subframe_start信号的后沿有人可能会说在代码中加入延迟#1来解决，实际上不推荐这样做，还会存在两个#1的信号同样还会存在竞争。 仿真模型原理分析要搞清楚产生这种问题的原因首先要了解仿真器对于时序仿真的模型。第4级的时钟不能正常采到第3级输出的数据，但是第2级的时钟能采到第二级时钟打出来的数据（D3），原因就是，仿真器会在寄存器输出的时候添加一个虚拟的延迟δ，虽然这个虚拟延迟我们是看不到的，在仿真器上都是0，但是对于仿真器工作的时候，到遇到always采样事件时先要判断这个δ延迟，决定触发器的采样输出。（当延迟相等时，clk延迟的优先级会比data延迟的优先级高，即clk1能采到D1的前沿， 也就是我们看到的数据不打拍，这跟我们的预期是不一致的，而clk1能采不到D2的前沿，但能采到D2的后沿，这跟我们的预期一样的。这些讨论仅限于前仿，实际器件上我们必须有时序约束来保证建立保持时间，也不会存在这样的问题。但是硬件设计就是要保证仿真和物理器件一致。因此我们要注意这个现象。 如何解决 在你的TB里时钟都由一个单独的模块产生送给DUT，不管产生多少个时钟，这些时钟保证都经历了n级分频下来的然后送入DUT，这样数据就不会出现不delay的现象。","link":"/eda/verilog_simu_0delay.html"}],"tags":[{"name":"Chisel","slug":"Chisel","link":"/tags/Chisel/"},{"name":"verilog","slug":"verilog","link":"/tags/verilog/"},{"name":"firrtl","slug":"firrtl","link":"/tags/firrtl/"},{"name":"计算机","slug":"计算机","link":"/tags/计算机/"},{"name":"riscv","slug":"riscv","link":"/tags/riscv/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"开发环境","slug":"开发环境","link":"/tags/开发环境/"},{"name":"make","slug":"make","link":"/tags/make/"},{"name":"verctor","slug":"verctor","link":"/tags/verctor/"},{"name":"scala","slug":"scala","link":"/tags/scala/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/函数式编程/"},{"name":"分型","slug":"分型","link":"/tags/分型/"},{"name":"递归","slug":"递归","link":"/tags/递归/"},{"name":"SpinalHDL  Scala","slug":"SpinalHDL-Scala","link":"/tags/SpinalHDL-Scala/"},{"name":"SpinalHDL","slug":"SpinalHDL","link":"/tags/SpinalHDL/"},{"name":"Macro","slug":"Macro","link":"/tags/Macro/"}],"categories":[{"name":"chisel","slug":"chisel","link":"/categories/chisel/"},{"name":"eda","slug":"eda","link":"/categories/eda/"},{"name":"others","slug":"others","link":"/categories/others/"},{"name":"riscv","slug":"riscv","link":"/categories/riscv/"},{"name":"scala","slug":"scala","link":"/categories/scala/"},{"name":"sicp","slug":"sicp","link":"/categories/sicp/"},{"name":"spinal","slug":"spinal","link":"/categories/spinal/"}]}