{"pages":[{"title":"索引置顶","text":"Scala 笔记 2019-03-08: SCALA 程序初探.一(main函数) 2019-03-08: SCALA 程序初探.二(package组织方式) 2019-03-08: SCALA 程序初探.三(sbt组织scala代码1) 2019-03-08: SCALA 程序初探.四(sbt组织scala代码2) RISCV 开发调试 2018-11-28: IDEA scala chisel环境配置 2018-11-28: Makefile使用笔记 2018-11-27: RISC-V 编译链接脚本 2018-11-20: RISC-V C代码编译调试笔记 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-15: RISCV-Vector介绍 Chisel 笔记 2018-12-05: Chisel 示例问题汇总 2019-03-21: chisel 组合逻辑，时序逻辑写法 2019-04-01: chisel Keep变量名 2019-04-11: chisel 版本问题 2019-03-20: Chisel-Verilog 查找表优先级问题讨论 EDA工具 如何从shell中传递变量给verilog文件 EDA仿真环境Makefile配置(vcs,verdi) 时序分析回顾 Moudle名冲突解决办法 仿真不打拍 收藏 Python lambda Y组合子(Y算子)实现 通信 AGC调整 其他 Terminal Shell 常见配置问题 RISCV ISA todo list Markdown 使用手册 晶振,PLL,VCO初识 计算机大小端详解 进程通信，消息队列","link":"/top-index.html"},{"title":"","text":"","link":"/about/index.html"},{"title":"","text":"RISCV SCALA Chisel EDA","link":"/topic/index.html"},{"title":"","text":"Scala 笔记 2019-03-08: SCALA 程序初探.一(main函数) 2019-03-08: SCALA 程序初探.二(package组织方式) 2019-03-08: SCALA 程序初探.三(sbt组织scala代码1) 2019-03-08: SCALA 程序初探.四(sbt组织scala代码2) RISCV 开发调试 2018-11-28: IDEA scala chisel环境配置 2018-11-28: Makefile使用笔记 2018-11-27: RISC-V 编译链接脚本 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-25: RISC-V GDB 调试 2018-11-20: RISC-V C代码编译调试笔记 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-15: RISCV-Vector介绍 Chisel 笔记 2018-12-05: Chisel 示例问题汇总 2019-03-21: chisel 组合逻辑，时序逻辑写法 2019-04-01: chisel Keep变量名 2019-04-11: chisel 版本问题 2019-03-20: Chisel-Verilog 查找表优先级问题讨论 EDA工具 如何从shell中传递变量给verilog文件 EDA仿真环境Makefile配置(vcs,verdi) 时序分析回顾 Moudle名冲突解决办法 仿真不打拍 收藏 Python lambda Y组合子(Y算子)实现 通信 AGC调整 其他 Terminal Shell 常见配置问题 晶振,PLL,VCO初识 计算机大小端详解 进程通信，消息队列","link":"/main/index.html"}],"posts":[{"title":"索引置顶","text":"Scala 笔记 2019-03-08: SCALA 程序初探.一(main函数) 2019-03-08: SCALA 程序初探.二(package组织方式) 2019-03-08: SCALA 程序初探.三(sbt组织scala代码1) 2019-03-08: SCALA 程序初探.四(sbt组织scala代码2) RISCV 开发调试 2018-11-28: IDEA scala chisel环境配置 2018-11-28: Makefile使用笔记 2018-11-27: RISC-V 编译链接脚本 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-25: RISC-V GDB 调试 2018-11-20: RISC-V C代码编译调试笔记 2018-11-16: RISC-V 汇编指令调试、立即数浅尝 2018-11-15: RISCV-Vector介绍 Chisel 笔记 2018-12-05: Chisel 示例问题汇总 2019-03-21: chisel 组合逻辑，时序逻辑写法 2019-04-01: chisel Keep变量名 2019-04-11: chisel 版本问题 2019-03-20: Chisel-Verilog 查找表优先级问题讨论 EDA工具 如何从shell中传递变量给verilog文件 EDA仿真环境Makefile配置(vcs,verdi) 时序分析回顾 Moudle名冲突解决办法 仿真不打拍 收藏 Python lambda Y组合子(Y算子)实现 通信 AGC调整 其他 Terminal Shell 常见配置问题 晶振,PLL,VCO初识 计算机大小端详解 进程通信，消息队列","link":"/top-index.html"},{"title":"Hexo 技巧收录","text":"草稿功能草稿相当于很多博客都有的“私密文章”功能。1$ hexo new draft \"new draft\" 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。如果你希望强行预览草稿，更改配置文件： 1render_drafts: true 或者，如下方式启动server：1$ hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面：1$ hexo publish [layout] &lt;filename&gt;","link":"/others/hexo_utlis.html"},{"title":"Python lambda实现Y组合子","text":"也许你我都难以理解，为什么有人对她痴迷疯狂，铭记在心中不说，还要刻在身上： 她让人绞尽脑汁，也琢磨不定！她让人心力憔悴，又百般回味！ 她，看似平淡，却深藏玄机！她，貌不惊人，却天下无敌！ 她是谁？ 她就是 Y 组合子：Y = λf.(λx.f (x x)) (λx.f (x x)) ，不动点组合子中最著名的一个。 原文出处 python 利用Y算子实现递归阶乘函数 1((lambda S : (lambda x: (S(lambda y: x(x)(y))))(lambda x: (S(lambda y: x(x)(y)))))(lambda f:lambda n: 1 if(n==0) else (n*f(n-1))))(10) 复制此段代码到python shell可以看到阶乘10的正确结果","link":"/sicp/python-fp.html"},{"title":"Chisel版本","text":"如何查看当前使用的chisel版本一般情况下chisel的版本会在build.sbt里显式定义，但有时候像jupter-notebook里并不能看到版本号这种情况下有一个方法可以得到版本号即生成的firrtl文件头会打印版本信息 12;buildInfoPackage: chisel3, version: 3.1.2, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2018-07-25 16:52:17.431, builtAtMillis: 1532537537431circuit T1 : 修改chisel 版本 12libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.1.2\"libraryDependencies += \"edu.berkeley.cs\" %% \"chisel-iotesters\" % \"1.2.2\" 如何知道最新release的chisel 版本号 ，可以访问 https://index.scala-lang.org/ 搜索chisel3 查看当前release版本比如当前最新版本为3.1.7 , 修改build.sbt 重新sbt run时会自动下载最新版本库到~/.ivy2 libraryDependencies += \"edu.berkeley.cs\" %% \"chisel3\" % \"3.1.7\" chisel Scala 版本对应关系 scala sbt chisel firrtl 状态 2.11.x x.x.x 3.1.x x.x.x 正常 2.12.x x.x.x 3.1.x x.x.x Fail, IO Bundle Error chisel 3.1.x firrtl版本策略","link":"/chisel/20190411_chisel_version.html"},{"title":"Chiel Keep变量名","text":"how to keep chisel variable name when generate verilogThere are several reasons why a name may be disappearing. Constant PropagationFor many reasons, including interoperability with existing CAD tools, performance, and Verilog debug-ability, Chisel (actually the FIRRTL compiler underneath Chisel) will propagate constants and direct wire connections. For example: 123456789class MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val wire = Wire(UInt(8.W)) wire := io.in io.out := wire} In the above code, wire will be removed because it is simply connected to io.in, the Verilog will just show: assign io_out = io_in;Inability to nameChisel Modules are implemented as Scala Classes. Due to implementation reasons, by default Chisel can only name “top-level” vals in the body of the Module, for example: 12345678910111213141516class MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val in2 = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val sum = io.in + io.in2 // this is a top-level val, will be named // A method, we can call to help generate code: def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented } io.out := inc(sum)} suggestNameYou can manually name any signal by calling .suggestName(“name”) on it, eg. 1234def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented.suggestName(&quot;incremented&quot;) // Now it is named!} Enter @chiselNameWe can fix the above issue with an experimental feature called @chiselName like so: 12345678910111213141516171819import chisel3.experimental.chiselName@chiselNameclass MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val in2 = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val sum = io.in + io.in2 // this is a top-level val, will be named // A method, we can call to help generate code: def inc(x: UInt): UInt = { val incremented = x + 1.U // We cannot name this, it&apos;s inside a method incremented } io.out := inc(sum)} @chiselName is an annotation that can be used on any class or object definition and will ensure vals like incremented can get named. @chiselName effectively rewrites your code to put .suggestName all over the place. I hope this helps! EDIT more info:Disabling OptimizationsI don’t think it’s in a release yet (most recent being 3.1.7, this will be in 3.2.0), but we do have an option to disable all optimizations. You can change the “compiler” used from verilog to mverilog (for “minimum” Verilog, ie. no optimizations). This can be done with the command-line argument -X mverilog either in Chisel or FIRRTL. Don’t TouchYou can also use chisel3.experimental.dontTouch to mark a signal as something that shouldn’t be deleted. This will prevent optimizations from removing the signal. For example: 123456789import chisel3.experimental.dontTouchclass MyModule extends Module { val io = IO(new Bundle { val in = Input(UInt(8.W)) val out = Output(UInt(8.W)) }) val wire = dontTouch(Wire(UInt(8.W))) wire := io.in io.out := wire I’ve edited my response to talk about how to disable optimizations (not in the current release, you can wait for 3.2 which should be out in a couple of weeks or build Chisel manually from master and use that). I should caution that running formal equivalence tools tend to struggle comparing large designs with and without optimizations, but you can try it. For specific signals, dontTouch can help with what you want. o 原文链接","link":"/chisel/20190401_chisel_keep_name.html"},{"title":"Verilog 模块重名问题","text":"Chisel 不同开发生产的Verilog 模块名冲突同学A 负责开发AP同学B 负责开发CP其中都会用到Queue，生产的AP_system_top.v CP_system_top.v中可能都会包含一个module Queue (集成到SOC_top.v时会面临模块名冲突的问题，目前Chisel 本身没有提供解决该问题的方法。只能依赖于原始verilog 的解决方法 Verilog 模块名冲突解决方法仿真命令如下 1vcs -top $top_cfg_name_in_libmap -libmap $libmap_file 1234567891011121314library default_lib $project;library cp_rocket_lib $project/cp/rocket_chip/*.v;library top_rocket_lib $project/top/rocket_chip/*.v;library i2c_ahb_lib $project/top_peri/i2c_ahb/*.v;config chip_cfg; design tb_top ; default liblist default_lib; instance tb_top.U_chip.U_system_top.U_cp_top.U_cp_rocket liblist cp_rocket_lib ; instance tb_top.U_chip.U_system_top.U_top_rocket liblist top_rocket_lib; instance tb_top.U_chip.U_system_top.U_top_peri_sys.U_i2c_ahb liblist i2c_ahb_lib ;endconfig 综合应该也差不多","link":"/chisel/20190322_chisel_module_confilict.html"},{"title":"Chisel组合逻辑时序逻辑","text":"时序逻辑的声明和写法123456789101112131415161718192021实例1 val tiRomStartAddr = RegInit(0.U(6.W)) //显示的声明Reg when (io.swif.K&lt;40.U ){tiRomStartAddr := 25.U } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := 21.U } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := 35.U } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := 15.U } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := 10.U } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := 5.U } .otherwise {tiRomStartAddr := 25.U }实例2 val RRomRdata = RegInit(0.U(log2Up(pm.MaxR).W)) //显示的声明Reg并初始化（switch语句不带default) switch (io.RRomAddr) { is (0.U) {RRomRdata := intraRowTi.RRomVal(0).U} is (1.U) {RRomRdata := intraRowTi.RRomVal(1).U} is (2.U) {RRomRdata := intraRowTi.RRomVal(2).U} is (3.U) {RRomRdata := intraRowTi.RRomVal(3).U} is (4.U) {RRomRdata := intraRowTi.RRomVal(4).U} is (5.U) {RRomRdata := intraRowTi.RRomVal(5).U} is (6.U) {RRomRdata := intraRowTi.RRomVal(6).U} is (7.U) {RRomRdata := intraRowTi.RRomVal(7).U} } 组合逻辑的声明与写法123456789101112131415161718192021222324252627实例1 val tiRomStartAddr = Wire(UInt()) //显示的声明Wire when (io.swif.K&lt;40.U ){tiRomStartAddr := 25.U } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := 21.U } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := 35.U } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := 15.U } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := 10.U } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := 5.U } .otherwise {tiRomStartAddr := 25.U }实例2 val RRomRdata = Wire(UInt()) //显示的声明Wire RRomRdata := 0.U //一定要设默认值，否则组合逻辑条件不全chisel编译不过（verilog组合逻辑条件不全会产生锁存器） switch (io.RRomAddr) { is (0.U) {RRomRdata := intraRowTi.RRomVal(0).U} is (1.U) {RRomRdata := intraRowTi.RRomVal(1).U} is (2.U) {RRomRdata := intraRowTi.RRomVal(2).U} is (3.U) {RRomRdata := intraRowTi.RRomVal(3).U} is (4.U) {RRomRdata := intraRowTi.RRomVal(4).U} is (5.U) {RRomRdata := intraRowTi.RRomVal(5).U} is (6.U) {RRomRdata := intraRowTi.RRomVal(6).U} is (7.U) {RRomRdata := intraRowTi.RRomVal(7).U} } 实例3 val PrimeRom = Vec(PrimeAndRoot.map(_.U)) //ROM默认生成的是组合逻辑，寄存器输出自己加一级 io.out3 := PrimeRom(io.i)","link":"/chisel/20190321_chisel_comb_reg.html"},{"title":"Scala 初探.四(sbt组织scala代码2)","text":"package and import1234567├── build.sbt└── src └── main └── scala ├── Interleave.scala ├── utils.scala └── config.scala 对于同一目录下的两个文件，可以不用import，默认在一个package内 12345//Interleave.scalaclass A { val a = new ClassInUtils} 12345//utils.scala class ClassInUtils{ } Interleave.scala 不需要import ClassInUtils ,直接使用就可以，sbt 会帮你搞定编译","link":"/scala/20190308_scala_sbt2.html"},{"title":"Scala 初探.一(main函数)","text":"SCALA 程序的几种运行方式方法1脚本式的使用，scala a.scala 可正常打印1234def main() = { println(\"Hello, Scala way1\")}main() 但这种写法不能被 scalac a.scala正确编译，可能JVM对象必须要有个main入口函数 方法2 object mainJava中一个类要独立运行，必须具有静态的main方法，如下123public static void main(String[] args) { ... } scala 种借鉴了这种方法，为了独立运行一个SCALA程序，必须定义一个scala object并且为其定义main方法命令行scala a.scala会直接运行main函数，其中args为命令行参数 123456object RunAppDemo { def main(args:Array[String]) { println(\"Hello, Scala within object main\") args.map(println) } } Scala中的Object相当于java中的静态类，在其上可以定义静态的方法。Scala允许一个类定义自己的“伴生对象”(Companion Object)，它们具有相同的名字，必须位于同一个文件中，并且可以互相引用各自的私有成员。Scala的Object也可以独立存在。如果一个Scala Object没有伴生对象，我们称之为“独立对象”（Standardalone Object），反之，对象和类互为友元。上述代码main方法中的参数args是从命令行中传入的参数列表，具体用法和java类似。 如果a.scala 定义两个main函数，会默认执行第一个出现的main函数123456789101112object RunAppDemo { def main(args:Array[String]) { println(\"Hello, Scala within object main\") args.map(println) } } object RunAppDemo2 { def main(args:Array[String]) { println(\"Hello, Scala within object main2\") } } 方法3 extends App为了使代码更简洁，Scala还提供了另外一种运行Scala程序的方式，那就是直接继承scala.App接口（Trait）。 123object RunAppWithoutMain extends App { println(\"runing scala app without main\") } 之所以这里无须定义main方法，那是因为在App这个接口中定义了一个main方法，main方法在执行时会初始化RunAppWithoutMain这个对象，并执行它的主构造方法，而所有直接写在对象中的代码都会被scala编译器收集到主构造方法中，于是就被运行了。 这种方法虽然省略了一些代码，但是也有一些副作用。 直接继承自Application导致的副作用: 无法接受命令行参数。因为args参数不会被传入 在Scala中，如果一个程序是多线程的，那么这个程序必须具有一个main方法。所以这种写法只能适用于单线程的程序 App这个接口在执行一个程序的代码之前，需要进行一些初始化。而某些JVM不会对这些初始化代码进行优化。 所以第二种方法只适用于一些非常简单的场合，大部分情况不推荐使用。","link":"/scala/20190308_scala_main.html"},{"title":"Scala 初探.三(sbt组织scala代码1)","text":"上一节我们用Makefile来组织scala代码，这里有更好的选择sbt来管理项目sbt推荐将scala代码放在src路径，如下为标准的组织方式(代码还是原封使用第二节的样例代码)总共3个文件 1234567├── build.sbt└── src └── main └── scala ├── a.scala ├── b.scala └── c.scala 输入命令 sbt test 编译没报错输入命令 sbt run 提示找到了2个入口函数12345678Multiple main classes detected, select one to run: [1] com.east.objectMain [2] com.north.NorthWolf[info] Packaging E:\\nutstore\\2017pc\\lab\\scala\\sbtProj\\target\\scala-2.11\\sbtproj_2.11-0.1.0-SNAPSHOT.jar ...[info] Done packaging.Enter number: 跟我们的预期一致，确实a.scala中 和c.scala分别存在两个main入口 ,用不同的方式实现 12345678910111213141516//a.scalapackage com.east import com.west._object objectMain extends App{ println(\"add Function from west used in east, 1+2=%d\".format(Add.add(1,2))) } //c.scalapackage com.north import com.west._object NorthWolf { def main(args:Array[String]) { println(\"add Function from west used in north, 3+4=%d\".format(Add.add(3,4))) args.map(println) }} 也可以sbt &quot;runMain com.north.NorthWolf arg1 arg2&quot; 直接选定要执行的main入口 其他sbt 相关的命令可以自行在网上搜索 SBT打包jarsbt compile 后会在根目录下生成","link":"/scala/20190308_scala_sbt1.html"},{"title":"Scala 初探.二(package组织方式)","text":"多个文件的package组织方式123456//a.scala package com.east import com.west._object objectMain extends App{ println(\"add Function from west used in east, 1+2=%d\".format(Add.add(1,2)))} 12345//b.scala package com.west object Add { def add(a:Int, b:Int) = a + b} 多个文件的package组织方式编译 scalac a.scala b.scala 生成com文件夹（JVM 编译完的.class文件）运行 scala com.east.main 正确打印信息 object main 方式 1234567891011121314151617181920212223//c.scala package com.north object NorthWolf { def main(args:Array[String]){ println(\"add Function from west used in north, 3+4=%d\".format(Add.add(3,4))) }} ``` 编译 `scalac a.scala b.scala c.scala` 更新com文件夹 运行 `scala com.north.NorthWolf` 正确打印信息 Makefile 如下```Makefileobjects = comsource = a.scala b.scala c.scala.PHONY: runrun:com scala com.east.objectMain scala com.north.NorthWolf $(objects) : $(source) scalac $(source) SCALA编译生成的com为package目录, *.class 为class字节码，可以被JVM执行(所以SCALA编译玩的.scala可以在任何JVM上执行，也就说scala的程序也可以在Android上运行)比如com/east/main.class ,可以直接scala com.east.main来执行 123456789101112$:tree com com├── east│ ├── main$.class│ ├── main$delayedInit$body.class│ └── main.class├── north│ ├── NorthWolf$.class│ └── NorthWolf.class└── west ├── Add$.class └── Add.class 关于*.scala 和 *$.scala 的区别可以在网上自行搜索 原则上只要把com文件夹打包就可以发布为一个SCALA/JAVA程序 jar打包和运行如何讲程序打包成jar 命令行运行jar cvf com.jar com 得到com.jar在任意地方 scala -classpath com.jar com.north.NorthWolf 可直接运行函数 实例参见目录/nutstore/2017pc/lab/scala/packageTest","link":"/scala/20190308_scala_package.html"},{"title":"RISCV 矢量处理器","text":"RISC-V向量的工作过程 setp1 : 首先要确定向量的类型 比如你要做一个向量运算 Y = a*X + Y ,如果X, Y 都是双精度的浮点的向量，那么就需要申请两个F64类型的向量v0和v1, 如果是 Z = a*X + Y ,同样X,Y是双精度的浮点的向量，那么就需要至少申请3个F64类型的向量v0和v1,v2分别给X,Y,Z使用 RV32V 向量寄存器类型的编码如下 Type Floating Poing Signed Interger Unsigned Interger Width Name vetype Name vetype Name vetype 8bit — — X8 10100 X8U 11100 16bit F16 01101 X16 10101 X16U 11101 32bits F32 01110 X32 10110 X32U 11110 64bits F64 01111 X64 10111 X64U 11111 setp2 : 然后申请向量的个数 假如向量寄存器总共有1024Byte ，如果只给2个向量使用,那么对半分，每个向量可以分得512Byte的空间，F64=8Byte，所以 每个向量可以有512/8=64个F64类型的元素，也就是mvl(max_vecotr_length)=64， 一次可以计算的个数是64个元素。 如果我们的X,Y的长度假设是100，那么完成 Y = a*X + Y 需要2次向量操作， 第一次vl选64， 计算64个F64向量的运算 第二次vl选100-64= 36, 计算剩余的36个F64向量的运算 FAQ 何为mvl max_vector_ 何为ml","link":"/riscv/20181221_riscv_verctor.html"},{"title":"从Shell传递变量给verilog的两种方法","text":"通过define宏传递 首先在命令行中定义define 1234567vcs -sverilog -debug_all +define%s+CASENAME=\\\"%s\\\" -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log -f top.f 尤其要注意CASENAME=\\&quot;%s\\&quot;的转义“\\”的应用，比如命令行被包含在python脚本内部，需要两次转义, 而shell可能只要一次 123def run(case,defines=\"\"): os.system('vcs -sverilog -debug_all +define%s+CASENAME=\\\\\"%s\\\\\" -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log -f top.f'%(defines,case)) os.system('./simv -l sim.log +notimingcheck +nospecify +loopreport +memcbk +novopt') 否则verilog文件是无法获取CASENAM的意思 然后在verilog中通过宏取出 1fp_reg = $fopen({\"./case/\",`CASENAME,\"/source_dpp.txt\"},\"r\"); 这种方式比较繁琐，而且转义嵌套难以理解，另外一种方便的方法如下 通过option arg传递 首先在命令行的option里定义两个puls类型的args, +DUMPWAVE和TESTCASE 1234run: compile rm -rf ${TEST_RUNDIR} mkdir ${TEST_RUNDIR} cd ${TEST_RUNDIR}; ${SIM_EXEC} +DUMPWAVE=${DUMPWAVE} +TESTCASE=${TESTCASE} |&amp; tee ${TESTNAME}.log; cd ${RUN_DIR}; 然后在verilog文件中通过$val$plusargs()获取val 123456789101112131415reg [8*300:1] testcase;integer dumpwave;initial begin if($value$plusargs(\"TESTCASE=%s\",testcase))begin $display(\"TESTCASE=%s\",testcase);endinitial begin $value$plusargs(\"DUMPWAVE=%d\",dumpwave); if(dumpwave != 0)begin // To add your waveform generation function $fsdbDumpfile(\"./e203.fsdb\") ; $fsdbDumpvars(0,tb_top); $fsdbDumpflush; endend","link":"/eda/how_to_send_param2tb.html"},{"title":"Chisel-Verilog查找表优先级问题讨论","text":"Chisel 查找表电路优先级问题verilog ROM的两种写法及区别1234567891011121314151617181920212223方法1always @(posedge clk )begin case(addr0) 6'd0 : data0 &lt;= 8'd214; 6'd1 : data0 &lt;= 8'd213; 6'd2 : data0 &lt;= 8'd212; 6'd3 : data0 &lt;= 8'd211; 6'd4 : data0 &lt;= 8'd210; 6'd5 : data0 &lt;= 8'd209; 6'd6 : data0 &lt;= 8'd208; 6'd7 : data0 &lt;= 8'd207; 方法2always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; 方法2是不是带优先级？ 实际上是不带优先级逻辑上if取的条件都是addr1的值，一定是互斥的，综合工具也能自动识别出这种if else它有别于以下这种情况，这种情况下是真实带有优先级的电路，其中another_cond_A,another_cond_B是独立的两个输入条件，和addr1的取值可能同时发生，所以不能被综合器当做查找表来对待。 12345678910always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(another_cond_A ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(another_cond_B ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; chisel中查找表的写法以及对应电路1234567891011121314方法一switch (addr) { is( 0.U ) { rdata:= 8'd150 } is( 1.U ) { rdata:= 8'd149 } is( 2.U ) { rdata:= 8'd148 } is( 3.U ) { rdata:= 8'd147 } is( 4.U ) { rdata:= 8'd146 } is( 5.U ) { rdata:= 8'd145 } is( 6.U ) { rdata:= 8'd144 } is( 7.U ) { rdata:= 8'd143 }}方法二val ROM = Vec(Array(150.U,149.U,148.U, 143.U))val rdata = ROM(addr) 两种方法都会生成以下类似电路，等效CASE语句写法。所以不用担心优先级的问题。 12345678910always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143; 综合工具对上面电路的处理也是没有优先级的。 综合对比Verilog DEMO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104module caseifelse_top ( clk,in_en0,in_addr0,out_data0,in_en1,in_addr1,out_data1);input clk ;input in_en0 ;input in_en1 ;input [5:0] in_addr0 ;input [5:0] in_addr1 ;output [7:0] out_data0 ;output [7:0] out_data1 ;reg [7:0] out_data0 ;reg [7:0] out_data1 ;reg [5:0] addr0 ;reg [5:0] addr1 ;reg en0 ;reg en1 ;wire [7:0] data0 ;wire [7:0] data1 ;always @(posedge clk )begin en0 &lt;= in_en0 ; en1 &lt;= in_en1 ; addr0 &lt;= in_addr0 ; addr1 &lt;= in_addr1 ; out_data0 &lt;= data0 ; out_data1 &lt;= data1 ;end rom u_rom_table(.clk (clk ),.en0 (en0 ),.addr0 (addr0 ),.data0 (data0 ) );ifelse u_ifelse_table(.clk (clk ),.en1 (en1 ),.addr1 (addr1 ),.data1 (data1 ) );endmodule module rom(clk,rstn,en0,addr0,data0);input clk ;input rstn ;input en0 ;input [5:0] addr0 ;output [7:0] data0 ;reg [7:0] data0 ;always @(posedge clk )begin case(addr0) 6'd0 : data0 &lt;= 8'd214; 6'd1 : data0 &lt;= 8'd213; 6'd2 : data0 &lt;= 8'd212; 6'd3 : data0 &lt;= 8'd211; 6'd4 : data0 &lt;= 8'd210; 6'd5 : data0 &lt;= 8'd209; 6'd6 : data0 &lt;= 8'd208; 6'd7 : data0 &lt;= 8'd207;。。。 6'd63: data0 &lt;= 8'd151; default : data0 &lt;= 8'd0; endcase end endmodule module ifelse(clk,en1,addr1,data1);input clk ;input en1 ;input [5:0] addr1 ;output [7:0] data1 ;reg [7:0] data1 ;always @(posedge clk )begin if(addr1 == 6'd0 ) data1 &lt;= 8'd150; else if(addr1 == 6'd1 ) data1 &lt;= 8'd149; else if(addr1 == 6'd2 ) data1 &lt;= 8'd148; else if(addr1 == 6'd3 ) data1 &lt;= 8'd147; else if(addr1 == 6'd4 ) data1 &lt;= 8'd146; else if(addr1 == 6'd5 ) data1 &lt;= 8'd145; else if(addr1 == 6'd6 ) data1 &lt;= 8'd144; else if(addr1 == 6'd7 ) data1 &lt;= 8'd143;。。。 else if(addr1 == 6'd63) data1 &lt;= 8'd87; else data1 &lt;= 8'd1 ;end endmodule 综合后的网表 看到两种方法都是基本相同，没有优先级区别 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465module caseifelse_top_ifelse_1 ( clk, en1, addr1, data1 ); input [5:0] addr1; output [7:0] data1; input clk, en1; wire N67, N69, n8, n9, n10, n17, n18, n19, n1, n2, n3, n4, n5; SDFKCNQD1BWP7T40P140UHVT data1_reg_7_ ( .D(n8), .CN(n10), .SI(n9), .SE(n9), .CP(clk), .Q(data1[7]) ); SDFKSNQD1BWP7T40P140UHVT data1_reg_6_ ( .SN(n10), .D(addr1[5]), .SI(n9), .SE(n9), .CP(clk), .Q(data1[6]) ); MB2SRLSDFQD1BWP7T40P140LVT data1_reg_1_0_ ( .D1(n19), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[1]), .D2(addr1[0]), .Q2(data1[0]) ); MB2SRLSDFQD1BWP7T40P140UHVT data1_reg_5_4_ ( .D1(N69), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[5]), .D2(n17), .Q2(data1[4]) ); OA21D1BWP7T35P140UHVT U3 ( .A1(n4), .A2(n2), .B(n1), .Z(N67) ); ND2D1BWP7T30P140UHVT U4 ( .A1(addr1[4]), .A2(n1), .ZN(n10) ); ND2D1BWP7T30P140UHVT U5 ( .A1(n2), .A2(n4), .ZN(n1) ); ND3D1BWP7T30P140UHVT U6 ( .A1(addr1[0]), .A2(addr1[1]), .A3(addr1[2]), .ZN( n4) ); ND2D1BWP7T35P140UHVT U7 ( .A1(addr1[0]), .A2(addr1[1]), .ZN(n3) ); INVD1BWP7T35P140UHVT U8 ( .I(addr1[3]), .ZN(n2) ); INVD1BWP7T35P140UHVT U9 ( .I(addr1[5]), .ZN(n8) ); OAI21D1BWP7T35P140UHVT U10 ( .A1(addr1[0]), .A2(addr1[1]), .B(n3), .ZN(n19) ); OAI21D1BWP7T35P140UHVT U11 ( .A1(n5), .A2(addr1[2]), .B(n4), .ZN(n18) ); MAOI22D1BWP7T40P140UHVT U14 ( .A1(n10), .A2(n8), .B1(n8), .B2(n10), .ZN(N69) ); MB2SRLSDFQD1BWP7T40P140UHVT data1_reg_3_2_ ( .D1(N67), .CP(clk), .SE(n9), .SI(n9), .Q1(data1[3]), .D2(n18), .Q2(data1[2]) ); TIELBWP7T40P140LVT U12 ( .ZN(n9) ); INVD1BWP7T40P140UHVT U13 ( .I(n3), .ZN(n5) ); OAI21D1BWP7T40P140UHVT U15 ( .A1(addr1[4]), .A2(n1), .B(n10), .ZN(n17) );endmodulemodule caseifelse_top_rom_1 ( clk, rstn, en0, addr0, data0 ); input [5:0] addr0; output [7:0] data0; input clk, rstn, en0; wire N235, N237, N238, n7, n14, n15, n16, n1, n2, n3, n4, n5, n6; SDFQOPPSAD1BWP7T40P140UHVT data0_reg_0_ ( .D(addr0[0]), .SI(n7), .SE(n7), .CP(clk), .Q(data0[0]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_2_1_ ( .D1(n15), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[2]), .D2(n16), .Q2(data0[1]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_4_3_ ( .D1(n14), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[4]), .D2(N235), .Q2(data0[3]) ); MB2SRLSDFQD1BWP7T40P140LVT data0_reg_6_5_ ( .D1(N238), .CP(clk), .SE(n7), .SI(n7), .Q1(data0[6]), .D2(N237), .Q2(data0[5]) ); AO21D1BWP7T35P140UHVT U3 ( .A1(n6), .A2(n5), .B(n4), .Z(n14) ); AO21D1BWP7T35P140UHVT U4 ( .A1(n3), .A2(n2), .B(n1), .Z(n15) ); INVD1BWP7T35P140UHVT U5 ( .I(addr0[2]), .ZN(n2) ); ND2D1BWP7T35P140UHVT U6 ( .A1(addr0[0]), .A2(addr0[1]), .ZN(n3) ); NR2D1BWP7T35P140UHVT U7 ( .A1(n2), .A2(n3), .ZN(n1) ); INVD1BWP7T35P140UHVT U8 ( .I(addr0[4]), .ZN(n5) ); NR2D1BWP7T35P140UHVT U9 ( .A1(addr0[3]), .A2(n1), .ZN(n6) ); NR2D1BWP7T35P140UHVT U10 ( .A1(n5), .A2(n6), .ZN(n4) ); OAI21D1BWP7T35P140UHVT U11 ( .A1(addr0[0]), .A2(addr0[1]), .B(n3), .ZN(n16) ); AOI21D1BWP7T35P140UHVT U12 ( .A1(n1), .A2(addr0[3]), .B(n6), .ZN(N235) ); AOI21D1BWP7T35P140UHVT U13 ( .A1(addr0[5]), .A2(n4), .B(N238), .ZN(N237) ); NR2D1BWP7T35P140UHVT U14 ( .A1(n4), .A2(addr0[5]), .ZN(N238) ); TIELBWP7T40P140LVT U15 ( .ZN(n7) );endmodule 代码目录：/nutstore/2017pc/lab/turbo/scala/work 结论chisel 虽然生成的电路没有CASE语句，也完全没有问题，if else的写法也能满足查找表的实现，并不会有优先级的问题 扩展同样一下两种chisel和verilog的写法对于综合器来说其实都是没有优先级的，综合器可以根据时序情况将其打平，并不影响电路的功能（本质上每个条件都不重叠，所以没有真实的优先级物理意义）因此可以大胆的采用这种写法而不用考虑优先级进位链太长而产生的时序问题。 1234567891011121314151617181920212223 when (io.swif.K&lt;40.U ){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;159.U ){tiRomStartAddr := baseR5 } .elsewhen (io.swif.K&lt;200.U ){tiRomStartAddr := baseR10 } .elsewhen (io.swif.K&lt;481.U ){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;530.U ){tiRomStartAddr := baseR10 } .elsewhen (io.swif.K&lt;2881.U){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;2480.U){tiRomStartAddr := baseR20 } .elsewhen (io.swif.K&lt;3160.U){tiRomStartAddr := baseRAny } .elsewhen (io.swif.K&lt;3210.U){tiRomStartAddr := baseR20 } .otherwise {tiRomStartAddr := baseRAny } ``` ```verilog if (K&lt;40 ){addr := 5&apos;d0 } else if (K&lt;159 ){addr := 5&apos;d1 } else if (K&lt;200 ){addr := 5&apos;d2 } else if (K&lt;481 ){addr := 5&apos;d4 } else if (K&lt;530 ){addr := 5&apos;d6 } else if (K&lt;2881){addr := 5&apos;d0 } else if (K&lt;2480){addr := 5&apos;d9 } else if (K&lt;3160){addr := 5&apos;d0 } else if (K&lt;3210){addr := 5&apos;d8 } else {addr := 5&apos;d0 }","link":"/chisel/20190320_verilog_case_ifelse.html"},{"title":"Chisel 实例问题汇总","text":"chisel-example \\ chisel-tutorial 同样代码，生成器输出不一致问题同样的一份代码src/main/scala/GCD.scalasrc/test/scala/GCDTester.scala 其中生成vcd波形的代码12345object GCDTester extends App { iotesters.Driver.execute(Array(\"--target-dir\", \"generated\", \"--fint-write-vcd\"), () =&gt; new GCD){ c =&gt; new GCDTests(c) }} 在chisel-example 目录下 sbt &quot;test:runMain simple.GCDTester&quot; 可以生成GCD波形1234&gt;&gt; l generated/examples.GCDTester1802184992-rwxr-xr-x+ 1 Administrator None 6 Dec 5 14:53 GCD.anno.json-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.fir-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.lo.fir 在chisel-tutorial 目录下 sbt &quot;test:runMain simple.GCDTester&quot; 不能生成GCD波形 1234&gt;&gt; l generated/examples.GCDTester1802184992-rwxr-xr-x+ 1 Administrator None 6 Dec 5 14:53 GCD.anno.json-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.fir-rwxr-xr-x+ 1 Administrator None 1.5K Dec 5 14:53 GCD.lo.fir 导致的原因是，build.sbt 不一样 , 可能是引入的库的版本不一致导致，123456789//chisel-tutorial/build.sbtval defaultVersions = Map( // \"chisel3\" -&gt; \"3.1.+\", // \"chisel-iotesters\" -&gt; \"1.2.+\" //将上面两行注释掉，改为3.1.2， 1.2.2 //否则可能会默认使用.ivy2/cache/edu.berkeley.cs/chisel3_2.11/jars/chisel3_2.11-3.1.3.jar \"chisel3\" -&gt; \"3.1.2\", \"chisel-iotesters\" -&gt; \"1.2.2\" ) iotesters.Driver.execute(Array(&quot;--target-dir&quot;, &quot;generated&quot;, &quot;--fint-write-vcd&quot;), () =&gt; new GCD){ chisel-example下的build.sbt chisel-tutorial下的build.sbt 结论：保险起见，使用一下两个版本号：12libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chisel3&quot; % &quot;3.1.2&quot;libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chisel-iotesters&quot; % &quot;1.2.2&quot;","link":"/chisel/20181205_chisel_learning.html"},{"title":"IDEA Scala开发环境配置","text":"IDEA 下载社区版本是免费的，scala开发够用，专业版面向web部分是收费的 启动idea ，import project 按钮倒入 .sbt 文件 setting java JDK, File&gt;&gt;Project Structure&gt;&gt;Project&gt;&gt;Project SDK, 按new ,选择JAVA jdk. 默认会自动识别，否则手动下载指定xxx/1.8.0-openjdk-amd64)(一般要求1.8版本) ![01](http://ppw74l91w.bkt.clouddn.com/IDEA/01.png) setting scala JDK, 下载scala 太慢，可以直接brows选择 你的ivy2目录，如果是mac隐藏目录，可以按shift + command + .切换是否显示隐藏目录 如果你的ivy2目录下有不同版本的scala，默认会全部倒入，只选择你要安装的版本号，其他版本list按delete删除。 restart IDEA build.sbt 设置正确的版本依赖 set root directory Rigth click on project root dir “rocket-chip” ,右键选择Mark Directory as &gt;&gt; Sources Root IDE主要用来写代码，但是不推荐在IDED 内部Build，在terminal 利用Makefile来维护和build 会更可靠。","link":"/riscv/20181130_idea_scala_config.html"},{"title":"Makefile 笔记","text":"规则伪目标变量变量定义的3种方式 1 foo = bar (递归展开式变量) 会在引用$(foo)地方原地替换，直到不能再替换，这种方式称之为递归展开式变量 1234foo = $(bar)bar = $(ugh)ugh = Huh?all @echo $(foo) 以上例子会在@echo $(foo) 地方递归展开 缺点一 ： 是当嵌套定义 foo = $(foo) bar 时讲进入死循环，导致Make失败 其他例子 x = $(y) y = $(x) $(z) 同样会陷入死循环，所以这种定义方法只推荐在不引用变量的时候应用 缺点二 这种定义中如果使用函数，只会在变量被引用时展开，而不是在定义时展开 会使得Make的效率降低，另外有可能会在变量函数的引用会出现非预期结果，特别当变量 定义引用到shell wildcard 函数的情况下，出现不可控的结果 123456x = fooy = $(x) bar //$(x) 不会被立即替换，只有在$(y)被用到的地方才用x的值替换x = later //将会覆盖 原来的 x , 等价于y = later barx = later 2 foo := bar (直接展开式变量) 123456x := fooy := $(x) bar ; 会立即替换成 foo barx := later 等价于y := foo barx := later bar 在复杂的Makefile中，推荐使用立即展开式变量，变量的定义会比较明确 ，也和大多数变成语言中的变量定义使用方法一致。 尽量避免和减少使用第一种递归式变量的使用 定义空格 dir := /foo/bar # directory to put the frobs in 变量“dir”的值是“/foo/bar ”（后面有 4 个空格），这可能并不是想要实现的。如果一个文件以它作为路径来表示“$(dir)/file”，那么大错特错了。 在书写 Makefile 时。推荐将注释书写在独立的行或者多行，防止出现上边例子中 的意外情况，而且将注释书写在独立的行也使得 Makefile 清晰，便于阅读。对于特殊 的定义，比如定义包含一个或者多个空格空格的变量时进行详细地说明和注释。 如果定义个空格变量 12nullstring :=space := $(nullstring) # end of the line 3 foo ?= bar 条件赋值操作符 只有变量之前没有赋值的情况下才会对这个变量赋值，如果之前已经定义了，就不改变原来的值 12345FOO ?= bar其等价于：ifeq ($(origin FOO), undefined) FOO = barendif 4 foo += jar 追加变量值 123456objects = main.o foo.o bar.o utils.oobjects += another.o上边的两个操作之后变量“objects”的值就为：“main.o foo.o bar.o utils.o another.o”。使用“+=”操作符，相当于：objects = main.o foo.o bar.o utils.oobjects := $(objects) another.o 5 define 定义多行变量 1234define two-linesecho fooecho $(bar)endef 6 override 变量 123456override foo = bar override foo := bar override define two-linesfoo$(bar)endef override定义变量是，防止变量的值被命令行指定 变量的高级用法变量的替换引用格式为“$(VAR:A=B)”（或者“${VAR:A=B}”），意思是，替换变量“VAR”中所有“A”字符结尾的字为“B”结尾的字。“结尾”的含义是空格之前（变量值多个字之间使用空格分开）。而对于变量其它部分的“A”字符不进行替换。例如：12foo := a.o b.o c.obar := $(foo:.o=.c) 变量的替换引用其实是函数“patsubst”（参考 8.2 文本处理函数 一节）的一个简化实现所实现功能相同。例如：12foo := a.o b.o c.obar := $(foo:%.o=%.c) 这个例子同样使变量“bar”的值为“a.c b.c c.c”。这种格式的替换引用方式比第一种方式更通用 变量的嵌套引用1234x = $(y)y = zz = Helloa := $($(x)) a的值最后为Hello，嵌套引用往往最后一个变量定义要用立即展开变量定义,有点像C语言的指针 函数","link":"/riscv/20181128_makefile_acc.html"},{"title":"RISCV 编译 Link探究","text":"问题： 如何将代码编译到指定的mem地址？在用$RISCV/bin/riscv64-unknown-elf-gcc hello.c时生成的目标文件默认的都是从0x0000_1000地址开始，如何自定义指定到从0x8000_0000地址开始？那么就得熟悉连接器的原理 默认链接脚本gcc在编译和链接的时候，如果不指定链接脚本，会指向默认的链接脚本默认的链接脚本可以用 $RISCV/bin/riscv64-unknown-elf-ld -verbose 来查看 如何更改链接脚本12345678SECTIONS{ . = 0x8000000; .text : { *(.text) } . = 0x9000000; .data : { *(.data) } .bss : { *(.bss) }} 在编译时指定$RISCV/bin/riscv64-unknown-elf-gcc -T link.lds hello.c -o hello.out默认会报错，没有指定_start 就没有办法分配堆和栈空间12345xxxx/bin/../lib/gcc/riscv64-unknown-elf/8.1.0/../../../../riscv64-unknown-elf/lib/rv64imafdc/lp64d/crt0.o: In function `_start':(.text+0x0): undefined reference to `__global_pointer$'(.text+0x8): undefined reference to `_edata'(.text+0x10): undefined reference to `_end'collect2.exe: error: ld returned 1 exit status 简单起见添加option -nostartfiles 忽略指定_start$RISCV/bin/riscv64-unknown-elf-gcc -T link.lds hello.c -o hello.out -nostartfiles然后$RISCV/bin/riscv64-unknown-elf-objdump -d hello.out &gt; hello.dump可以看到.text 从0x8000000地址开始123456789hello.out: file format elf64-littleriscvDisassembly of section .text:0000000008000000 &lt;main&gt;: 8000000: 1101 addi sp,sp,-32 8000002: ec06 sd ra,24(sp) 8000004: e822 sd s0,16(sp) 8000006: 1000 addi s0,sp,32 完整的参考实例参见hbird-e-sdk是RISCV开源E200系列开发板的sdk https://github.com/SI-RISCV/hbird-e-sdk ./generate_test4sim.csh 生成指定地址的out以及.verilog 二进制可读文件 编译新的case只需make dasm PROGRAM=hellowrold BOARD=hbird-e200 CORE=e203 DOWNLOAD=itcm即可展看来看，实际上执行的是123456789101112make -C software/hello_world \\ SIZE=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-size \\ CC=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-gcc \\ RISCV_ARCH=rv32imac \\ REPLACE_PRINTF=0 \\ NANO_PFLOAT=1 \\ USE_NANO=1 \\ DOWNLOAD=itcm \\ RISCV_ABI=ilp32 \\ AR=$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-ar \\ BSP_BASE=/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp \\ BOARD=hbird-e200 \\ 具体执行的是hbird-e-sdk/Makefile下的makefile，具体过程如下：12345678910111213141516171819202122232425262728# cd /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/software/hello_world$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-gcc -O2 -g -march=rv32imac -mabi=ilp32 \\ -ffunction-sections -fdata-sections -fno-common \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/drivers \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env \\ -I/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/include \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/start.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/entry.o \\ hello_world.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/init.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/close.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/_exit.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/write_hex.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/fstat.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/isatty.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/lseek.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/read.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/sbrk.o \\ /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/stubs/write.o \\ -o hello_world \\ -T /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env/link_itcm.lds -nostartfiles \\ -Wl,--gc-sections -Wl,--check-sections --specs=nano.specs -u _printf_float \\ -L/lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/bsp/hbird-e200/env \\$(RISCV_GNU_TOOLCHAIN)/bin/riscv-none-embed-size hello_world# Leaving /lifespace/t1/jijing/lab/e200_opensource/hbird-e-sdk/software/hello_world 还可以在bsp/env/common.k 中添加一行查看C编译成的hello.s汇编程序文件 1234$(TARGET): $(LINK_OBJS) $(LINK_DEPS) $(CC) $(CFLAGS) $(INCLUDES) $@.c -S #添加该行，可以在对于目录下生成 .s汇编程序 $(CC) $(CFLAGS) $(INCLUDES) $(LINK_OBJS) -o $@ $(LDFLAGS) $(SIZE) $@ 具体link脚本先关细节可见：hbird-e-sdk/bsp/hbird-e200/env/common.mk 文件中 LDFLAGS +=的定义对应脚本 hbird-e-sdk/bsp/hbird-e200/env/link_itcm.lds 下载目标ITCM 链接细节的描述 hbird-e-sdk/bsp/hbird-e200/env/link_flash.lds 下载目标Flash 链接细节的描述 hbird-e-sdk/bsp/hbird-e200/env/link_flashxip.lds 编译好的二进制可读文件在e200的vsim目录下make run_test TESTCASE=$PWD/../riscv-tools/fpga_test4sim/hello4sim/hello_world 即可启动仿真环境 lds 链接脚本的原理介绍完整的文章 链接器把一个或多个输入文件合成一个输出文件.输入文件: 目标文件或链接脚本文件.输出文件: 目标文件或可执行文件. 目标文件(包括可执行文件)具有固定的格式, 在UNIX或GNU/Linux平台下, 一般为ELF格式有时把输入文件内的section称为输入section(input section), 把输出文件内的section称为输出section(output sectin).目标文件的每个section至少包含两个信息: 名字和大小. 大部分section还包含与它相关联的一块数据, 称为section contents(section内容). 一个section可被标记为“loadable(可加载的)”或“allocatable(可分配的)”.loadable section: 在输出文件运行时, 相应的section内容将被载入进程地址空间中.allocatable section: 内容为空的section可被标记为“可分配的”. 在输出文件运行时, 在进程地址空间中空出大小同section指定大小的部分. 某些情况下, 这块内存必须被置零.如果一个section不是“可加载的”或“可分配的”, 那么该section通常包含了调试信息. 可用objdump -h命令查看相关信息.每个“可加载的”或“可分配的”输出section通常包含两个地址: VMA(virtual memory address虚拟内存地址或程序地址空间地址) LMA(load memory address加载内存地址或进程地址空间地址). 通常VMA和LMA是相同的. 在目标文件中, loadable或allocatable的输出section有两种地址: VMA(virtual Memory Address)和LMA(Load Memory Address). VMA是执行输出文件时section所在的地址, 而LMA是加载输出文件时section所在的地址. 一般而言, 某section的VMA == LMA. 但在嵌入式系统中, 经常存在加载地址和执行地址不同的情况: 比如将输出文件加载到开发板的flash中(由LMA指定), 而在运行时将位于flash中的输出文件复制到SDRAM中(由VMA指定).可这样来理解VMA和LMA, 假设: (1) .data section对应的VMA地址是0×08050000, 该section内包含了3个32位全局变量, i、j和k, 分别为1,2,3. (2) .text section内包含由”printf( “j=%d “, j );”程序片段产生的代码. 连接时指定.data section的VMA为0×08050000, 产生的printf指令是将地址为0×08050004处的4字节内容作为一个整数打印出来。如果.data section的LMA为0×08050000，显然结果是j=2如果.data section的LMA为0×08050004，显然结果是j=1还可这样理解LMA:.text section内容的开始处包含如下两条指令(intel i386指令是10字节，每行对应5字节):jmp 0×08048285movl $0×1,%eax如果.text section的LMA为0×08048280, 那么在进程地址空间内0×08048280处为“jmp 0×08048285”指令, 0×08048285处为movl $0×1,%eax指令. 假设某指令跳转到地址0×08048280, 显然它的执行将导致%eax寄存器被赋值为1.如果.text section的LMA为0×08048285, 那么在进程地址空间内0×08048285处为“jmp 0×08048285”指令, 0×0804828a处为movl $0×1,%eax指令. 假设某指令跳转到地址0×08048285, 显然它的执行又跳转到进程地址空间内0×08048285处, 造成死循环.符号(symbol): 每个目标文件都有符号表(SYMBOL TABLE), 包含已定义的符号(对应全局变量和static变量和定义的函数的名字)和未定义符号(未定义的函数的名字和引用但没定义的符号)信息.符号值: 每个符号对应一个地址, 即符号值(这与c程序内变量的值不一样, 某种情况下可以把它看成变量的地址). 可用nm命令查看它们. (nm的使用方法可参考本blog的GNU binutils笔记) 脚本格式链接脚本由一系列命令组成, 每个命令由一个关键字(一般在其后紧跟相关参数)或一条对符号的赋值语句组成. 命令由分号‘;’分隔开.文件名或格式名内如果包含分号’;’或其他分隔符, 则要用引号‘”’将名字全称引用起来. 无法处理含引号的文件名./ /之间的是注释。","link":"/riscv/20181127_riscv_link.html"},{"title":"RISCV GDB debug调试","text":"RISCV-GDB启动步骤 hello.c12345678#include &lt;stdio.h&gt;int main(){ long a = 0x876543210 ; float pi = 3.1415926 ; printf(\"Hello %s!\\n\",\"World\"); a = a*pi; return a ;} 如何生成汇编代码riscv64-unknown-elf-gcc -S hello.c 只会生成汇编代码hello.s 不会生成.out文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC2: .string &quot;World&quot; .align 3.LC3: .string &quot;Hello %s!\\n&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd ra,24(sp) sd s0,16(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) sd a5,-24(s0) lui a5,%hi(.LC1) flw fa5,%lo(.LC1)(a5) fsw fa5,-28(s0) lui a5,%hi(.LC2) addi a1,a5,%lo(.LC2) lui a5,%hi(.LC3) addi a0,a5,%lo(.LC3) call printf ld a5,-24(s0) fcvt.s.l fa4,a5 flw fa5,-28(s0) fmul.s fa5,fa4,fa5 fcvt.l.s a5,fa5,rtz sd a5,-24(s0) ld a5,-24(s0) sext.w a5,a5 mv a0,a5 ld ra,24(sp) ld s0,16(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 .align 2.LC1: .word 1078530010 .ident &quot;GCC: (GNU) 8.1.0&quot; 如何反汇编.out文件首先生成.out文件riscv64-unknown-elf-gcc -o hello.out hello.c 然后反汇编 riscv64-unknown-elf-objdump -d hello.out &gt; hello_disassemble.s 即可查看反汇编代码,搜索main函数如下，当然也包括其他内置函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748hello.out: file format elf64-littleriscvDisassembly of section .text:00000000000100b0 &lt;_start&gt;: 100b0: 0000d197 auipc gp,0xd 100b4: fd818193 addi gp,gp,-40 # 1d088 &lt;__global_pointer$&gt; 100b8: 84818513 addi a0,gp,-1976 # 1c8d0 &lt;_edata&gt; 100bc: 8d818613 addi a2,gp,-1832 # 1c960 &lt;_end&gt; ..... ...000000000001038c &lt;printf&gt;: 1038c: 711d addi sp,sp,-96 1038e: f832 sd a2,48(sp) 10390: fc36 sd a3,56(sp) .... ..0000000000010198 &lt;main&gt;: 10198: 1101 addi sp,sp,-32 1019a: ec06 sd ra,24(sp) 1019c: e822 sd s0,16(sp) 1019e: 1000 addi s0,sp,32 101a0: 67e9 lui a5,0x1a 101a2: a687b783 ld a5,-1432(a5) # 19a68 &lt;__clzdi2+0x54&gt; 101a6: fef43423 sd a5,-24(s0) 101aa: 67e9 lui a5,0x1a 101ac: a707a787 flw fa5,-1424(a5) # 19a70 &lt;__clzdi2+0x5c&gt; 101b0: fef42227 fsw fa5,-28(s0) 101b4: 67e9 lui a5,0x1a 101b6: a5078593 addi a1,a5,-1456 # 19a50 &lt;__clzdi2+0x3c&gt; 101ba: 67e9 lui a5,0x1a 101bc: a5878513 addi a0,a5,-1448 # 19a58 &lt;__clzdi2+0x44&gt; 101c0: 1cc000ef jal ra,1038c &lt;printf&gt; 101c4: fe843783 ld a5,-24(s0) 101c8: d027f753 fcvt.s.l fa4,a5 101cc: fe442787 flw fa5,-28(s0) 101d0: 10f777d3 fmul.s fa5,fa4,fa5 101d4: c02797d3 fcvt.l.s a5,fa5,rtz 101d8: fef43423 sd a5,-24(s0) 101dc: fe843783 ld a5,-24(s0) 101e0: 2781 sext.w a5,a5 101e2: 853e mv a0,a5 101e4: 60e2 ld ra,24(sp) 101e6: 6442 ld s0,16(sp) 101e8: 6105 addi sp,sp,32 101ea: 8082 ret .... ... gdb 查看CPU寄存器-print $x0-p $x0-p $pc-info reg-display $x0 ;每跑一步都会显示寄存器-ni ;next inst","link":"/riscv/20181125_gdb_debug.html"},{"title":"RISCV C开发调试笔记","text":"hello.c12345678#include &lt;stdio.h&gt;int main(){ long a = 0x876543210 ; float pi = 3.1415926 ; printf(\"Hello %s!\\n\",\"World\"); a = a*pi; return a ;} 如何指定target编译riscv64-unknown-elf-gcc -c hello.c mylib.c i2c.c 只会编译生成hello.o myprint.o i2c.o ,但不会生成.out可执行文件 12``````mylib.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162````riscv64-unknown-elf-gcc hello.c mylib i2c.c -o hello_exec.out ` 不仅会编译还会链接成最终的可执行文件hello.out链接后的地址从101b0开始### 如何生成汇编代码`riscv64-unknown-elf-gcc -S hello.c` 只会生成汇编代码hello.s 不会生成.out文件```s .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC2: .string &quot;World&quot; .align 3.LC3: .string &quot;Hello %s!\\n&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd ra,24(sp) sd s0,16(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) sd a5,-24(s0) lui a5,%hi(.LC1) flw fa5,%lo(.LC1)(a5) fsw fa5,-28(s0) lui a5,%hi(.LC2) addi a1,a5,%lo(.LC2) lui a5,%hi(.LC3) addi a0,a5,%lo(.LC3) call printf ld a5,-24(s0) fcvt.s.l fa4,a5 flw fa5,-28(s0) fmul.s fa5,fa4,fa5 fcvt.l.s a5,fa5,rtz sd a5,-24(s0) ld a5,-24(s0) sext.w a5,a5 mv a0,a5 ld ra,24(sp) ld s0,16(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 .align 2.LC1: .word 1078530010 .ident &quot;GCC: (GNU) 8.1.0&quot; 如何反汇编.out文件首先生成.out文件riscv64-unknown-elf-gcc -o hello.out hello.c 然后反汇编 riscv64-unknown-elf-objdump -d hello.out &gt; hello_disassemble.s 即可查看反汇编代码,搜索main函数如下，当然也包括其他内置函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748hello.out: file format elf64-littleriscvDisassembly of section .text:00000000000100b0 &lt;_start&gt;: 100b0: 0000d197 auipc gp,0xd 100b4: fd818193 addi gp,gp,-40 # 1d088 &lt;__global_pointer$&gt; 100b8: 84818513 addi a0,gp,-1976 # 1c8d0 &lt;_edata&gt; 100bc: 8d818613 addi a2,gp,-1832 # 1c960 &lt;_end&gt; ..... ...000000000001038c &lt;printf&gt;: 1038c: 711d addi sp,sp,-96 1038e: f832 sd a2,48(sp) 10390: fc36 sd a3,56(sp) .... ..0000000000010198 &lt;main&gt;: 10198: 1101 addi sp,sp,-32 1019a: ec06 sd ra,24(sp) 1019c: e822 sd s0,16(sp) 1019e: 1000 addi s0,sp,32 101a0: 67e9 lui a5,0x1a 101a2: a687b783 ld a5,-1432(a5) # 19a68 &lt;__clzdi2+0x54&gt; 101a6: fef43423 sd a5,-24(s0) 101aa: 67e9 lui a5,0x1a 101ac: a707a787 flw fa5,-1424(a5) # 19a70 &lt;__clzdi2+0x5c&gt; 101b0: fef42227 fsw fa5,-28(s0) 101b4: 67e9 lui a5,0x1a 101b6: a5078593 addi a1,a5,-1456 # 19a50 &lt;__clzdi2+0x3c&gt; 101ba: 67e9 lui a5,0x1a 101bc: a5878513 addi a0,a5,-1448 # 19a58 &lt;__clzdi2+0x44&gt; 101c0: 1cc000ef jal ra,1038c &lt;printf&gt; 101c4: fe843783 ld a5,-24(s0) 101c8: d027f753 fcvt.s.l fa4,a5 101cc: fe442787 flw fa5,-28(s0) 101d0: 10f777d3 fmul.s fa5,fa4,fa5 101d4: c02797d3 fcvt.l.s a5,fa5,rtz 101d8: fef43423 sd a5,-24(s0) 101dc: fe843783 ld a5,-24(s0) 101e0: 2781 sext.w a5,a5 101e2: 853e mv a0,a5 101e4: 60e2 ld ra,24(sp) 101e6: 6442 ld s0,16(sp) 101e8: 6105 addi sp,sp,32 101ea: 8082 ret .... ... 更多信息尝试riscv64-unknown-elf-objdump --help123456789101112131415161718192021Usage: objdump &lt;option(s)&gt; &lt;file(s)&gt; Display information from object &lt;file(s)&gt;. At least one of the following switches must be given: -a, --archive-headers Display archive header information -f, --file-headers Display the contents of the overall file header -h, --[section-]headers Display the contents of the section headers -x, --all-headers Display the contents of all headers -d, --disassemble Display assembler contents of executable sections -D, --disassemble-all Display assembler contents of all sections -s, --full-contents Display the full contents of all sections requested -G, --stabs Display (in raw form) any STABS info in the file.... Display DWARF info in the file -t, --syms Display the contents of the symbol table(s) -T, --dynamic-syms Display the contents of the dynamic symbol table.... The following switches are optional: -b, --target=BFDNAME Specify the target object format as BFDNAME -m, --architecture=MACHINE Specify the target architecture as MACHINE 如何指定target编译riscv64-unknown-elf-rvgcc --target-help显示更多指定目标编译 默认 riscv64-unknown-elf-rvgcc 会生成RV64IMADF，如果你指向生成RV32IM指令集的机器码，如下操作 rvgcc -march=rv32im -mabi=ilp32 -o b_rv32im.out b.c 注意如果用-march=rvxxxx必须要加-mbi=xxxx RISC-V 编译器支持多个 ABI，具体取决于 F 和 D 扩展是否存在。RV32 的 ABI 分别名为 ilp32，ilp32f 和 ilp32d。ilp32 表示 C 语言的整型（int），长整型（long）和指针（pointer）都是 32 位，可选后缀表示如何传递浮点参数。在 lip32 中，浮点参数在整数寄存器中传递；在 ilp32f 中，单精度浮点参数在浮点寄存器中传递；在 ilp32d 中，双精度浮点参数也在浮点寄存器中传递。 自然，如果想在浮点寄存中传递浮点参数，需要相应的浮点 ISA 添加 F 或 D 扩展（见第 5 章）。因此要编译 RV32I 的代码（GCC 选项-march=rv32i），必须使用 ilp32 ABI（GCC选项-mabi=lib32）。反过来，调用约定并不要求浮点指令一定要使用浮点寄存器，因此RV32IFD 与 ilp32，ilp32f 和 ilp32d 都兼容。 对于C代码1234void main(){ int val = 0xf; val++;} gcc 使用rv32im，和默认64位编译的区别如下可以看出32im的指令都是16bit， 而右边指令集有采纳C，有压缩到16bit gdb 查看CPU寄存器RISCV-GDB启动步骤 print $x0 p $x0 p $pc info reg display $x0 ;每跑一步都会显示寄存器 ni ;next inst","link":"/riscv/20181120_riscv_c_dev_setp.html"},{"title":"IPC进程通信、消息队列","text":"计算机进程通信原理、IPC、消息队列，常见的方法 共享内存模式 消息传递模式 共享文件模式 主要使用的是前两种方法 多处理器之间通信处理器之间不能通过消息传递模式通信，只能共享内存处理器本身是异步执行的，消息队列没办法实现（接受消息和消耗消息有可能会冲突）而共享内存的方法也有可能会导致冲突，可以为不同处理器划分不同地址空间来避免冲突 单处理器进程通信进程之间的通信最常见最安全的方法就是消息队列。每个进程会维护一个消息队列（常见的是FIFO队列，也有带优先级的队列本文不做讨论） 进程A给进程B发消息，首先获取进程B消息队列（链表）的地址，将消息插入到链表后面。当进程B执行是会去取消息队列最前面的消息然后执行。由于进程A进程B是在同一处理器上占不同的时间片（跟操作系统进程的调度算法有关），同一时刻消息队列不可能即recive 又 consume，所以不存在队列读写冲突的问题。 消息可以是简单的数据编码标志，也可以携带数据（数据起始地址以及长度），或者其他数据结构体格式 scala 的Actor的消息传递也是用此方式实现。","link":"/sicp/ipc_msg_communication.html"},{"title":"RISCV 汇编指令调试","text":"RISCV汇编指令调试，立即数使用分析新建文件 test.s 123456.global main.textmain: li a5, 0x12345678 ret riscv.....gcc test.s 编译成汇编代码riscv.....gdb test.s 用调试器运行 进入调试器12345(gdb) disassemble mainDump of assembler code for function _init:0x000000000001019c &lt;+182&gt;: lui a5,0x123450x00000000000101a0 &lt;+186&gt;: addiw a5,a5,16560x00000000000101a4 &lt;+190&gt;: ret 在windows 和Ubuntu上打印的汇编信息由所区别，Windows上会打印额外的很多信息，但是从0x0000000001019c开始的3行信息都是和Ubuntu上一致。一般情况下RISCV程序地址从0x10000开始其余信息可能是一些stdio程序，并不是很清楚 用Spike 调试12345678910111213141516171819202122$: $RISCV/bin/spike -d pk a.out: until pc 0 0x1019c: reg 0 a50x0000000000000002: reg 0 #查看core0 的所有32个寄存器zero: 0x0000000000000000 ra : 0x00000000000100e2 sp : 0x000000007f7e9b50 gp : 0x00000000000123d0 tp : 0x0000000000000000 t0 : 0x00000000000100c8 t1 : 0x0000000000000000 t2 : 0x0000000000000000 s0 : 0x0000000000000000 s1 : 0x0000000000000000 a0 : 0x0000000000000001 a1 : 0x000000007f7e9b58 a2 : 0x0000000000000000 a3 : 0x0000000000000001 a4 : 0x0000000000000010 a5 : 0x0000000000000002 a6 : 0x000000000000001f a7 : 0x0000000000000000 s2 : 0x0000000000000000 s3 : 0x0000000000000000 s4 : 0x0000000000000000 s5 : 0x0000000000000000 s6 : 0x0000000000000000 s7 : 0x0000000000000000 s8 : 0x0000000000000000 s9 : 0x0000000000000000 s10 : 0x0000000000000000 s11 : 0x0000000000000000 t3 : 0x0000000000000000 t4 : 0x0000000000000000 t5 : 0x0000000000000000 t6 : 0x0000000000000000 : help #查看调试命令: run 1 #单步执行core 0: 0x000000000001019c (0x123457b7) lui a5, 0x12345: reg 0 a50x0000000012345000 #可以看到将原来的 0x0000000000000002 覆盖成 0x12345000 ,低12bit覆盖为0: run 1 core 0: 0x00000000000101a0 (0x6787879b) addiw a5, a5, 1656: reg 0 a5 0x0000000012345678 #成功写入 试验12345main: li a5, 0x12345678 li a1, 0xabc li a2, 0x12345 ret 编译后的汇编指令12345678910(gdb) disassemble main Dump of assembler code for function main:0x000000000001019c &lt;+0&gt;: lui a5,0x123450x00000000000101a0 &lt;+4&gt;: addiw a5,a5,16560x00000000000101a4 &lt;+8&gt;: lui a1,0x1 # a1=0x00001000 , 低12bit=0 0x00000000000101a8 &lt;+12&gt;: addiw a1,a1,-1348 # hex(0x1000 - 1348) = 0xabc0x00000000000101ac &lt;+16&gt;: lui a2,0x120x00000000000101b0 &lt;+20&gt;: addiw a2,a2,8370x00000000000101b4 &lt;+24&gt;: retEnd of assembler dump. 即便是小于12bit 的立即数也不能被立即load到,因为LUI指令加载的最小数是0x1000(除了0), 所以所有小于12bit的数val还是要用两条指令完成12LUI rd, 0x1 #load rd 0x1000ADDIW rd, rs, (val-0x1000) C代码编译调试例子11234void main() { int val = 1 ; val+=3 ;} 123456789101112131415161718192021 .file &quot;a.c&quot; .option nopic .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 #sp指针默认从比较大的地址开始，反向增长开辟了32byte的空间 sd s0,24(sp) #将s0的8个字节(64bit)压入栈指针-32+24=-8 addi s0,sp,32 #然后将栈BASE地址放入s0 (s0 被用来当中间寄存器) li a5,1 #加载立即数1到a5 （小于32位的立即数会直接通过立即数指令加载） 否则就需要在内存开辟双字节整形，然后通过ld 加载 sw a5,-20(s0) #给val开辟栈空间，变量都会在栈里面，只有申请内存空间才会在dynamicdata(堆) lw a5,-20(s0) #再读回来 addiw a5,a5,3 #+3 sw a5,-20(s0) #再写回去,(不开优化，每一次操作都会存取) nop ld s0,24(sp) #恢复s0 寄存器 addi sp,sp,32 #恢复栈指针 jr ra #main函数返回 .size main, .-main .ident &quot;GCC: (GNU) 8.1.0&quot; 编译后进gdb调试 a.out123456789101112131415(gdb) disassemble main Dump of assembler code for function main:0x000000000001019c &lt;+0&gt;: addi sp,sp,-320x000000000001019e &lt;+2&gt;: sd s0,24(sp) #表示sp寄存器的内容+立即数偏移240x00000000000101a0 &lt;+4&gt;: addi s0,sp,320x00000000000101a2 &lt;+6&gt;: li a5,10x00000000000101a4 &lt;+8&gt;: sw a5,-20(s0)0x00000000000101a8 &lt;+12&gt;: lw a5,-20(s0)0x00000000000101ac &lt;+16&gt;: addiw a5,a5,10x00000000000101ae &lt;+18&gt;: sw a5,-20(s0)0x00000000000101b2 &lt;+22&gt;: nop0x00000000000101b4 &lt;+24&gt;: ld s0,24(sp)0x00000000000101b6 &lt;+26&gt;: addi sp,sp,320x00000000000101b8 &lt;+28&gt;: retEnd of assembler dump. 定义大于32bit的整数12345long main(){ long val = 0x876543210; //超过32位的长整数 val+=1; return val;} 不开启优化123456789101112131415161718192021222324252627 .file &quot;a.c&quot; .option nopic .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-32 sd s0,24(sp) addi s0,sp,32 lui a5,%hi(.LC0) ld a5,%lo(.LC0)(a5) #load doubleworld from (.LC0)地址 sd a5,-24(s0) ld a5,-24(s0) addi a5,a5,1 sd a5,-24(s0) ld a5,-24(s0) mv a0,a5 ld s0,24(sp) addi sp,sp,32 jr ra .size main, .-main .section .rodata .align 3.LC0: .dword 36344967696 #开辟一块双字节的MEM空间， .ident &quot;GCC: (GNU) 8.1.0&quot; 发现超过32bit的整数，不能通过立即数加载到寄存器（立即数受限于指令的长度最大只能是32bit，而且需要两条指令完成), 只能在内存中开辟一块地址先存放0x876543210,然后ld a5,该地址 例子21234#include &lt;stdio.h&gt;void main(){ printf(\"hello world\");} hello.s 查看汇编代码1234567891011121314151617181920212223242526 .file &quot;hello.c&quot; .option nopic .text .section .rodata .align 3.LC0: .string &quot;hello world&quot; .text .align 1 .globl main .type main, @functionmain: addi sp,sp,-16 #sp 开辟16byte栈空间 sp=-16 sd ra,8(sp) #将ra的8Byte（64bit)内容从sp=-8处压栈 , 0 ~-8 存ra的值 sd s0,0(sp) #将s0的8Byte（64bit)内容从sp=-16处压栈,-8 ~-16存s0的值 addi s0,sp,16 #将sp=offset0的值存入s0 lui a5,%hi(.LC0) #计算string .LC0的地址，存入a0 addi a0,a5,%lo(.LC0) #这两条指令等价于 伪指令 li &amp;(.LC0) call printf #调用 printf 函数 ,printf 使用a0的内容作为参数 nop ld ra,8(sp) #恢复栈 0~-8 的内容到ra ld s0,0(sp) #恢复栈-8~-16的内容到s0 addi sp,sp,16 #栈指针恢复到0 jr ra #返回ra .size main, .-main .ident &quot;GCC: (GNU) 8.1.0&quot; gdb hell.out 查看汇编以后的机器码123456789101112131415(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: sd s0,0(sp) 0x000000000001019e &lt;+6&gt;: addi s0,sp,16 0x00000000000101a0 &lt;+8&gt;: lui a5,0x1a # (.LC0)的起始地址就是0x19a10 0x00000000000101a2 &lt;+10&gt;: addi a0,a5,-1520 # 0x19a10 0x00000000000101a6 &lt;+14&gt;: jal ra,0x10354 &lt;printf&gt; # pc+4 存入ra, 跳转到pc+0x10354*2的printf函数地址 0x00000000000101aa &lt;+18&gt;: nop 0x00000000000101ac &lt;+20&gt;: ld ra,8(sp) # 恢复ra 0x00000000000101ae &lt;+22&gt;: ld s0,0(sp) # 恢复s0 0x00000000000101b0 &lt;+24&gt;: addi sp,sp,16 # 释放栈 0x00000000000101b2 &lt;+26&gt;: retEnd of assembler dump. print内容稍加修改1234#include &lt;stdio.h&gt;void main(){ printf(\"Hello %s!\\n\",\"World\");} 查看效果1234567891011121314151617(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: sd s0,0(sp) 0x000000000001019e &lt;+6&gt;: addi s0,sp,16 0x00000000000101a0 &lt;+8&gt;: lui a5,0x1a 0x00000000000101a2 &lt;+10&gt;: addi a1,a5,-1504 # 0x19a20 #加载字符串&quot;Hello %s!\\n&quot; 的地址 0x00000000000101a6 &lt;+14&gt;: lui a5,0x1a 0x00000000000101a8 &lt;+16&gt;: addi a0,a5,-1496 # 0x19a28 #加载字符串&quot;Wrold&quot;的地址 0x00000000000101ac &lt;+20&gt;: jal ra,0x1035a &lt;printf&gt; #调用printf, printf会从a0,a1内获取参数 0x00000000000101b0 &lt;+24&gt;: nop 0x00000000000101b2 &lt;+26&gt;: ld ra,8(sp) 0x00000000000101b4 &lt;+28&gt;: ld s0,0(sp) 0x00000000000101b6 &lt;+30&gt;: addi sp,sp,16 0x00000000000101b8 &lt;+32&gt;: retEnd of assembler dump. 字符串的只需要知道起始地址即可，结束位由隐藏的固定格式构成 例31234567#include &lt;stdio.h&gt;int main(){ int a = 2 ; printf(\"Hello %s!\\n\",\"World\"); a++; return a ;} 查看机器码1234567891011121314151617181920212223(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-32 # 开辟32Byte栈空间 0x000000000001019a &lt;+2&gt;: sd ra,24(sp) # 0 ~-8 存ra 0x000000000001019c &lt;+4&gt;: sd s0,16(sp) #-9 ~-16存s0 0x000000000001019e &lt;+6&gt;: addi s0,sp,32 # 栈根给s0 0x00000000000101a0 &lt;+8&gt;: li a5,2 0x00000000000101a2 &lt;+10&gt;: sw a5,-20(s0) # 2存入a5 压栈到-16~-20 0x00000000000101a6 &lt;+14&gt;: lui a5,0x1a # a0 0x00000000000101a8 &lt;+16&gt;: addi a1,a5,-1488 # 0x19a30 #加载字符串&quot;Hello %s!\\n&quot; 的地址到a1 0x00000000000101ac &lt;+20&gt;: lui a5,0x1a 0x00000000000101ae &lt;+22&gt;: addi a0,a5,-1480 # 0x19a38 #加载字符串&quot;World&quot; 的地址到a0 0x00000000000101b2 &lt;+26&gt;: jal ra,0x1036e &lt;printf&gt; 0x00000000000101b6 &lt;+30&gt;: lw a5,-20(s0) #从栈-20 读出32bit=4Byte 出来 0x00000000000101ba &lt;+34&gt;: addiw a5,a5,1 0x00000000000101bc &lt;+36&gt;: sw a5,-20(s0) 0x00000000000101c0 &lt;+40&gt;: lw a5,-20(s0) 0x00000000000101c4 &lt;+44&gt;: mv a0,a5 #a++结果从栈中读出给a0 ,a0 a1 寄存器常用作返回值 0x00000000000101c6 &lt;+46&gt;: ld ra,24(sp) 0x00000000000101c8 &lt;+48&gt;: ld s0,16(sp) 0x00000000000101ca &lt;+50&gt;: addi sp,sp,32 0x00000000000101cc &lt;+52&gt;: ret #返回End of assembler dump. 开启优化选项 -O1234567891011121314(gdb) disassemble mainDump of assembler code for function main: 0x0000000000010198 &lt;+0&gt;: addi sp,sp,-16 0x000000000001019a &lt;+2&gt;: sd ra,8(sp) 0x000000000001019c &lt;+4&gt;: lui a1,0x1a 0x00000000000101a0 &lt;+8&gt;: addi a1,a1,-1520 # 0x19a10 0x00000000000101a4 &lt;+12&gt;: lui a0,0x1a 0x00000000000101a8 &lt;+16&gt;: addi a0,a0,-1512 # 0x19a18 0x00000000000101ac &lt;+20&gt;: jal ra,0x10358 &lt;printf&gt; 0x00000000000101b0 &lt;+24&gt;: li a0,3 # 2 + 1 =3 在编译阶段就计算完 0x00000000000101b2 &lt;+26&gt;: ld ra,8(sp) 0x00000000000101b4 &lt;+28&gt;: addi sp,sp,16 0x00000000000101b6 &lt;+30&gt;: retEnd of assembler dump. 总结LUI 指令会讲20比特的立即数放到 寄存器的31:12位置，并且将低12bit覆盖为0 ADDIW 指令会将 rs1 寄存器的值导入到rd 寄存器，并且用立即数[11:0] 覆盖 rd的低12比特 LU是伪指令，因为汇编指令的立即数肯定小于32bit，所以为了实现完整的32bit的立即数load 编译器使用了2条指令LUI,ADDIW 实现了LU的功能 对于一般变量比如int类型，会分配给栈来存放 如果比较大的常数变量，超过32bit或者64bit的数， 地址会分配堆内存给地址 对于数字串分配堆内存地址 参考-RISC-V Reference Card(指令绿卡片) -RISC-V 指令集编码","link":"/riscv/20181116_RISCV_inst_test.html"},{"title":"综合时序分析回顾","text":"时序分析静态时序分析工具STA，在分析时序的时候会统一从一个点出发开始计算分析（这样才有可行性），往往是从时钟PLL出来以后开始计算 一般情况下都会设一个clock network delay 表示从PLL 到寄存器段clk的群延迟 ，理想情况下，到每个寄存器的群延迟都是一样的（时钟balance） 看一个timing报告： 1234567891011121314151617181920212223242526272829303132333435363738394041**************************************** Startpoint: U_xx/_ram_sp1024x8/srsp_1024x8 (rising edge-triggered flip-flop clocked by clk) Endpoint: U_xx/nS_bit_reg_1_ (rising edge-triggered flip-flop clocked by clk) Path Group: clk Path Type: max Des/Clust/Port Wire Load Model Library ------------------------------------------------ xx_top ZeroWireload tef40ulp128x8hd_ph_ssg0p99v2p25vm40c Point Incr Path -------------------------------------------------------------------------- clock clk (rise edge) 0.0000 0.0000 clock network delay (ideal) 2.0000 2.0000 #时钟群延迟设为2ns xx/srsp_1024x8/CLK (sadr41p1024x8m4b1) 0.0000 2.0000 r #arrival + 2ns xx/srsp_1024x8/Q[0] (sadr41p1024x8m4b) 2.2361 4.2361 f xx/U37/X (SVN_ND2_T_2) 0.0290 4.2651 r xx/U47/X (SVN_ND2_2) 0.0323 4.2974 f .... .. xx/U188/X (SVN_EN2_F_1) 0.0956 4.8690 f xx/nS_bit_reg_1_/D (SVN_FSDPRBQ_D_4) 0.0000 4.8690 f data arrival time 4.8690 clock clk (rise edge) 3.3300 3.3300 #300Mhz = 3.33ns clock network delay (ideal) 2.0000 5.3300 #required + 2 =5.33ns clock uncertainty 0.3000 5.0300 #恶化抖动 xxx/nS_bit_reg_1_/CK (SVN_FSDPRBQ_D_4) 0.0000 5.0300 r library setup time 0.3303 4.6997 #- setup time data required time 4.6997 -------------------------------------------------------------------------- data required time 4.6997 # = clk_arvl_time - Setuptime - skew data arrival time -4.8690 # -------------------------------------------------------------------------- slack (VIOLATED) -0.1693**************************************** Clock Setup Slack = Data Required Time – Data Arrival Time Clock Arrival Time = Latch Edge + Clock Network Delay to Destination Register Data Required = Clock Arrival Time – μtSU – Setup Uncertainty Data Arrival Time = Launch Edge + Clock Network Delay Source Register + μtCO + Register-to-Register Delay","link":"/eda/timing_analysis.html"},{"title":"Terminal配置常见问题","text":"Teriminal 配置常见问题 ls后文件名包含引号,例如 'Program file' 在 ~/.zshrc 里面配置 MACOS ls 目录后没有颜色显示， 'alias ls =/bin/ls -G' , 一定要指到/bin/ls 其他","link":"/others/terminal_FAQ.html"},{"title":"SBT 版本问题","text":"QA sbt 指向 “java -Dsbt.ivy.home=/nishome/jijing/ivy2 -jar /DATA/jijing/rocket-chip/sbt-launch.jar” 现象ivy2 也是最新的，包含 org.scala-lang#scala-library;2.11.12 正确的版本号 依然会报错！！ 12345[warn] ::::::::::::::::::::::::::::::::::::::::::::::[warn] :: UNRESOLVED DEPENDENCIES ::[warn] ::::::::::::::::::::::::::::::::::::::::::::::[warn] :: org.scala-lang#scala-library;2.11.12: public: unable to get resource for org/scala-lang#scala-library;2.11.12: res=https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.11.12/scala-library-2.11.12.pom: java.net.UnknownHostException: repo1.maven.org: Temporary failure in name resolution[warn] :::::::::::::::::::::::::::::::::::::::::::::: 原因 ~/.sbt 目录可能存在旧的版本，导致问题， 解决 删除 ~/.sbt 目录，如果联网，直接重新sbt run ，会自动下载更新，否则copy 别的机子上正确的 .sbt 到home 目录下。 IDEA，rochi-chip:sync failed ，但在terminal下正常编译 ，也是~/.sbt导致的 C 程序编译好的.out文件不能再 rocket-chip/emulator 目录下运行，而 run-asm-isa-test 则会没有问题 这是由于直接用rvgcc 编译的文件，并没有按照处理器的格式做link，因此想要正确的在处理器上运行，需要正确的link 可以参见 bootrom/link.lds 文件 ： 1234567891011 1 SECTIONS 2 { 3 ROM_BASE = 0x10000; /* ... but actually position independent */ 4 5 . = ROM_BASE; 6 .text.start : { *(.text.start) } 7 . = ROM_BASE + 0x40; 8 .text.hang : { *(.text.hang) } 9 . = ROM_BASE + 0x80;10 .rodata.dtb : { *(.rodata.dtb) }11 } rvgcc -T link.ld bootrom.S -nostdlib -static -wl,--no-gc-section -o bootrom.img 同理C代码编译的时候也需要使用正确的linkfile 文件 。 如何编译指定CPU的可执行文件必要信息： $(CC) 需要默认的target (例如intel x86, AMD64, MIPS 等等， 如果RISCV， 需要支持的指定指令集 (例如 rv32imc rv64g,rv32imdfc 等等) link 脚本，如果不指定，会有导入默认的脚本，否则需要显示指定，尤其是自己设计的处理器，需要显式的指定堆栈起始地址，程序默认存放地址，这些信息响应的也会体现在CPU硬件设计当中。需要正确match 12","link":"/eda/20181130_sy_QA.html"},{"title":"综合时序分析回顾","text":"关于计算机大小端一般计算机所讲的大小端指的是字节序的大小端，比特序一般默认都是小端无论字节序为大端还是小端 字节序大小端HSB(大端格式):按字节从大到小排布123byte0,byte1,byte2,byte3byte4,byte5,byte6,byte7... LSB(小端格式):按字节从小到大排布123byte3,byte2,byte1,byte0byte7,byte6,byte5,byte4... 比特序大小端bit大端 =[01234567]bit小端 =[76543210]一般常见的都是bit小端","link":"/others/lsb_hsb.html"},{"title":"VCS仿真option","text":"VCS、verdi的命令的配置该Makefile可作为仿真工作脚本，参考了开源处理器蜂鸟e200的仿真环境 https://github.com/SI-RISCV/e200_opensource/blob/master/vsim/bin/run.makefile 1234567891011121314151617181920212223242526272829303132333435363738394041424344RUN_DIR := ${PWD}TESTCASE := 00DUMPWAVE := 1VSRC_DIR := ${RUN_DIR}/../rtlVTB_DIR := ${RUN_DIR}/../tbINC_DIR := ${RUN_DIR}/../rtl/dir_inc_defines1INC_DIR += ${RUN_DIR}/../rtl/dir_inc_defines2# TESTNAME := $(notdir $(patsubst %.dump,%,${TESTCASE}.dump))TESTNAME := case${TESTNAME}TEST_RUNDIR := ${TESTNAME}RTL_V_FILES := $(wildcard ${VSRC_DIR}/*/*.v)TB_V_FILES := $(wildcard ${VTB_DIR}/*.v)# The following portion is depending on the EDA tools you are using, Please add them by yourself according to your EDA vendorsSIM_TOOL := vcs # this is a free solution here to use iverilog to compile the codeSIM_OPTIONS := -sverilog -debug_all +incdir+${INC_DIR} -timescale=1ns/100ps +notimingcheck +nospecify +v2k +memcbk -fsdb -l com.log SIM_EXEC := ${RUN_DIR}/simv -l sim.log +notimingcheck +nospecify +loopreport +memcbk +novoptWAV_TOOL := verdi #To-ADD: to add the waveform toolWAV_OPTIONS := -timescale=1ns/100ps +notimingcheck +nospecify #To-ADD: to add the waveform tool options WAV_PFIX := #To-ADD: to add the waveform file postfixall: runcompile.flg: ${RTL_V_FILES} ${TB_V_FILES} @-rm -rf compile.flg ${SIM_TOOL} ${SIM_OPTIONS} ${RTL_V_FILES} ${TB_V_FILES} ; touch compile.flgcompile: compile.flg wave: # gvim -p ${TESTCASE}.spike.log ${TESTCASE}.dump &amp; ${WAV_TOOL} ${WAV_OPTIONS} ${RTL_V_FILES} ${TB_V_FILES} &amp; run: compile rm -rf ${TEST_RUNDIR} mkdir ${TEST_RUNDIR} cd ${TEST_RUNDIR}; ${SIM_EXEC} +DUMPWAVE=${DUMPWAVE} +TESTCASE=${TESTCASE} |&amp; tee ${TESTNAME}.log; cd ${RUN_DIR}; .PHONY: run clean all","link":"/eda/eda_option.html"},{"title":"晶振，PLL, VCO介绍","text":"晶振，vco区别晶振分有源晶振和无源晶振，一般会产生1～200Mhz时钟频率vco亚控振荡器，可以产生比较高的频率比如2Ghz，但是不稳定 为什么既要晶振还要vco？就是为了能够产生稳定的高频时钟信号，就需要用到PLL, PLL内部会有一个VCO 产生高频时钟，通过分频器假设得到10分频的时钟2，再拿这个时钟2和晶振产生的100mhz基用鉴相器做比较，输出一个比较的波形后经过低通滤波，用输出电压控制VCO的输出, 那么就能是vco输出的高频时钟得到稳定的频率，达到了倍频的效果。 20Mhz一下的晶振基本上都是基频的器件，稳定度好，20mhz以上的晶振大多是谐波(如3次，5次谐波)稳定度差，因此强烈建议使用低频的器件，毕竟倍频器用的pll电路需要的周边配置主要是电容，电阻，电感，其稳定度和价格方面要远远浩宇晶体晶振器件。 如果只需要一个20mhz以内的时钟频率，完全可以不用pll，直接接晶振就够了 晶振一般有哪些参数晶振有几个重要参数： 1，晶体元件规格书中所指定的频率，也是工程师在电路设计和元件选购时首要关注的参数。晶振常用标称频率在1～200MHz之间，比如32768Hz、8MHz、12MHz、24MHz、125MHz等，更高的输出频率也常用PLL（锁相环）将低频进行倍频至1GHz以上。我们称之为标称频率。 2，输出信号的频率不可避免会有一定的偏差，我们用频率误差（Frequency Tolerance）或频率稳定度（Frequency Stability），用单位ppm来表示，即百万分之一（parts per million）（1/106），是相对标称频率的变化量，此值越小表示精度越高。比如，12MHz晶振偏差为±20ppm，表示它的频率偏差为12×20Hz=±240Hz，即频率范围是（11999760～12000240Hz） 3，还有一个温度频差（Frequency Stability vs Temp）表示在特定温度范围内，工作频率相对于基准温度时工作频率的允许偏离，它的单位也是ppm。 4，另外，负载电容CL（Load capacitance），它是电路中跨接晶体两端的总的有效电容（不是晶振外接的匹配电容），主要影响负载谐振频率和等效负载谐振电阻，与晶体一起决定振荡器电路的工作频率，通过调整负载电容，就可以将振荡器的工作频率微调到标称值。更准确而言，无源晶体的负载电容是一项非常重要的参数，因为无源晶体属于被动元器件，所谓的被动元器件即是自身不能工作，需要外部元器件协助工作，无源晶体即是！ 其中： CS为晶体两个管脚之间的寄生电容（又名晶振静态电容或Shunt Capacitance），在晶体的规格书上可以找到具体值，一般0.2pF~8pF不等。如图二是某32.768KHz的电气参数，其寄生电容典型值是0.85pF（在表格中采用的是Co）。 CG指的是晶体振荡电路输入管脚到GND的总电容，其容值为以下三个部分的和。 需加外晶振主芯片管脚芯到GND的寄生电容 Ci 晶体震荡电路PCB走线到到GND的寄生电容CPCB 电路上外增加的并联到GND的外匹配电容 CL1CD指的是晶体振荡电路输入管脚到GND的总电容。容值为以下三个部分的和。 需加外晶振主芯片管脚芯到GND的寄生电容, Co 晶体震荡电路PCB走线到到gnd的寄生电容，CPCB 电路上外增加的并联到GND的外匹配电容, CL2 既然晶振的负载电容是一个非常重要的参数，如果此项参数与外部电容匹配不正确会导致什么样的现象？晶振两端的等效电容与晶振标称的负载电容匹配不正确，晶振输出的谐振频率将与标称工作的工作频率会产生一定偏差（又称之为频偏），负载电容（load capacitance）主要影响负载谐振频率和等效负载谐振电阻，它与石英谐振器一起决定振荡器的工作频率，通过调整负载电容，一般可以将振荡器的工作频率调到标称值。应用时我们一般外接电容，便是为了使晶振两端的等效电容等于或接近负载电容，对于要求高的场合还要考虑ic输入端的对地电容，这样便可以使得晶振工作的频率达到标称频率。所以合理匹配合适的外加电容使晶振两端的等效电容等于或接近负载电容显得十分重要。 负载电容常用的标准值有12.5 pF，16 pF，20 pF，30pF,负载电容和谐振频率之间的关系不是线性的，负载电容变小时，频率偏差量变大；负载电容提高时，频率偏差减小。图3是一个晶体的负载电容和频率的误差的关系图。 例外情况： 现在有很多芯片内部已经增加了补偿电容（internal capacitance），所以在设计的时候，只需要选按照芯片datasheet推荐的负载电容值的选择晶体即可，不需要额外再加电容。但是因为实际设计的寄生电路的不确定性，最好还是预留CL1/CL2的位置。","link":"/others/crystals-pll-vco.html"},{"title":"Verilog仿真不打拍分析","text":"现象例如：出现： 原因这是由于采样的时钟tx_gen_symbol_clk 和数据信号subframe_start之间存在竞争关系导致的。我们的设计意图是时钟tx_gen_symbol_clk应该采到subframe_start信号的后沿有人可能会说在代码中加入延迟#1来解决，实际上不推荐这样做，还会存在两个#1的信号同样还会存在竞争。 仿真模型原理分析要搞清楚产生这种问题的原因首先要了解仿真器对于时序仿真的模型。第4级的时钟不能正常采到第3级输出的数据，但是第2级的时钟能采到第二级时钟打出来的数据（D3），原因就是，仿真器会在寄存器输出的时候添加一个虚拟的延迟δ，虽然这个虚拟延迟我们是看不到的，在仿真器上都是0，但是对于仿真器工作的时候，到遇到always采样事件时先要判断这个δ延迟，决定触发器的采样输出。（当延迟相等时，clk延迟的优先级会比data延迟的优先级高，即clk1能采到D1的前沿， 也就是我们看到的数据不打拍，这跟我们的预期是不一致的，而clk1能采不到D2的前沿，但能采到D2的后沿，这跟我们的预期一样的。这些讨论仅限于前仿，实际器件上我们必须有时序约束来保证建立保持时间，也不会存在这样的问题。但是硬件设计就是要保证仿真和物理器件一致。因此我们要注意这个现象。 如何解决 在你的TB里时钟都由一个单独的模块产生送给DUT，不管产生多少个时钟，这些时钟保证都经历了n级分频下来的然后送入DUT，这样数据就不会出现不delay的现象。","link":"/eda/verilog_simu_0delay.html"}],"tags":[{"name":"Chisel","slug":"Chisel","link":"/tags/Chisel/"},{"name":"verilog","slug":"verilog","link":"/tags/verilog/"},{"name":"firrtl","slug":"firrtl","link":"/tags/firrtl/"},{"name":"计算机","slug":"计算机","link":"/tags/计算机/"},{"name":"riscv","slug":"riscv","link":"/tags/riscv/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"开发环境","slug":"开发环境","link":"/tags/开发环境/"},{"name":"scala","slug":"scala","link":"/tags/scala/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/函数式编程/"},{"name":"verctor","slug":"verctor","link":"/tags/verctor/"},{"name":"make","slug":"make","link":"/tags/make/"}],"categories":[{"name":"chisel","slug":"chisel","link":"/categories/chisel/"},{"name":"eda","slug":"eda","link":"/categories/eda/"},{"name":"others","slug":"others","link":"/categories/others/"},{"name":"riscv","slug":"riscv","link":"/categories/riscv/"},{"name":"scala","slug":"scala","link":"/categories/scala/"},{"name":"sicp","slug":"sicp","link":"/categories/sicp/"}]}